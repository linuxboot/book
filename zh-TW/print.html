<!DOCTYPE HTML>
<html lang="zh-TW" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>LinuxBoot</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        <script>
            const mdbookPath = "print.md";
            const mdbookPathToRoot = "";
        </script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/css/language-picker.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">LinuxBoot</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/linuxboot/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="linuxboot介紹"><a class="header" href="#linuxboot介紹">LinuxBoot介紹</a></h1>
<p>這是 LinuxBoot 專案的官方「LinuxBoot 書籍」。這本書：</p>
<ul>
<li>描述 LinuxBoot 項目</li>
<li>解釋為什麼要使用 LinuxBoot</li>
<li>描述組成 LinuxBoot 的元件</li>
<li>說明其他啟動系統（如 UEFI）與 LinuxBoot 的差異</li>
<li>指導您完成實作 LinuxBoot 所需的步驟</li>
</ul>
<h2 id="什麼是-linuxboot"><a class="header" href="#什麼是-linuxboot">什麼是 LinuxBoot？</a></h2>
<p>LinuxBoot 的想法是用 Linux 核心和基於社群的用戶空間（user-space） 取代專有或企業主導的後期啟動<a href="./glossary.html">韌體</a>。這個想法逐漸發展成為一個項目，多年來包括各種舉措，其總體目標是從晦澀複雜的韌體轉變為更簡單和開源的韌體。</p>
<p>The LinuxBoot project provides two reference implementations; <code>linuxboot</code> and Heads. The <a href="https://github.com/linuxboot/linuxboot"><code>linuxboot</code></a> build system outputs a boot payload consisting of a Linux kernel and an <a href="https://de.wikipedia.org/wiki/Initramfs">initramfs</a> that contains a minimal Go user-space built using <a href="https://github.com/u-root/u-root">u-root</a>.</p>
<p>Heads 構建系統更側重於本地證明（local attestation）、TPM DUK 密封/解封（seal/unseal）操作、基於 GPG 的安全措施、可重現構建（reproducible builds），並使用 BusyBox 提供更大的 Linux 工具套件，使其也可以用作修復環境（recovery environment）。</p>
<p>許多其他實作獨立於專案而存在：</p>
<ul>
<li><a href="https://github.com/open-power/petitboot">petitboot</a> 屬於 OpenPOWER 項目，最初針對的是 PS3</li>
<li><a href="https://github.com/BayLibre/k-boot">k-boot</a> 由 BayLibre 於 2023 年使用 BusyBox 開發</li>
<li><a href="https://github.com/rhboot/nmbl-poc">nmbl</a> 由 RedHat 於 2024 年開發</li>
<li><a href="https://docs.zfsbootmenu.org/en/latest">ZFSBootMenu</a></li>
</ul>
<p>此外，過去也曾有許多類似的實作，其中包含一些已不再維護的專案：</p>
<ul>
<li>Alpha 版 MILO 於 2000 年之前就已啟動（請參閱<a href="https://tldp.org/HOWTO/MILO-HOWTO/what-section.html">什麼是 MILO？</a>）</li>
<li>kboot 由 Werner Almesberger 於 2005 年開發</li>
</ul>
<p>這些專案都試圖將韌體的角色簡化為一個小型、固定功能的核心，其唯一目的是啟動一個儲存在快閃記憶體（flash）中的 Linux 核心（Linux kernel）。這個「最低必要」（bare essentials）的韌體會負責初始化硬體，接著啟動 Linux 核心，並讓使用者空間環境（user-space environment）在機器上運行。Go 是建議使用的使用者空間環境，但並非必須。</p>
<h2 id="為什麼需要-linuxboot"><a class="header" href="#為什麼需要-linuxboot">為什麼需要 LinuxBoot</a></h2>
<p>有時候，韌體會包含驅動程式和工具程式（utilities）。這些元件可能存在漏洞，或是已無人維護，進而成為問題或資安風險的來源。LinuxBoot 以 Linux 驅動程式取代了供應商提供的專有閉源韌體驅動（proprietary, closed-source firmware drivers），讓開發 Linux 驅動與韌體驅動的工程師能專注於同一套驅動程式。如此一來，這些驅動程式將擁有更多的貢獻者 (contributors) 與審閱者（reviewers），又因為它們是 Linux 的一部分，能夠運用業界標準的開發流程與工具（standard industry coding infrastructure）來持續改善。最終，由於這些 Linux 驅動目前已在大量系統上長時間穩定運作（run around the clock at scale），其錯誤率也會相對較低。</p>
<h2 id="linuxboot-的功能"><a class="header" href="#linuxboot-的功能">LinuxBoot 的功能</a></h2>
<p>LinuxBoot 以 Linux 應用程式取代了統一可擴充韌體介面（Unified Extensible Firmware Interface，UEFI）與其他韌體中大量的驅動程式執行環境（Driver Execution Environment，DXE）模組，特別是網路協定堆疊（network stack）和檔案系統（file system）模組。</p>
<p>LinuxBoot 將 Linux 核心（Linux kernel）作為快閃記憶體（flash ROM）中的驅動程式執行環境（Driver Execution Environment, DXE）啟動，而非傳統的 UEFI shell。接著，Linux 核心可透過隨附的基於 Go 的使用者空間（user-space）來載入運行時核心（runtime kernel）。LinuxBoot 的架構（paradigm）使得傳統的韌體應用程式（例如開機載入器、偵錯工具、診斷與錯誤偵測應用程式）能夠以跨架構、跨平台的可攜式 Linux 應用程式形式實作。</p>
<p>當 Linux 啟動時，它需要一個包含工具程式（utilities）的根檔案系統（root file system）。LinuxBoot 使用的其中一種根檔案系統是基於使用 Go 語言編寫的 u-root 標準工具程式（standard utilities）。下圖顯示了目前 UEFI 啟動過程的狀況，以及計畫中的 LinuxBoot 過渡流程。</p>
<p><a href="./images/UEFI-versus-LinuxBoot.svg"><img src="./images/UEFI-versus-LinuxBoot.svg" alt="comparison of UEFI boot and LinuxBoot" /></a></p>
<h2 id="使用-go-使用者空間user-space環境和編譯器的好處"><a class="header" href="#使用-go-使用者空間user-space環境和編譯器的好處">使用 Go 使用者空間(user-space)環境和編譯器的好處</a></h2>
<p>Go 是由 Google 創建的系統程式語言。Go 具有強類型（strong typing）、語言級別的並發支援（concurrency support）、透過通道（channels）進行進程間通訊（inter-process communication）、運行時類型安全性（runtime type safety）和其他保護措施、動態分配（dynamic allocation）和垃圾收集（garbage collection）以及閉包（closures）。Go 具有與 Java 類似的套件名稱符號（package name notation），使得可以清楚地確定給定程式需要哪些套件（packages）。</p>
<p>現代語言結構使 Go 成為比 C 更安全的語言。這種安全性對於網路連接的嵌入式系統至關重要，這些系統通常擁有用 C 編寫的網路工具程式，包括網頁伺服器、包含 sshd 的網路伺服器（network servers），以及提供命令解釋器存取的程式（本身以 C 編寫）。所有這些都證明容易受到互聯網成為攻擊頻繁環境的威脅。</p>
<p>即使是最熟練的程式設計師也會犯下 C 語言中無法恢復的錯誤，尤其是在網路連線系統上。目前，即使我們個人電腦、印表機和恆溫器中最低等級的韌體也是連網的。這些程式錯誤要麼在 Go 中不可能犯，要麼如果犯了，則會在運行時檢測到並導致程式退出。</p>
<p>在低階嵌入式韌體中使用像 Go 這樣的高級安全語言的理由，可能比用戶程式更為充分，因為在韌體層級的漏洞幾乎不可能被檢測和緩解。</p>
<p>在韌體等儲存受限的環境中使用 Go 的挑戰在於，高階語言特性會導致二進位檔案過大。即使是簡單的日期程式也約有 2 MiB。一個實現單一功能的 Go 二進位檔案大小是實現多個功能的 BusyBox 二進位檔案的兩倍。當前，典型的 BIOS 快閃記憶體（FLASH）大小為 16 MiB。將多個 Go 二進位檔案裝入單一 BIOS 快閃記憶體區塊是不切實際的。Go 編譯器速度非常快，且其速度顯示了只有在使用程式時進行編譯的解決方案。透過這種方式，您可以建立一個幾乎不含二進位檔案（除了 Go 編譯器本身）的根檔案系統。編譯後的程式和套件可儲存到基於 RAM 的檔案系統中。另一個解決方案是將所有程式編譯成一個 BusyBox 風格的程式。或者，程式可以透過網路獲取，但動態編譯 Go 或創建 BusyBox 程式是建議的解決方案。</p>
<h2 id="在-uefi-伺服器上使用-linuxboot-的好處"><a class="header" href="#在-uefi-伺服器上使用-linuxboot-的好處">在 UEFI 伺服器上使用 LinuxBoot 的好處</a></h2>
<p>大多數伺服器韌體基於 Intel 的通用可擴展韌體介面 (UEFI)。與 UEFI 相比，LinuxBoot 具有以下優點：</p>
<p>可靠性</p>
<ul>
<li>透過使用強化的 Linux 驅動程式取代未經充分測試的韌體驅動程式來提高啟動可靠性</li>
<li>近 20 年來，在軍事、消費性電子和超級電腦領域，可靠性和性能至關重要的領域，該實踐方法已得到驗證</li>
<li>容錯 - Linux 隔離程序** **（例如，當「pxeboot」發生災難性故障時，「diskboot」仍然可以運作）</li>
</ul>
<p>安全性</p>
<ul>
<li>將“Ring 0”引導程式（bootloaders）移至“Ring 3”</li>
<li><code>pxeboot</code> 和 <code>diskboot</code> 在使用者空間（user-space）進行解析和其他邏輯處理</li>
<li>Go 提供記憶體安全和類型安全（type safety）
<ul>
<li>有缺陷的解析器（parser）不太可能影響其他程式</li>
</ul>
</li>
<li>核心安全性補丁（patches）可應用於韌體</li>
</ul>
<p>靈活性</p>
<ul>
<li>可與 coreboot、u-boot、OpenPOWER 抽象層 (OpenPOWER Abstraction Layer, OPAL)、SlimBootLoader、ARM 可信任韌體 (Arm Trusted Firmware, ATF) 搭配</li>
<li>可啟動多個作業系統（Linux、Berkeley UNIX（BSD）、XEN、Windows）</li>
<li>支援以下伺服器主機板：
<ul>
<li>QEMU 模擬的 Q35 系統</li>
<li><a href="https://trmm.net/S2600wf">Intel S2600WF</a></li>
<li><a href="https://trmm.net/NERF">Dell R630</a></li>
<li>Winterfell Open Compute node</li>
<li>Leopard Open Compute node</li>
<li>Tioga Pass Open Compute node</li>
<li>Monolake Open Compute node（未經測試）</li>
</ul>
</li>
</ul>
<p>啟動速度</p>
<ul>
<li>透過移除不必要的程式碼來提升啟動時間；通常能使啟動速度提高 20 倍</li>
</ul>
<p>客製化</p>
<ul>
<li>允許自訂 initramfs 運行時，支援特定環境的需求（包括裝置驅動程式和自訂執行檔）</li>
</ul>
<p>工程生產力</p>
<ul>
<li>編寫一次驅動程序，無需編寫兩次
<ul>
<li>Linux 是 <strong>開放、可衡量、可重現且易於更新的</strong></li>
<li>Linux 已經為幾乎所有東西提供了驅動程式</li>
</ul>
</li>
<li>核心（kernel）工程師=韌體工程師
<ul>
<li>了解 Linux 的工程師比了解 UEFI 的工程師多得多</li>
</ul>
</li>
<li>減少建置時間
<ul>
<li>initramfs 需要 <strong>30 秒</strong></li>
<li>核心需要 <strong>15 秒</strong>（增量式）</li>
<li>大約 <strong>15 秒</strong> 重新包裝 bios 映像檔（使用 fiano/utk）</li>
<li><strong>總計：約 1 分鐘</strong> 用於新的完整 BIOS 映像，可供測試</li>
</ul>
</li>
<li>測試和除錯
<ul>
<li><code>diskboot</code> 和 <code>pxeboot</code> 已經有單元測試 （unit tests）</li>
<li>使用 Linux 資源（如網路）使編寫測試更容易</li>
<li>u-root 等開源專案遵循優秀的軟體實踐，例如對每個提交的變更執行自動化測試</li>
<li>更容易除錯的 Go 用戶空間（user-space）應用程式</li>
<li>使用 QEMU 中的核心進行測試</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用情境"><a class="header" href="#使用情境">使用情境</a></h1>
<p>The general concept of using a Linux kernel to boot into an operating system sounds simple at first glance. The challenges in the details, in part not only limited to using Linux, are being discussed in this chapter, with ideas on solving specific problems in the domain of bootloaders.</p>
<h2 id="constrained-environments"><a class="header" href="#constrained-environments">Constrained environments</a></h2>
<p>Booting a system means dealing with constraints. Those can have either of two effects: spark creativity or keep you from pursuing a goal. On foot, you can only reach as far in a day, whereas a vehicle gets you much further. With LinuxBoot, we want to take the chance to reevaluate contemporary designs and go beyond.</p>
<p>When it comes to hardware, the vendor would choose the parts for their product and consider them in their price calculation.</p>
<p>One main constraint is the initial boot source. A System-on-Chip (SoC) typically starts off with a mask ROM and continues with a simple storage part, which may range from a SPI flash of a few megabytes up to eMMC or SD cards of hundreds of megabytes or even gigabytes.</p>
<p>We neglect other storages here that are attached via NVMe, SATA or other high-speed buses, because those are commonly not supported by mask ROMs. They are, on the other hand, what a bootloader offers to boot from, as well as network sources.</p>
<h2 id="embedded-devices"><a class="header" href="#embedded-devices">Embedded devices</a></h2>
<p>Many devices, nowadays known as IoT (Internet of Things), appliances, or similar, have a narrow use case. They are meant to perform a specific set of tasks, and thus can be tailored for it. In hardware terms, that often means an SoC, a bit of storage, and peripherals. Debug interfaces are reduced or removed for the final product.</p>
<h2 id="desktop-laptop-workstation-and-server-systems"><a class="header" href="#desktop-laptop-workstation-and-server-systems">Desktop, laptop, workstation and server systems</a></h2>
<p>At this point, many systems are still based on x86 processors, coming with a SPI flash on the board. While laptops and desktops mostly have a mere 16 or 32 megabytes to offer, high-end servers and workstations already have 64, and even a second whole system called the Board Management Controller (BMC), which has its own firmware and corresponding storage. Designs around those constraints vary among OEMs.</p>
<p>Note that it need not be that way. Arm based, RISC-V based and other systems already show that you can expect more, such as booting off eMMC. Laptops and desktop boards in that range are available as of now, even some servers and workstations.</p>
<h2 id="single-board-computers-sbcs"><a class="header" href="#single-board-computers-sbcs">Single Board Computers (SBCs)</a></h2>
<p>The SBC market has grown to such a degree that credit card size boards nowadays comes with both small storage parts that can act as boot sources as well as PCIe connectors that can hold NVMes of gigabytes and terabytes of storage. This gives us the opportunity to work out a boot flow that provides the end user with a very rich environment already early on before the main operating system is loaded.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="coverage"><a class="header" href="#coverage">Coverage</a></h1>
<h2 id="talks"><a class="header" href="#talks">Talks</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Date</th><th>Presenter</th><th>Title</th></tr></thead><tbody>
<tr><td>12/27/2016</td><td>Trammell Hudson</td><td><a href="https://trmm.net/Heads_33c3">Bootstraping a slightly more secure laptop</a></td></tr>
<tr><td>10/27/2017</td><td>Ron Minnich</td><td>Replace your exploit-ridden firmware with a Linux kernel (<a href="https://www.youtube.com/watch?v=iffTJ1vPCSo">YouTube</a>, <a href="https://schd.ws/hosted_files/osseu17/84/Replace%20UEFI%20with%20Linux.pdf">slides</a>)</td></tr>
<tr><td>12/29/2017</td><td>Trammell Hudson</td><td><a href="https://trmm.net/LinuxBoot_34c3">Bringing Linux back to the server BIOS with LinuxBoot</a></td></tr>
<tr><td>09/13/2018</td><td>Andrea Barberio, David Hendricks</td><td><a href="https://www.osfc.io/2018/talks/open-source-firmware-facebook/">Open Source Firmware @ Facebook</a></td></tr>
<tr><td>10/02/2018</td><td>Andrea Barberio, David Hendricks</td><td><a href="https://2018ocpregionalsummit.sched.com/event/F8ax/turning-linux-engineers-into-firmware-engineers">Turning Linux Engineers into Firmware Engineers</a> (<a href="https://insomniac.slackware.it/static/2018_ocp_regional_summit_linuxboot_at_facebook.pdf">slides</a>, <a href="https://www.youtube.com/watch?v=i84df1z6mdI">YouTube</a>)</td></tr>
<tr><td>06/15/2024</td><td>Marta Lewandowska</td><td><a href="https://pretalx.com/devconf-cz-2024/talk/W3AVCT/">No more boot loader: Please use the kernel instead</a></td></tr>
</tbody></table>
</div>
<ul>
<li><a href="https://www.usenix.org/conference/lisa18/presentation/barberio">Make Your System Firmware Faster, More Flexible and Reliable with LinuxBoot</a> by <a href="https://github.com/dhendrix">David Hendricks</a> and <a href="https://github.com/insomniacslk">Andrea Barberio</a> at <a href="https://www.usenix.org/conference/lisa18">LISA 2018</a> (<a href="https://insomniac.slackware.it/static/2018_lisa_linuxboot_at_facebook.pdf">slides</a>) (2018-10-31)</li>
<li><a href="https://www.youtube.com/watch?v=xfqKm190dbU">Open Source Firmware - A love story</a> by <a href="https://cybersecurity.9elements.com">Philipp Deppenwiese</a> at <a href="https://events.ccc.de/congress/2018">35c3</a> (<a href="https://cdn.media.ccc.de/congress/2018/slides-h264-hd/35c3-9778-deu-eng-Open_Source_Firmware_hd-slides.mp4">slides</a>) (2018-12-27)</li>
<li><a href="https://fosdem.org/2019/schedule/event/open_source_firmware_at_facebook/">Open Source Firmware at Facebook</a> by <a href="https://github.com/dhendrix">David Hendricks</a> and <a href="https://github.com/insomniacslk">Andrea Barberio</a> at <a href="https://fosdem.org/2019/">FOSDEM 2019</a> (<a href="https://video.fosdem.org/2019/K.4.401/open_source_firmware_at_facebook.mp4">video</a>) (<a href="https://insomniac.slackware.it/static/2019_fosdem_linuxboot_at_facebook.pdf">slides</a>) (2019-02-03)</li>
<li><a href="https://www.osfc.io/2022/talks/kexec-evolutions-for-linuxboot/">Kexec Evolutions for LinuxBoot</a> by David Hu at OSFC 2021</li>
<li><a href="https://pretalx.com/devconf-cz-2024/talk/W3AVCT/">No more boot loader: Please use the kernel instead</a> at 2024 DevConf</li>
</ul>
<h2 id="news"><a class="header" href="#news">News</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Date</th><th>Website</th><th>Title</th></tr></thead><tbody>
<tr><td>01/25/2018</td><td>Linux Foundation</td><td><a href="https://www.linuxfoundation.org/blog/system-startup-gets-a-boost-with-new-linuxboot-project/">System Statup gets a Boost with new LinuxBoot project</a></td></tr>
<tr><td>02/15/2018</td><td>Linux Journal</td><td><a href="https://www.linuxjournal.com/content/foss-project-spotlight-linuxboot/">Linux Journal: FOSS Project Spotlight: LinuxBoot</a></td></tr>
<tr><td>03/08/2018</td><td>LWN</td><td><a href="https://lwn.net/Articles/748586/">LWN.net: LinuxBoot: Linux as firmware</a></td></tr>
<tr><td>06/21/2018</td><td>Phoronix</td><td><a href="https://www.phoronix.com/news/Equus-WHITEBOX-OPEN">Equus WHITEBOX OPEN: A Line Of Coreboot/LinuxBoot-Ready Xeon Scalable Servers</a></td></tr>
<tr><td>02/06/2019</td><td>Phoronix</td><td><a href="https://www.phoronix.com/news/LinuxBoot-2019">At Just Over One Year Old, LinuxBoot Continues Making Inroads At Facebook &amp; Elsewhere</a></td></tr>
<tr><td>03/14/2019</td><td>Facebook</td><td><a href="https://code.fb.com/data-center-engineering/f16-minipack/">Facebook's LinuxBoot-powered F-16 high-performance fabric network</a></td></tr>
<tr><td>03/10/2023</td><td>Phoronix</td><td><a href="https://www.phoronix.com/news/Lenovo-LinuxBoot-ByteDance">Lenovo Begins Supporting LinuxBoot Firmware With ByteDance</a></td></tr>
<tr><td>07/08/2024</td><td>LWN</td><td><a href="https://lwn.net/Articles/979789">Giving bootloaders the boot with nmbl</a></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h2 id="linuxboot-的組成"><a class="header" href="#linuxboot-的組成">LinuxBoot 的組成</a></h2>
<p><img src="./images/LinuxBoot-components.svg" alt="image" /></p>
<p>LinuxBoot consists of the following components:</p>
<ol>
<li>BIOS</li>
<li>Linux kernel</li>
<li>u-root -&gt; initramfs</li>
</ol>
<h4 id="bios"><a class="header" href="#bios">BIOS</a></h4>
<p>This does not have to be a specific BIOS; currently LinuxBoot supports UEFI and <a href="https://coreboot.org/">coreboot</a>.</p>
<h4 id="linux-kernel"><a class="header" href="#linux-kernel">Linux kernel</a></h4>
<p>LinuxBoot is not intended to be a runtime production kernel; rather, it is meant to replace specific UEFI functionality using Linux kernel capabilities and then boot the actual production kernel on the machine. Kernel configuration files specific to LinuxBoot provide the needed Linux kernel capabilities without bloating the size of the BIOS with unnecessary drivers.</p>
<p>These config files disable options that are not needed in the LinuxBoot kernel and add some patches that are needed.</p>
<h4 id="initial-ram-filesystem--initramfs"><a class="header" href="#initial-ram-filesystem--initramfs">Initial RAM filesystem  (initramfs)</a></h4>
<p>When Linux boots it needs a root file system that provides boot and startup utilities. LinuxBoot uses <a href="./glossary.html">u-root</a> to create an initramfs for this purpose.</p>
<h4 id="what-is-an-initramfs"><a class="header" href="#what-is-an-initramfs">What is an initramfs?</a></h4>
<p>The initramfs is a root file system that is embedded within the firmware image itself. It is intended to be placed in a flash device along with the Linux kernel as part of the firmware image for LinuxBoot. The initramfs is essentially a set of directories bundled into a single cpio archive.</p>
<p>At boot time, the boot loader or firmware (for example, coreboot) loads the bzImage and initramfs into memory and starts the kernel. The kernel checks for the presence of the initramfs and, if found, unpacks it, mounts it as <code>/</code> and runs <code>/init</code>.</p>
<p>There are many types of initramfs, in this topic we focus on u-root. u-root is a Go user-space (a set of programs and libraries written in Go that are used to interact with the kernel). It contains a toolset of standard Linux applications and commands.</p>
<p>u-root can create an initramfs in two different modes:</p>
<ul>
<li>source mode, which contains:
<ul>
<li>Go toolchain binaries</li>
<li>A simple shell</li>
<li>Go source for tools to be compiled on the fly by the shell</li>
</ul>
</li>
<li>Busybox (bb) mode: This is one busybox-like binary comprising all the requested utilities.</li>
</ul>
<p>The initramfs provided by u-root implements the toolchain needed to securely boot the machine from the network, perform identity verification, communicate with different internal boot-related components, and kexec the next kernel.</p>
<p>u-root is an open source project hosted on GitHub. Within the u-root repository, we have executable commands in <code>cmds</code> and the packages containing libraries and implementations in <code>pkg</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="工具評估"><a class="header" href="#工具評估">工具評估</a></h1>
<p>Three general questions guide all software projects:</p>
<ul>
<li>what exists already? (implementations, tools and build systems)</li>
<li>what needs development? (UIs and such)</li>
<li>what is a good environment? (build + runtime)</li>
</ul>
<p>Not only do we want to answer those questions. We also keep track of the options and decision process in this book in order for readers to make sense.</p>
<p>There are many existing tools already that we can leverage to implement the idea of using Linux to boot into an operating system.</p>
<h2 id="root-filesystem"><a class="header" href="#root-filesystem">Root filesystem</a></h2>
<p>Linux needs a root filesystem with at least one binary that is called <a href="https://docs.kernel.org/admin-guide/init.html"><code>init</code></a>. Since booting a system is a cumbersome task, additional tools aid in both development and investigating possible issues.</p>
<h3 id="core-utilities"><a class="header" href="#core-utilities">Core utilities</a></h3>
<p>Unix already came with lots of little utilities for the user of the system, which may be anyone from a system developer to an administrator of a shared or provided system, or an end user. Further tools have been created over the years, and the <a href="https://en.wikipedia.org/wiki/GNU_Core_Utilities">GNU core utilities</a> are essentially a collection of tools resulting from merging other collections. Note that there are still many other utilities that are not part of coreutils. At the same time, there are multiple other implementations now, which differ in terms of arguments and flags and possibly additional utilities they include.</p>
<div class="table-wrapper"><table><thead><tr><th>tool</th><th>language</th><th>license</th><th>usage</th></tr></thead><tbody>
<tr><td><a href="https://busybox.net/">BusyBox</a></td><td>C</td><td>GPLv2</td><td>Heads</td></tr>
<tr><td><a href="http://landley.net/toybox">toybox</a></td><td>C</td><td>0BSD</td><td>Android</td></tr>
<tr><td><a href="https://www.gnu.org/software/coreutils/">GNU coreutils</a></td><td>C</td><td>GPLv3</td><td>not for LinuxBoot</td></tr>
<tr><td><a href="https://u-root.org">u-root</a></td><td>Go</td><td>BSD 3-Clause</td><td>ByteDance, Google et al</td></tr>
<tr><td><a href="http://uutils.github.io/">uutils/coreutils</a></td><td>Rust</td><td>MIT</td><td>not for LinuxBoot</td></tr>
</tbody></table>
</div>
<h3 id="kexec-implementations"><a class="header" href="#kexec-implementations">kexec implementations</a></h3>
<p>While <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/uapi/linux/kexec.h">kexec itself is a Linux syscall</a>, it is not a one-shot operation. Loading multiple segments into memory, synchronizing and unmounting file systems, and the eventual syscall to <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/uapi/linux/reboot.h">reboot</a> belong to the procedure. In addition, there are architecture specifics to take into account. Thus, there are multiple implementations of kexec, which are Linux programs that offer their own interfaces again to pass extra arguments. Besides those standalone implementations, there are also specialized boot loaders based on kexec that have their own extra logic, such as FreeBSD's kload or petitboot.</p>
<div class="table-wrapper"><table><thead><tr><th>tool</th><th>language</th><th>license</th><th>usage</th></tr></thead><tbody>
<tr><td><a href="https://git.kernel.org/pub/scm/utils/kernel/kexec/kexec-tools.git">kexec-tools</a> (<a href="https://github.com/horms/kexec-tools">GitHub mirror</a>)</td><td>C</td><td>GPLv2</td><td>Heads, Petitboot</td></tr>
<tr><td><a href="https://systemd.io/">systemd</a> (wrapper)</td><td>C</td><td>LGPL-2.1+</td><td>systemd on UEFI</td></tr>
<tr><td><a href="https://github.com/kexecboot/kexecboot">kexecboot</a></td><td>C</td><td>GPLv2</td><td>?</td></tr>
<tr><td>u-root (CLI+mod)</td><td>Go</td><td>BSD 3-Clause</td><td>Google et al</td></tr>
<tr><td><a href="https://github.com/im-0/kexlinux">kexlinux</a></td><td>Rust</td><td>LGPL-3.0+</td><td>?</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="petitboot"><a class="header" href="#petitboot">Petitboot</a></h1>
<p>petitboot is a Linux user-space application written in C that calls <code>kexec</code>. The <code>kexec</code> installed in the initramfs is not the mainline kexec-tools implementation, but a smaller implementation named <a href="https://github.com/antonblanchard/kexec-lite">kexec-lite</a>. It is claimed to be roughly 32 KB compared to kexec-tools, which is roughly 200 KB.<sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup></p>
<hr>
<ol class="footnote-definition"><li id="footnote-1">
<p><a href="https://github.com/antonblanchard/kexec-lite/issues/4#issuecomment-314936778">https://github.com/antonblanchard/kexec-lite/issues/4#issuecomment-314936778</a> <a href="#fr-1-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="openpower-boot-chain"><a class="header" href="#openpower-boot-chain">OpenPOWER boot chain</a></h1>
<pre class="mermaid">flowchart LR
    skiroot([&quot;skiroot (petitboot)&quot;])
    SBEs--&gt;hostboot--&gt;skiboot--&gt;skiroot--&gt;OS
</pre>
<ul>
<li><a href="https://github.com/open-power/sbe">Self-boot engines</a> (SBE) are split between an on-chip ROM and an external EEPROM</li>
<li><a href="https://github.com/open-power/hostboot">hostboot</a> is a C++ boot loader that does DRAM initialization provides runtime services to skiboot or a hypervisor</li>
<li><a href="https://github.com/open-power/skiboot">skiboot</a> is a C boot loader and runtime firmware for OpenPOWER that loads skiroot.</li>
</ul>
<p>skiroot is a term used to describe the LinuxBoot implementation for OpenPOWER. A skiroot repository or package does not exist. The term is only used in the kernel configuration, <code>skiroot_defconfig</code>.<sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup></p>
<h2 id="see-also"><a class="header" href="#see-also">See also</a></h2>
<ul>
<li><a href="https://openpower.foundation/blog/coreboot-on-talos2/">coreboot and Heads as an alternative firmware for OpenPOWER Talos II</a></li>
</ul>
<hr>
<ol class="footnote-definition"><li id="footnote-1">
<p><a href="https://github.com/open-power/op-build/blob/master/openpower/configs/linux/skiroot_defconfig">https://github.com/open-power/op-build/blob/master/openpower/configs/linux/skiroot_defconfig</a> <a href="#fr-1-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="odroid-boot-chain"><a class="header" href="#odroid-boot-chain">ODROID boot chain</a></h1>
<p>The <a href="https://wiki.odroid.com/odroid-n2/hardware">ODROID-N2</a> comes with a SPI flash as well as a connector for an eMMC flash and an SD card slot. The SoC is an <a href="https://wiki.odroid.com/odroid-n2/software/boot_sequence">Amlogic S922X which can boot from all those storages</a>, depending on GPIO configuration and a fallback flow in the mask ROM. For booting from SPI flash, the ODROID-N2 board has a switch, and comes with <a href="./petitboot.html">Petitboot</a> preinstalled<sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup>.</p>
<p>The SPI flash boot flow is as follows:</p>
<pre class="mermaid">flowchart LR
    maskrom[&quot;mask ROM&quot;]
    spl[&quot;U-Boot SPL&quot;]
    uboot[&quot;U-Boot main&quot;]
    petitboot([&quot;petitboot&quot;])
    maskrom--&gt;spl--&gt;uboot--&gt;petitboot--&gt;OS
</pre>
<ul>
<li><a href="https://docs.u-boot.org/en/latest/usage/spl_boot.html">U-Boot SPL</a> initializes DRAM and loads U-Boot main ("proper")</li>
<li>U-Boot main is set up to directly load Linux with Petitboot, which implements LinuxBoot</li>
</ul>
<h2 id="see-also-1"><a class="header" href="#see-also-1">See also</a></h2>
<ul>
<li><a href="https://forum.odroid.com/viewtopic.php?f=182&amp;t=33873">ODROID forum discussion on porting Petitboot to ODROID-N2</a></li>
</ul>
<hr>
<ol class="footnote-definition"><li id="footnote-1">
<p><a href="https://wiki.odroid.com/getting_started/petitboot/os_installation_using_otg">https://wiki.odroid.com/getting_started/petitboot/os_installation_using_otg</a> <a href="#fr-1-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="關於-u-root"><a class="header" href="#關於-u-root">關於 u-root</a></h1>
<p>U-root is an embeddable root file system intended to be placed in a flash device as part of the firmware image, along with a Linux kernel. The program source code is installed in the root file system contained in the firmware flash part and compiled on demand. All the u-root utilities, roughly corresponding to standard Unix utilities, are written in Go, a modern, type-safe language with garbage collection and language-level support for concurrency and inter-process communication.</p>
<p>Unlike most embedded root file systems, which consist largely of binaries, u-root has only 5: an init program and 4 Go compiler binaries. When a program is first run, it, and any not-yet-built packages it uses are compiled to a RAM-based file system. The first invocation of a program takes a fraction of a second, as it is compiled. Packages are only compiled once, so the slowest build is always the first one, on boot, which takes about 3 seconds. Subsequent invocations are very fast, usually a millisecond or so.</p>
<p>U-root blurs the line between script-based distros such as Perl Linux[^24] and binary-based distros such as BusyBox[^26]. It has the flexibility of Perl Linux and the performance of BusyBox. Scripts and builtins are written in Go, not a shell scripting language. U-root is a new way to package and distribute file systems for embedded systems, and the use of Go promises a dramatic improvement in their security.</p>
<h2 id="u-root-and-embedded-systems"><a class="header" href="#u-root-and-embedded-systems">U-root and embedded systems</a></h2>
<p>Embedding kernels and root file systems in BIOS flash is a common technique for gaining boot time performance and platform customization[^25] [^14] [^23]. Almost all new firmware includes a multiprocess operating system with a full complement of file systems, network drivers, and protocol stacks, all contained in an embedded file system. In some cases, the kernel is only booted long enough to boot another kernel. In others, the kernel that is booted and the file system it contains constitute the operational environment of the device[^15]. These so-called “embedded root file systems” also contain a set of standard Unix-style programs used for both normal operation and maintenance. Space on the device is at a premium, so these programs are usually written in C using the BusyBox toolkit[^26], or in an interpretive language such as Perl[^24] or Forth. BusyBox in particular has found wide usage in embedded appliance environments, as the entire root file system can be contained in under one MiB.</p>
<p>Embedded systems, which were once standalone, are now almost always network connected. Network connected systems face a far more challenging security environment than even a few years ago. In response to the many successful attacks against shell interpreters[^11] and C programs[^8], we have started to look at using a more secure, modern language in embedded root file systems, namely, Go[^21] [^16].</p>
<p>Go is a new systems programming language created by Google. Go has strong typing; language level support for concurrency; inter-process communication via channels, a la Occam[^13], Limbo[^17], and Alef[^27]; runtime type safety and other protective measures; dynamic allocation and garbage collection; closures; and a package syntax, similar to Java, that makes it easy to determine what packages a given program needs. The modern language constructs make Go a much safer language than C. This safety is critical for network-attached embedded systems, which usually have network utilities written in C, including web servers, network servers including sshd, and programs that provide access to a command interpreter, itself written in C. All are proving to be vulnerable to the attack-rich environment that the Internet has become. Buffer overflow attacks affecting C-based firmware code (among other things) in 2015 include GHOST and the so-called FSVariable.c bug in Intel’s UEFI firmware. Buffer overflows in Intel’s UEFI and Active Management Technology (AMT) have also been discovered in several versions in recent years.</p>
<p>Both UEFI[^12] and AMT[^4] are embedded operating systems, loaded from flash that run network-facing software. Attacks against UEFI have been extensively studied[^9]. Most printers are network-attached and are a very popular exploitation target[^6]. Firmware is not visible to most users and is updated much less frequently (if at all) than programs. It is the first software to run, at power on reset. Exploits in firmware are extremely difficult to detect, because firmware is designed to be as invisible as possible. Firmware is extremely complex; UEFI is roughly equivalent in size and capability to a Unix kernel. Firmware is usually closed and proprietary, with nowhere near the level of testing of kernels. These properties make firmware an ideal place for so-called advanced persistent threats[^10] [^18] [^5]. Once an exploit is installed, it is almost impossible to remove, since the exploit can inhibit its removal by corrupting the firmware update process. The only sure way to mitigate a firmware exploit is to destroy the hardware.</p>
<p>U-root is an excellent option for embedded systems. U-root contains only 5 binaries, 4 of them from the Go toolchain, and the 5th is an init binary. The rest of the programs are contained in BIOS flash in source form, including packages. The search path is arranged so that when a command is invoked, if it is not in <code>/bin</code>, an installer is invoked instead which compiles the program into <code>/bin</code>. If the build succeeds, the command is executed. This first invocation takes a fraction of a second, depending on program complexity. After that, the RAM-based, statically linked binaries run in about a millisecond. Scripts are written in Go, not a shell scripting language, with two benefits: the shell can be simple, with fewer corner cases, and the scripting environment is substantially improved since Go is more powerful than most shell scripting languages, but also less fragile and less prone to parsing bugs.</p>
<h2 id="u-root-design"><a class="header" href="#u-root-design">U-root design</a></h2>
<p>The u-root boot image is a build toolchain and a set of programs in source form. When first used, a program and any needed but not-yet-built packages are built and installed, typically in a fraction of a second. With later uses, the binary is executed. The root file system is almost entirely unformed on boot; <code>/init</code> sets up the key directories and mounts, including common ones such as <code>/etc</code> and <code>/proc</code>.</p>
<p>Since the init program itself is only 132 lines of code and is easy to change, the structure is very flexible and allows for many use cases, for example:</p>
<ul>
<li>Additional binaries: if the 3 seconds it takes to get to a shell is too long (some applications such as automotive computing require 800 ms startup time), and there is room in flash, some programs can be precompiled into /bin.</li>
<li>Build it all on boot: if on-demand compilation is not desired, a background thread in the init process can build all the programs on boot.</li>
<li>Selectively remove binaries after use: if RAM space is at a premium, once booted, a script can remove everything in <code>/bin</code>. Utilities or commands that are used will be rebuilt on demand.</li>
<li>Always build on demand: run in a mode in which programs are never written to <code>/bin</code> and always rebuilt on demand. This is a very practical option given that program compilation is so fast.</li>
<li>Lockdown: if desired, the system can be locked down once booted in one of several ways: the entire <code>/src</code> tree can be removed, for example, or just the compiler toolchain can be deleted.</li>
</ul>
<h2 id="u-root-functionality"><a class="header" href="#u-root-functionality">U-root functionality</a></h2>
<p>U-root is packaged as an LZMA-compressed initial RAM file system (initramfs) in cpio format. It is contained in a Linux compressed kernel image, also know as bzImage. The bootloader (for example, syslinux) or firmware (for example, coreboot) loads the bzImage into memory and starts it. The Linux kernel sets up a RAM-based root file system and unpacks the u-root file system into it. This initial root file system contains the Go toolchain (4 binaries), an init binary, the u-root program source, and the entire Go source tree, which provides packages needed for u-root programs.</p>
<p>All Unix systems start an init process on boot and u-root is no exception. The init for u-root sets up some basic directories, symlinks, and files. It builds a command installer and invokes the shell. This process is described in more detail below. The boot file system layout is shown in Table 1.</p>
<p>The src directory is where programs and u-root packages reside. The go/bin directory is for any Go tools built after boot; the go/pkg/tool directory contains binaries for various architecture/kernel combinations. The directory in which a compiler toolchain is placed provides information about the target OS and architecture, for example, the Go build places binaries for Linux on x86 64 in <code>/go/pkg/tool/linux</code> <code>amd64/</code>. Note that there is no <code>/bin</code> or many of the other directories expected in a root file system. The init binary builds them. It creates an empty <code>/bin</code> which is filled with binaries on demand as shown in Table 2.The u-root root file system has very little state.</p>
<p>For most programs to work, the file system must be more complete. Image space is saved by having init create additional file system structure at boot time: it fills in the missing parts of the root filesystem. It creates <code>/dev</code> and <code>/proc</code> and mounts them. It creates an empty <code>/bin</code> which is filled with binaries on demand.</p>
<p>In addition to <code>/bin</code>, there is a directory called <code>/buildbin</code>. <code>Buildbin</code> and the correct setup of $PATH are the keys to making on-demand compilation work. The init process sets $PATH to <code>/go/bin:/bin:/buildbin:/usr/local/bin</code>. Init also builds <code>installcommand</code> using the Go bootstrap builder and creates a complete set of symlinks. As a final step, init execs <code>sh</code>.</p>
<p>There is no <code>/bin/sh</code> at this point; the first <code>sh</code> found in $PATH is <code>/buildbin/sh</code>. This is a symlink to <code>installcommand</code>. <code>Installcommand</code>, once started, examines <code>argv[0]</code>, which is <code>sh</code>, and takes this as instruction to build <code>/src/cmds/sh/.go</code> into <code>/bin</code> and then exec <code>/bin/sh</code>. There is no difference between starting the first shell and any other program. Hence, part of the boot process involves the construction of an installation tool to build a binary for a shell which is then run.</p>
<p>If a user wants to examine the source to the shell, they can <code>cat</code> <code>/src/cmds/sh/.go</code>. The <code>cat</code> command will be built and then show those files. U-root is intended for network-based devices and hence good network initialization code is essential. U-root includes a Go version of the IP and DHCP programs, along with the docker netlink package and a DHCP package.</p>
<p>Table 1 below shows the initial layout of a u-root file system.</p>
<p>All Go compiler and runtime source is included under <code>/go/src</code>. All u-root source is under <code>/src</code> and the compiler toolchain binaries are under <code>/go/pkg</code>.</p>
<div class="table-wrapper"><table><thead><tr><th>Directory</th><th style="text-align: center">Subdirectory</th><th style="text-align: left">Command</th></tr></thead><tbody>
<tr><td>/src</td><td style="text-align: center">cmds/</td><td style="text-align: left"></td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">builtin/builtin.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">/cat.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">/cmp.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">comm/comm.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">cp/cp.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">date/date.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">dmesg/dmesg.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">echo/echo.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">freq/freq.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">grep/grep.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">init/init.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">installcommand/installcommand.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">ip/ip.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">ldd/ldd.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">losetup/losetup.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">ls/ls.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">mkdir/mkdir.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">mount/mount.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">netcat/netcat.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">ping/ping.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">printenv/printenv.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">rm/rm.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">script/script.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">seq/seq.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">sh/{cd.go,parse.go,sh.go,time.go}</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">srvfiles/srvfiles.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">tcz/tcz.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">tee/tee.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">uniq/uniq.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">wc/wc.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">wget/wget.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">which/which.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">pkg/</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">dhcp/ (dhcp package source)</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">netlib/ (netlib package source)</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">golang.org (import package source)</td></tr>
<tr><td>/go</td><td style="text-align: center">src/</td><td style="text-align: left">Packages and toolchain</td></tr>
<tr><td></td><td style="text-align: center">pkg/</td><td style="text-align: left">tool/linux amd64/{6a,6c,6g,6l}</td></tr>
<tr><td></td><td style="text-align: center">misc/</td><td style="text-align: left">...</td></tr>
<tr><td></td><td style="text-align: center">tool/</td><td style="text-align: left">...</td></tr>
<tr><td></td><td style="text-align: center">bin/</td><td style="text-align: left">go</td></tr>
<tr><td></td><td style="text-align: center">include/</td><td style="text-align: left">...</td></tr>
<tr><td>/lib/</td><td style="text-align: center">libc.so</td><td style="text-align: left">Needed for tinycore linux packages</td></tr>
<tr><td></td><td style="text-align: center">libm.so</td><td style="text-align: left"></td></tr>
</tbody></table>
</div>
<p><strong>Table 1</strong>: Initial layout of a u-root filesystem</p>
<p>Table 2 below shows the layout after <code>/init</code> has run.</p>
<div class="table-wrapper"><table><thead><tr><th>Directory</th><th style="text-align: center">Subdirectory</th><th style="text-align: left">Command</th></tr></thead><tbody>
<tr><td>/src</td><td style="text-align: center">cmds/</td><td style="text-align: left"></td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">builtin/builtin.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">/cat.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">/cmp.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">comm/comm.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">cp/cp.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">date/date.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">dmesg/dmesg.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">echo/echo.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">freq/freq.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">grep/grep.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">init/init.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">installcommand/installcommand.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">ip/ip.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">ldd/ldd.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">losetup/losetup.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">ls/ls.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">mkdir/mkdir.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">mount/mount.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">netcat/netcat.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">ping/ping.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">printenv/printenv.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">rm/rm.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">script/script.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">seq/seq.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">sh/{cd.go,parse.go,sh.go,time.go}</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">srvfiles/srvfiles.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">tcz/tcz.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">tee/tee.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">uniq/uniq.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">wc/wc.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">wget/wget.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">which/which.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">pkg/</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">dhcp/ (dhcp package source)</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">netlib/ (netlib package source)</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">golang.org (import package source)</td></tr>
<tr><td>/go</td><td style="text-align: center">src/</td><td style="text-align: left">Packages and toolchain</td></tr>
<tr><td></td><td style="text-align: center">pkg/</td><td style="text-align: left">tool/linux amd64/{6a,6c,6g,6l}</td></tr>
<tr><td></td><td style="text-align: center">misc/</td><td style="text-align: left">...</td></tr>
<tr><td></td><td style="text-align: center">tool/</td><td style="text-align: left">...</td></tr>
<tr><td></td><td style="text-align: center">bin/</td><td style="text-align: left">go</td></tr>
<tr><td></td><td style="text-align: center">include/</td><td style="text-align: left">...</td></tr>
<tr><td>/lib/</td><td style="text-align: center">libc.so</td><td style="text-align: left">Needed for tinycore linux packages</td></tr>
<tr><td></td><td style="text-align: center">libm.so</td><td style="text-align: left"></td></tr>
</tbody></table>
</div>
<p><strong>Table 2</strong>: Layout after <code>/init</code> has run.</p>
<p><code>/buildbin</code> contains symlinks to enable the on-demand compilation, and other standard directories and mount points are ready.</p>
<h2 id="the-u-root-shell"><a class="header" href="#the-u-root-shell">The u-root shell</a></h2>
<p>U-root provides a shell that is stripped down to the fundamentals: it can read commands in using the Go scanner package; it can expand (that is, glob) the command elements, using the Go filepath package, and it can run the resulting commands, either programs or shell builtins. It supports pipelines and IO redirection. At the same time, the shell defines no language of its own for scripting and builtins. Instead, the u-root shell uses the Go compiler. In that sense, the u-root shell reflects a break in important ways with the last few decades of shell development, which has seen shells and their language grow ever more complex and, partially as a result, ever more insecure[^19] and fragile[^11].</p>
<p>The shell has several builtin commands, and you can extend it with builtin commands of your own. First, you need to understand the basic source structure of u-root shell builtins. Then, you will learn about user-defined builtins.</p>
<p>All shell builtins, including the ones that come with the shell by default, are written with a standard Go init pattern which installs one or more builtins.</p>
<p>Builtins in the shell are defined by a name and a function. One or more builtins can be described in a source file. The name is kept in a map and the map is searched for a command name before looking in the file system. The function must accept a string as a name and a (possibly zero-length) array of string arguments, and return an error. In order to connect the builtin to the map, a programmer must provide an <code>init</code> function which adds the name and function to the map. The <code>init</code> function is special in that it is run by Go when the program starts up. In this case, the <code>init</code> function just installs a builtin for the time command.</p>
<p>Figure 1 and Figure 2 below show the shell builtin for time.</p>
<pre><code class="language-go">// Package main is the 'root' of the package hierarchy for a program.
// This code is part of the main program, not another package,
// and is declared as package main.

package main

// A Go source file list all the packages on which it has a direct
// dependency.

import (
  "fmt"
  "os"
  "time"
  )

// init() is an optional function. If init () is present in a file,
// the Go compiler and runtime arrange for it to be called at
// program startup. It is therefore like a constructor.

func init () {
    // addBuiltIn is provided by the u−root shell for the addition of
    // builtin commands. Builtins must have a standard type:
    // - The first parameter is a string
    // - The second is a string array which may be 0 length
    // - The return is the Go error type
    // In this case, we are creating a builtincalled time that calls
    // the timecmd function.

  addBuiltIn ( "time " , timecmd )
  }
</code></pre>
<p><strong>Figure 1</strong>: The code for the time builtin, Part I: setup</p>
<pre><code class="language-go">// The timecmd function is passed the name of a command to run,
// optional arguments, and returns an error. It:
// - gets the starttime using Now from the time package
// - runs the command using the u−root shell runit function
// - computes a duration using Since from the time package
// - if there is an error, prints the error to os.Stderr
// - uses fmt. Printf to print the duration to os.Stderr
// Note that since runtime always handles the error, by printing
// it, it always returns nil. Most builtins return the error.
// Here you can see the usage of the imported packages
// from the imports statement above.

func timecmd (name string, args [] string )
error {
      start: = time. Now ()
      err := run it (name, args)
        if err != nil {

      fmt. Fprintf (os. Stderr, ”%v\n”, err)

  }
  cost := time . Since (start)
  fmt.Printf(os.Stderr, ”%v ”,cost)

    // This function is special in that it handles the error, and hence
    // does not return an error.
    // Most other builtins return the error.

  return nil
  }

</code></pre>
<p><strong>Figure 2</strong>: The code for the shell time builtin, Part II</p>
<h2 id="scripting-and-builtins"><a class="header" href="#scripting-and-builtins">Scripting and builtins</a></h2>
<p>To support scripting and builtins, u-root provides two programs: script and builtin. The script program allows users to specify a Go fragment on the command line, and runs that fragment as a program. The builtin program allows a Go fragment to be built into the shell as a new command. Builtins are persistent; the builtin command instantiates a new shell with the new command built in. Scripts run via the script command are not persistent.</p>
<p>A basic hello builtin can be defined on the command line:</p>
<pre><code>builtin hello '{ fmt.Printf("Hello\n") }'
</code></pre>
<p>The fragment is defined by the {} pair. Given a fragment that starts with a {, the builtin command generates all the wrapper boiler plate needed. The builtin command is slightly different from the script command in that the Go fragment is bundled into one argument. The command accepts multiple pairs of command name and Go code fragments, allowing multiple new builtin commands to be installed in the shell.</p>
<p>Builtin creates a new shell at <code>/bin/sh</code> with the source at <code>/src/cmds/sh/</code>. Invocations of <code>/bin/sh</code> by this shell and its children will use the new shell.</p>
<p>Processes spawned by this new shell can access the new shell source and can run the builtin command again and create a shell that further extends the new shell. Processes outside the new shell’s process hierarchy can not use this new shell or the builtin source. When the new shell exits, the builtins are no longer visible in any part of the file system. We use Linux mount name spaces to create this effect[^22]. Once the builtin command has verified that the Go fragment is valid, it builds a new, private namespace with the shell source, including the new builtin source. From that point on, the new shell and its children will only use the new shell. The parent process and other processes outside the private namespace continue to use the old shell.</p>
<p>Figure 3 below shows an example usage of the script command.</p>
<p>This script implements printenv. Note that it is not a complete Go program in that it lacks a package statement, imports, a main function declaration, and a return at the end. All the boilerplate is added by the script command, which uses the Go imports package to scan the code and create the import statements required for compilation (in this case, both fmt and os packages are imported). Because the u-root shell is so simple, there is no need to escape many of these special characters. The complex parsing tasks have been offloaded to Go. Builtins are implemented in almost the same way. The builtin command takes the Go fragment and creates a standard shell builtin Go source file which conforms to the builtin pattern. This structure is easy to generate programmatically, building on the techniques used for the script command.</p>
<pre><code>script{ fmt.Printf("%v\n", os.Environ()) }
</code></pre>
<p><strong>Figure 3</strong>: Go fragment for a printenv script. Code structure is inserted and packages are determined automatically.</p>
<h2 id="environment-variables"><a class="header" href="#environment-variables">Environment variables</a></h2>
<p>The u-root shell supports environment variables, but manages them differently than most Unix environments. The variables are maintained in a directory called <code>/env</code>; the file name corresponds to the environment variable name, and the files contents are the value. When it is starting a new process, the shell populates child process environment variables from the <code>/env</code> directory. The syntax is the same; $ followed by a name directs the shell to substitute the value of the variable in the argument by prepending <code>/env</code> to the path and reading the file.</p>
<p>The shell variables described above are relative paths; <code>/env</code> is prepended to them. In the u-root shell, the name can also be an absolute path. For example, the command script $<code>/home/$USER/scripts/hello</code> will substitute the value of the <code>hello</code> script into the command line and then run the script command. The ability to place arbitrary text from a file into an argument is proving to be extremely convenient, especially for script and builtin commands.</p>
<h2 id="using-external-packages-and-programs"><a class="header" href="#using-external-packages-and-programs">Using external packages and programs</a></h2>
<p>No root file system can provide all the packages all users want, and u-root is no exception. You need to have the ability to load external packages from popular Linux distros. The <code>tcz</code> command can be used to load external packages from the TinyCore Linux distribution, also known as <em>tinycore</em>. A tinycore package is a mountable file system image, containing all the package files, including a file listing any additional package dependencies. To load these packages, u-root provides the <code>tcz</code> command which fetches the package and needed dependencies. Hence, if a user wants emacs, they need merely type <code>tcz emacs</code>, and emacs will become available in <code>/usr/local/bin</code>. The tinycore packages directory can be a persistent directory or it can be empty on each boot.</p>
<p>The <code>tcz</code> command is quite flexible as to what packages it loads and where they are loaded from. Users can specify the host name which provides the packages, the TCP port on which to connect, the version of tinycore to use, and the architecture. The <code>tcz</code> command must loopback mount each package as it is fetched, and hence must cache them locally. It will not refetch already cached packages. This cache can be volatile or maintained on more permanent storage. Performance varies depending on the network being used and the number of packages being loaded, but averages about 1 second per package on a WIFI-attached laptop. U-root also provides a small web server, called <em>srvfiles</em>, that can be used to serve locally cached tinycore packages for testing. The entire server is 18 lines of Go.</p>
<h2 id="on-demand-compilation"><a class="header" href="#on-demand-compilation">On-Demand Compilation</a></h2>
<p>On-Demand compilation is one of the oldest ideas in computer science. Slimline Open Firmware (SLOF)[^7] is a FORTHbased implementation of Open Firmware developed by IBM for some of its Power and Cell processors. SLOF is capable of storing all of Open Firmware as source in the flash memory and compiling components to indirect threading on demand[^2].</p>
<p>In the last few decades, as our compiler infrastructure has gotten slower and more complex, true on-demand compilation has split into two different forms. First is the on-demand compilation of source into executable byte codes, as in Python. The byte codes are not native but are more efficient than source. If the python interpreter finds the byte code it will interpret that instead of source to provide improved performance. Java takes the process one step further with the Just In Time compilation of byte code to machine code[^20] to boost performance.</p>
<h2 id="embedding-kernel-and-root-file-systems-in-flash"><a class="header" href="#embedding-kernel-and-root-file-systems-in-flash">Embedding kernel and root file systems in flash</a></h2>
<p>The LinuxBIOS project[^14] <sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup>, together with clustermatic[^25], used an embedded kernel and simple root file system to manage supercomputing clusters. Due to space constraints of 1 MiB or less of flash, clusters embedded only a single-processor Linux kernel with a daemon. The daemon was a network bootloader that downloaded a more complex SMP kernel and root file system and started them. Clusters built this way were able to boot 1024 nodes in the time it took the standard PXE network boot firmware to find a working network interface.</p>
<p>Early versions of One Laptop Per Child used LinuxBIOS, with Linux in flash as a boot loader, to boot the eventual target. This system was very handy, as they were able to embed a full WIFI stack in flash with Linux, and could boot test OLPC images over WIFI. The continuing growth of the Linux kernel, coupled with the small flash size on OLPC, eventually led OLPC to move to Open Firmware.</p>
<p>AlphaPower shipped their Alpha nodes with a so-called Direct Boot Linux, or DBLX. This work was never published, but the code was partially released on sourceforge.net just as AlphaPower went out of business.  Compaq also worked with a Linux-As-Bootloader for the iPaq.</p>
<p>Car computers and other embedded ARM systems frequently contain a kernel and an ext2 formatted file system in NOR flash, that is, flash that can be treated as memory instead of a block device. Many of these kernels use the so-called eXecute In Place[^3] (XIP) patch, which allows the kernel to page binaries directly from the memory-addressable flash rather than copying it to RAM, providing a significant savings in system startup time. A downside of this approach is that the executables can not be compressed, which puts further pressure on the need to optimize binary size. NOR flash is very slow, and paging from it comes at a significant performance cost. Finally, an uncompressed binary image stored in NOR flash has a much higher monetary cost than the same image stored in RAM since the cost per bit is so much higher.</p>
<p>UEFI[^12] contains a non-Linux kernel (the UEFI firmware binary) and a full set of drivers, file systems, network protocol stacks, and command binaries in the firmware image. It is a full operating system environment realized as firmware.</p>
<p>The ONIE project[^23] is a more recent realization of the Kernel-in-flash idea, based on Linux. ONIE packs a Linux kernel and Busybox binaries into a very small package. Since the Linux build process allows an initial RAM file system (initramfs) to be built directly into the kernel binary, some companies are now embedding ONIE images into flash with coreboot. Sage Engineering has shown a bzImage with a small Busybox packed into a 4M image. ONIE has brought new life to an old idea: packaging a kernel and small set of binaries in flash to create a fast, capable boot system.</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<hr>
<ol class="footnote-definition"><li id="footnote-1">
<p>AGNEW, A., SULMICKI, A., MINNICH, R., AND ARBAUGH, W. A. Flexibility in rom: A stackable open source bios. In USENIX Annual Technical Conference, FREENIX Track (2003), pp. 115–124. [^2]: (AUTHOR OF SLOF), S. B. Personal conversation. [^3]: BENAVIDES, T., TREON, J., HULBERT, J., AND CHANG, W. The enabling of an execute-in-place architecture to reduce the embedded system memory footprint and boot time. Journal of computers 3, 1 (2008), 79–89. [^4]: BOGOWITZ, B., AND SWINFORD, T. Intel⃝R active management technology reduces it costs with improved pc manageability. Technology@ Intel Magazine (2004). [^5]: CELEDA, P., KREJCI, R., VYKOPAL, J., AND DRASAR, M. Embedded malware-an analysis of the chuck norris botnet. In Computer Network Defense (EC2ND), 2010 European Conference on (2010), IEEE, pp. 3–10. [^6]: CUI, A., COSTELLO, M., AND STOLFO, S. J. When firmware modifications attack: A case study of embedded exploitation. In NDSS (2013). [^7]: DALY, D., CHOI, J. H., MOREIRA, J. E., AND WATERLAND, A. Base operating system provisioning and bringup for a commercial supercomputer. In Parallel and Distributed Processing Symposium, 2007. IPDPS 2007. IEEE International (2007), IEEE, pp. 1–7. [^8]: DURUMERIC, Z., KASTEN, J., ADRIAN, D., HALDERMAN, J. A., BAILEY, M., LI, F., WEAVER, N., AMANN, J., BEEKMAN, J., PAYER, M., ET AL. The matter of heartbleed. In Proceedings of the 2014 Conference on Internet Measurement Conference (2014), ACM, pp. 475–488. [^9]: KALLENBERG, C., AND BULYGIN, Y. All your boot are belong to us intel, mitre. cansecwest 2014. [^10]: KALLENBERG, C., KOVAH, X., BUTTERWORTH, J., AND CORNWELL, S. Extreme privilege escalation on windows 8/uefi systems. [^11]: KOZIOL, J., LITCHFIELD, D., AITEL, D., ANLEY, C., EREN, S., MEHTA, N., AND HASSELL, R. The Shellcoder’s Handbook. Wiley Indianapolis, 2004. [^12]: LEWIS, T. Uefi overview, 2007. [^13]: MAY,D.Occam.ACMSigplanNotices18,4(1983),69–79. [^14]: MINNICH, R. G. Linuxbios at four. Linux J. 2004, 118 (Feb. 2004), 8–. [^15]: MOON, S.-P., KIM, J.-W., BAE, K.-H., LEE, J.-C., AND SEO, D.-W. Embedded linux implementation on a commercial digital tv system. Consumer Electronics, IEEE Transactions on 49, 4 (Nov 2003), 1402–1407. [^16]: PIKE, R. Another go at language design. Stanford University Computer Systems Laboratory Colloquium. [^17]: RITCHIE, D. M. The limbo programming language. Inferno Programmer’s Manual 2 (1997). [^18]: SACCO, A. L., AND ORTEGA, A. A. Persistent bios infection. In CanSecWest Applied Security Conference (2009). [^19]: SAMPATHKUMAR, R. Vulnerability Management for Cloud Computing-2014: A Cloud Computing Security Essential. Rajakumar Sampathkumar, 2014. [^20]: SUGANUMA, T., OGASAWARA, T., TAKEUCHI, M., YASUE, T., KAWAHITO, M., ISHIZAKI, K., KOMATSU, H., AND NAKATANI, T. Overview of the ibm java just-in-time compiler. IBM systems Journal 39, 1 (2000), 175–193. [^21]: TEAM, G. The go programming language specification. Tech. rep., Technical Report <a href="http://golang/">http://golang</a>. org/doc/doc/go spec. html, Google Inc, 2009. [^22]: VAN HENSBERGEN, E., AND MINNICH, R. Grave robbers from outer space: Using 9p2000 under linux. In USENIX Annual Technical Conference, FREENIX Track (2005), pp. 83–94. [^23]: VARIOUS. No papers have been published on onie; see onie.org. [^24]: VARIOUS. No papers were published; see perllinux.sourceforge.net. [^25]: WATSON, G. R., SOTTILE, M. J., MINNICH, R. G., CHOI, S.-E., AND HERTDRIKS, E. Pink: A 1024-node single-system image linux cluster. In High Performance Computing and Grid in Asia Pacific Region, 2004. Proceedings. Seventh International Conference on (2004), IEEE, pp. 454–461. [^26]: WELLS, N. Busybox: A swiss army knife for linux. Linux J. 2000, 78es (Oct. 2000). [^27]: WINTERBOTTOM, P. Alef language reference manual. Plan 9 Programmer’s Man (1995). <a href="#fr-1-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="使用-qemu-的-u-root-示範"><a class="header" href="#使用-qemu-的-u-root-示範">使用 QEMU 的 u-root 示範</a></h1>
<p>You can try out LinuxBoot without needing to build anything! You can try out LinuxBoot needing only 3 commands.</p>
<p>We have made Initial Ram File System (initramfs) images available for four architectures: arm, aarch64, amd64 (a.k.a. x86_64), and riscv64.</p>
<p>For now, we only have a kernel ready for x86_64, so the instructions below apply to that.</p>
<p>First, you can get the initramfs image, which mainly contains Go programs from the u-root project.</p>
<pre><code class="language-bash">curl -L -o u-root.cpio.xz https://github.com/linuxboot/u-root-builder/releases/download/v0.0.1/u-root_amd64_all.cpio.xz
</code></pre>
<p>Next, you will need to get a kernel. We use a pre-built kernel from Arch Linux.</p>
<pre><code class="language-bash">curl -L -o linux.tar.zst https://archlinux.org/packages/core/x86_64/linux/download/
tar -xf linux.tar.zst
</code></pre>
<p>Now you are ready to test LinuxBoot out.</p>
<pre><code class="language-bash">qemu-system-x86_64 -enable-kvm -machine q35 -nographic -append "console=ttyS0" \
  -kernel usr/lib/modules/*/vmlinuz -initrd u-root.cpio.xz
</code></pre>
<p>Or, for example, on Darwin:</p>
<pre><code class="language-bash">qemu-system-x86_64 -machine q35 -nographic -append "console=ttyS0" \
  -kernel usr/lib/modules/*/vmlinuz -initrd u-root.cpio.xz
</code></pre>
<p>You will see the following:</p>
<pre><code class="language-text">[... varying message or two depending on qemu version and OS]
2023/12/12 22:37:52 Welcome to u-root!
                              _
   _   _      _ __ ___   ___ | |_
  | | | |____| '__/ _ \ / _ \| __|
  | |_| |____| | | (_) | (_) | |_
   \__,_|    |_|  \___/ \___/ \__|

/#
</code></pre>
<p>You can type uname:</p>
<pre><code class="language-text">/# uname
Linux
/#
</code></pre>
<p>To exit qemu, just run the poweroff command:</p>
<pre><code class="language-text">/# poweroff
[   14.442914] reboot: Power down
</code></pre>
<p>You have just run your first LinuxBoot kernel.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linuxboot-utilities"><a class="header" href="#linuxboot-utilities">LinuxBoot Utilities</a></h1>
<p>In order to bootstrap, build and maintain LinuxBoot projects, we provide a handful of utilities for extracting, reducing, reworking, and stitching firmware images.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uefi工具包"><a class="header" href="#uefi工具包">UEFI工具包</a></h1>
<p>Authors: Ryan O'Leary, Gan Shun Lim and Andrea Barberio</p>
<p>In previous chapters, you learned how to read a raw ROM image from a flash part. If you've been following along, you know the next step is to insert a Linux kernel.</p>
<p>Inspecting and modifying ROM images is tricky and can involve a fair amount of tinkering. These images typically contain a number of file systems, drivers, tables, data structures and opaque blobs. They also differ significantly from the UNIX model of a file systems, thus cannot be reasonably mounted in Linux.</p>
<p>UEFI Tool Kit (UTK) is intended to be a one-stop-shop for reading, writing and modifying UEFI images -- the most common type of firmware image for x86 systems. UTK can parse a number of data structures including UEFI firmware volumes, Intel firmware descriptors and FIT.</p>
<p>In this chapter, we'll go over how to:</p>
<ol>
<li>Install UTK</li>
<li>Inspect ROMs</li>
<li>Modify ROMs</li>
<li>Common pitfalls</li>
<li>Extend UTK with additional commands</li>
</ol>
<h2 id="synopsis"><a class="header" href="#synopsis">Synopsis</a></h2>
<pre><code>make bzImage
sudo flashrom -r /tmp/ROM.bin
utk /tmp/ROM.bin replace_pe32 Shell arch/86/boot/bzImage save /tmp/NEWROM.bin
sudo flashrom -w /tmp/NEWROM.bin
</code></pre>
<h2 id="quick-start"><a class="header" href="#quick-start">Quick start</a></h2>
<p>We assume you have a way to read and write the FLASH into a file.</p>
<p>Let's assume you have read FLASH into an image called ROM.bin and you have a kernel, called bzImage, which you want to insert into ROM.bin. Be sure the kernel is buildable as an EFI driver (DXE); see the pitfalls section. The easiest option is to replace the UEFI shell. This is a quick and easy way to get started. In the long term, you want to remove as much of UEFI as possible, but replacing the shell is always our first step on a new board.</p>
<p>Get the tool:</p>
<pre><code>go get -u github.com/linuxboot/fiano/cmds/utk
</code></pre>
<p>Replace the shell:</p>
<pre><code>utk ROM.bin replace_pe32 Shell bzImage save NEWROM.bin
</code></pre>
<p>After that, you can flash NEWROM.bin and test. If anything goes wrong, such as not enough space, you will need to refer to the more detailed instructions below.</p>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>At the time of writing, you must clone and build UTK from source -- binary distributions are not officially available. The source code resides in the <a href="https://github.com/linuxboot/fiano/">Fiano Github project</a>.</p>
<p>Aside: what is the difference between Fiano and UTK? The Fiano project contains a few more tools besides UTK, but UTK is a big element.</p>
<p>We'll assume you already have Go installed. Check your installation with:</p>
<pre><code>$ go version
go version go1.11 linux/amd64
</code></pre>
<p>Linux and the latest stable version of Go are recommended. Either download the official binary distributions of Go or install from source. See <a href="https://golang.org/">https://golang.org/</a> for details.</p>
<p>With Go, download and install UTK:</p>
<pre><code>go get -u github.com/linuxboot/fiano/cmds/utk
</code></pre>
<p>Running the above line installs <code>utk</code> to your <code>$GOPATH/bin</code> directory (or <code>$HOME/go/bin</code> if the <code>GOPATH</code> environment variable is not set). Adding this directory to your <code>$PATH</code> is recommended.</p>
<p>Make sure it works with:</p>
<pre><code>$ utk -h
Usage: utk [flags] &lt;file name&gt; [0 or more operations]

Operations:
  cat                   : cat a file with a regexp that matches a GUID
  comment               : Print one arg
  count                 : count the number of each firmware type
  dump                  : dump a firmware file
  dxecleaner            : automates removal of UEFI drivers
  dxecleaner_blacklist  : automates removal of UEFI drivers with a blacklist file
  extract               : extract the files to a directory
  find                  : find a file by GUID or Name
  flatten               : prints a JSON list of nodes
  insert_after          : insert a file after another file
  insert_before         : insert a file before another file
  insert_end            : insert a file at the end of a firmware volume
  insert_front          : insert a file at the beginning of a firmware volume
  json                  : produce JSON for the full firmware volume
  remove                : remove a file from the volume
  remove_pad            : remove a file from the volume and replace it with a pad file of the same size
  repack                : repack a per file compressed fv to a nested compressed fv
  replace_pe32          : replace a pe32 given a GUID and new file
  save                  : assemble a firmware volume from a directory tree
  table                 : print out important information in a pretty table
  validate              : perform extra validation checks
</code></pre>
<p>Don't fret if your list of operations differs. UTK is an evolving project!</p>
<h2 id="inspecting-roms"><a class="header" href="#inspecting-roms">Inspecting ROMs</a></h2>
<p>Throughout this section, we'll demonstrate commands for inspecting a UEFI image. When confronted with a new image, run these commands to get a "lay of the land".</p>
<p>Start by downloading the UEFI image used in these examples:</p>
<pre><code>wget https://github.com/linuxboot/fiano/raw/master/integration/roms/OVMF.rom
</code></pre>
<p>Aside: alternatively, all UTK operations should work with your own UEFI images. Simply substitute "OVMF.rom" with your own UEFI image in all the examples below. If you encounter any problems, please file an issue at <a href="https://github.com/linuxboot/fiano/issues">https://github.com/linuxboot/fiano/issues</a>.</p>
<p>First, it is advisable to print a count of each firmware element:</p>
<pre><code>$ utk OVMF.rom count
{
        "FirmwareTypeCount": {
                "BIOSRegion": 1,
                "File": 118,
                "FirmwareVolume": 5,
                "Section": 365
        },
        "FileTypeCount": {
                "EFI_FV_FILETYPE_APPLICATION": 2,
                "EFI_FV_FILETYPE_DRIVER": 94,
                "EFI_FV_FILETYPE_DXE_CORE": 1,
                "EFI_FV_FILETYPE_FFS_PAD": 7,
                "EFI_FV_FILETYPE_FIRMWARE_VOLUME_IMAGE": 1,
                "EFI_FV_FILETYPE_FREEFORM": 3,
                "EFI_FV_FILETYPE_PEIM": 7,
                "EFI_FV_FILETYPE_PEI_CORE": 1,
                "EFI_FV_FILETYPE_RAW": 1,
                "EFI_FV_FILETYPE_SECURITY_CORE": 1
        },
        "SectionTypeCount": {
                "EFI_SECTION_DXE_DEPEX": 44,
                "EFI_SECTION_FIRMWARE_VOLUME_IMAGE": 2,
                "EFI_SECTION_GUID_DEFINED": 1,
                "EFI_SECTION_PE32": 99,
                "EFI_SECTION_RAW": 21,
                "EFI_SECTION_USER_INTERFACE": 99,
                "EFI_SECTION_VERSION": 99
        }
}
</code></pre>
<p>The definition of a "Firmware Element" is in order. Firmware images are hierarchical and can be represented as a tree. Each node in the tree is a "Firmware Element". Each element has a type such as "BIOSRegion", "FirmwareVolume", "File" and "Section" as seen above. Files (and sections) themselves have an additional type dictated by the UEFI spec. There are three major file types you should be aware of:</p>
<ul>
<li><code>EFI_FV_FILETYPE_DRIVER</code>: This is the most numerous file type and is often called a "DXE". They persist in memory even after their main function exits.</li>
<li><code>EFI_FV_FILETYPE_APPLICATION</code>: Applications do not persist in memory after exiting. For example, the EFI Shell is an EFI Application.</li>
<li><code>EFI_FV_FILETYPE_FIRMWARE_VOLUME_IMAGE</code>: These file types allow nesting firmware volumes. You will see this when an entire firmware volume is compressed.</li>
</ul>
<p>TODO: Diagram showing a tree of these firmware elements.</p>
<p>To view a human-readable tree of all the firmware elements, types and sizes, run:</p>
<pre><code>$ utk OVMF.rom table | less
Node        GUID/Name                             Type                                   Size
BIOS                                                                                     0x400000
 FV         FFF12B8D-7696-4C8B-A985-2747075B4F50                                          0x84000
  Free                                                                                        0x0
 FV         8C8CE578-8A3D-4F1C-9935-896185C32DD3                                         0x348000
  File      9E21FD93-9C72-4C15-8C4B-E77F1DB2D792  EFI_FV_FILETYPE_FIRMWARE_VOLUME_IMAGE  0x1256a7
   Sec                                            EFI_SECTION_GUID_DEFINED               0x12568f
    Sec                                           EFI_SECTION_RAW                            0x7c
    Sec                                           EFI_SECTION_FIRMWARE_VOLUME_IMAGE       0xe0004
     FV     8C8CE578-8A3D-4F1C-9935-896185C32DD3                                          0xe0000
      File  1B45CC0A-156A-428A-AF62-49864DA0E6E6  EFI_FV_FILETYPE_FREEFORM                   0x2c
       Sec                                        EFI_SECTION_RAW                            0x14
      File  FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF  EFI_FV_FILETYPE_FFS_PAD                    0x40
      File  52C05B14-0B98-496C-BC3B-04B50211D680  EFI_FV_FILETYPE_PEI_CORE                 0xc4fa
       Sec                                        EFI_SECTION_RAW                            0x3c
       Sec                                        EFI_SECTION_PE32                         0xc484
       Sec  PeiCore                               EFI_SECTION_USER_INTERFACE                 0x14
       Sec                                        EFI_SECTION_VERSION                         0xe
...
</code></pre>
<p>This format is compact and easy for humans reading, but not ideal for machine consumption. Use the <code>json</code> command to print everything (including much more metadata) as JSON:</p>
<pre><code>utk OVMF.rom json | less
</code></pre>
<p>Combine <code>utk</code> with the JSON query command, <code>jq</code> (<code>sudo apt-get install jq</code>), and other UNIX commands to quickly write powerful queries. For example, the following lists all the GUIDs, sorted and without duplicates:</p>
<pre><code>$ utk OVMF.rom json | jq -r '..|.GUID?|select(type=="string")' | sort -u
00000000-0000-0000-0000-000000000000
0167CCC4-D0F7-4F21-A3EF-9E64B7CDCE8B
0170F60C-1D40-4651-956D-F0BD9879D527
021722D8-522B-4079-852A-FE44C2C13F49
025BBFC7-E6A9-4B8B-82AD-6815A1AEAF4A
...
</code></pre>
<p>To only print the JSON for specific files, use the find command:</p>
<pre><code># The find command uses a regex to match on the name or GUID.
# These three examples find and print the JSON for the same file:
$ utk OVMF.rom find 'Sh.*'
$ utk OVMF.rom find 'Shell'
$ utk OVMF.rom find 7C04A583-9E3E-4F1C-AD65-E05268D0B4D1
{
        "Header": {
                "UUID": {
                        "UUID": "7C04A583-9E3E-4F1C-AD65-E05268D0B4D1"
                },
                "Type": 9,
                "Attributes": 0
        },
        "Type": "EFI_FV_FILETYPE_APPLICATION",
        "Sections": [
                {
                        "Header": {
                                "Type": 21
                        },
                        "Type": "EFI_SECTION_USER_INTERFACE",
                        "ExtractPath": "",
                        "Name": "Shell"
                },
                ...
        ],
        "ExtractPath": "",
        "DataOffset": 24
}
</code></pre>
<p>Note that UEFI uses GUIDs to identify files. Some files also have a name which is stored within the file's UI section. Like <code>find</code>, most of UTKs commands let you match a file by its name or GUID.</p>
<p>The examples up until now have only dealt with file metadata and not the file's contents. The <code>extract &lt;DIR&gt;</code> command extracts all the files from the image and saves them to <code>&lt;DIR&gt;</code>. <code>&lt;DIR&gt;/summary.json</code> lists all the paths to the extracted files along with their metadata.</p>
<pre><code>utk OVMF.rom extract OVMF/
</code></pre>
<p>After modifying the files, they can be reassembled with:</p>
<pre><code>utk OVMF/ save OVMF2.rom
</code></pre>
<h2 id="modifying-roms"><a class="header" href="#modifying-roms">Modifying ROMs</a></h2>
<p>First, let's verify the image works by running it inside QEMU. This step is not absolutely necessary, but gives us confidence the image works before and after each change we make.</p>
<pre><code>qemu-system-x86_64 -bios OVMF.rom -nographic -net none
</code></pre>
<p>For the provided OVMF.rom image, this should boot to the EDK2 shell.</p>
<p>TODO: include screenshot of the EDK2 shell</p>
<p>Multiple commands can be used together to form a pipeline. The first argument always loads the image into memory and the last argument typically writes the output. The commands in between operate on the image in memory and are reminiscent of a UNIX pipeline. The general syntax is:</p>
<pre><code>utk &lt;IMAGE or DIR&gt;                 \
  &lt;COMMAND0&gt; &lt;ARG0_0&gt; &lt;ARG0_1&gt; ... \
  &lt;COMMAND1&gt; &lt;ARG1_0&gt; &lt;ARG1_1&gt; ... \
  ...
</code></pre>
<p>To see the pipeline in action, we introduce two new commands:</p>
<ul>
<li><code>remove &lt;file GUID or NAME regex&gt;</code>: Remove a file from a firmware volume. The search has the same semantics as <code>find</code>.</li>
<li><code>replace_pe32 &lt;file GUID or NAME regex&gt; &lt;FILE&gt;</code>: Replace the pe32 section of a file with the given file. The search has the same semantics as <code>find</code>. The file must be a valid pe32 binary.</li>
<li><code>save &lt;FILE&gt;</code>: Save the firmware image to the given file. Usually, this is the last command in a pipeline.</li>
</ul>
<p>The following pipeline removes some unnecessary drivers (anything that starts with Usb and the Legacy8259 driver which has the GUID 79ca4208-bba1-4a9a-8456-e1e66a81484e) and replaces the Shell with Linux. Often you need to remove drivers to make room for Linux which makes the pipeline convenient. This is the essence of LinuxBoot:</p>
<pre><code>$ stat linux.efi
linux.efi: Linux kernel x86 boot executable bzImage, version 4.17.0
$ utk OVMF.rom \
  remove 'Usb.*' \
  remove 79ca4208-bba1-4a9a-8456-e1e66a81484e \
  replace_pe32 Shell linux.efi \
  save OVMF2.rom
</code></pre>
<p>That's all there to it! Try experimenting with the other commands such as insert.</p>
<h2 id="common-pitfalls"><a class="header" href="#common-pitfalls">Common Pitfalls</a></h2>
<h3 id="kernel-is-not-built-as-a-dxe-or-has-not-enabled-uefi-stub-mode"><a class="header" href="#kernel-is-not-built-as-a-dxe-or-has-not-enabled-uefi-stub-mode">Kernel is not built as a DXE or has not enabled UEFI stub mode</a></h3>
<p>In order to be properly bootable as a DXE, kernels must have the following enabled:</p>
<pre><code>CONFIG_EFI=y
CONFIG_EFI_STUB=y
</code></pre>
<h3 id="files-are-missing-from-the-firmware-volume"><a class="header" href="#files-are-missing-from-the-firmware-volume">Files are missing from the Firmware Volume</a></h3>
<p>When UTK does not recognize the compression format used by the particular image, the files within it are not listed.</p>
<p>In the wild, three compression schemes are common:</p>
<div class="table-wrapper"><table><thead><tr><th>Compression</th><th>GUID</th><th>UTK Support</th></tr></thead><tbody>
<tr><td>Uncompressed</td><td></td><td>Fully supported</td></tr>
<tr><td>LZMA</td><td>EE4E5898-3914-4259-9D6E-DC7BD79403CF</td><td>Fully supported</td></tr>
<tr><td>LZMA + x86</td><td>D42AE6BD-1352-4BFB-909A-CA72A6EAE889</td><td>Supported, but not tested</td></tr>
<tr><td>Tianocore</td><td>A31280AD-481E-41B6-95E8-127F4C984779</td><td>Not supported, see <a href="https://github.com/linuxboot/fiano/issues/226">#226</a></td></tr>
</tbody></table>
</div>
<p>To determine which compression scheme you are using, search for the respective GUID in the json summary.</p>
<h3 id="file-size-too-big"><a class="header" href="#file-size-too-big">File size too big</a></h3>
<pre><code>File size too big! File with GUID: XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX has length 543210, but is only 123450 bytes big
</code></pre>
<p>When saving a UEFI image, files are added successively to each firmware volume. The first file which overflows the volume's size causes this error.</p>
<p>If you were inserting files, you will need to delete existing files to make room.</p>
<p>There is a special cases where this error is generated without any operations:</p>
<pre><code>utk OVMF.rom save OVMF2.rom
</code></pre>
<p>How can this be? No changes should be made to the image!</p>
<p>Not quite (and the complete list of differences can be found in the "binary equality section") -- compressed volumes are recompressed.</p>
<p>By default, UTK uses the Go compressor, which is generally worse than the compression found in most UEFI images. Pass <code>--systemXZ=xz</code> as the first argument to UTK to use a better compressor.</p>
<h3 id="todo-for-everything-after-this-point-arbitrary-data-before-or-after-the-image"><a class="header" href="#todo-for-everything-after-this-point-arbitrary-data-before-or-after-the-image">(TODO for everything after this point) Arbitrary data before or after the image</a></h3>
<p>Find a general solution which works for all images is a topic of research: <a href="https://github.com/linuxboot/fiano/issues/200">#200</a>.</p>
<h3 id="hard-coded-addresses"><a class="header" href="#hard-coded-addresses">Hard-coded addresses</a></h3>
<h3 id="binary-equality"><a class="header" href="#binary-equality">Binary equality</a></h3>
<p>TODO</p>
<h2 id="extending-utk"><a class="header" href="#extending-utk">Extending UTK</a></h2>
<p>Visitor pattern means decoupling the structure from the operations.</p>
<ul>
<li>pkg/uefi: structure</li>
<li>pkg/visitors: operations</li>
</ul>
<p>Good resources:</p>
<ol>
<li>https://sourcemaking.com/design_patterns/visitor</li>
<li>https://en.wikipedia.org/wiki/Visitor_pattern</li>
</ol>
<p>A good visitor still works when new Firmware are introduced. A good Firmware still works when a new visitor is introduced.</p>
<h3 id="ast"><a class="header" href="#ast">AST</a></h3>
<p>Abstract Syntax Tree -- this is a concept borrowed from compilers. When you're extracting the DXE to create a tree of structs containing a simplified model, you're essentially creating an AST. Then think about how patterns used in compiler architecture might apply to UTK.</p>
<h3 id="visitor-interface"><a class="header" href="#visitor-interface">Visitor Interface</a></h3>
<p>Each visitor implements the following:</p>
<pre><code class="language-go">type Visitor interface {
    VisitFV(*FV) error
    VisitFile(*File) error
    VisitSection(*FileSection) error
    // ...
}
</code></pre>
<p>Think of a visitor as an "action" or a "transformation" being applied on the AST.</p>
<h3 id="visitor"><a class="header" href="#visitor">Visitor</a></h3>
<p>A struct implementing Visitor performs a transformation on the AST, for example:</p>
<pre><code class="language-go">type RenameDXE struct {
    before, after string
}
func (v *RenameDXE) VisitFV(fv *FV) error {
    // Recursively apply on files in the FV.
    for i := range fv.Files {
        fv.Files[i].Apply(v)
    }
    return nil
}
func (v *RenameDXE) VisitFile(f *File) error {
    if f.Type == FILETYPE_DXE &amp;&amp; f.Name == v.before {
        f.Name = after
    }
    return nil
}
func (v *RenameDXE) VisitSection(s *FileSection) error {
    return nil
}
</code></pre>
<p>You can imagine visitors being implemented for other actions, such as:</p>
<ul>
<li>Remove a DXE with the given GUID from the AST</li>
<li>Replace a GUID with a file</li>
<li>Validate that all the nodes in the tree are valid</li>
<li>Find compressed files in the tree and decompress them</li>
<li>Assemble the AST back into an image.</li>
<li>Recursively write the AST to the filesystem (what you currently do with extract)</li>
<li>Print an overview of the files to the terminal for debugging</li>
<li>...</li>
</ul>
<p>It is easy to add more visitors without modifying existing code. Each action can be in a separate file.</p>
<h3 id="applying"><a class="header" href="#applying">Applying</a></h3>
<p>Visitors are applied to the AST. Each node in the AST has an "Apply" method, for example:</p>
<pre><code class="language-go">func (f *File) Apply(v *visitor) error {
    return v.VisitFile(f)
}
</code></pre>
<p>This is so the visitors can be applied recursively over the AST.</p>
<p>To apply the above RenameDXE visitor, you'd run:</p>
<pre><code class="language-go">v := &amp;RenameDXE{"Shell", "NotShell"}
fv.Apply(v)
</code></pre>
<h3 id="chaining-visitors-together"><a class="header" href="#chaining-visitors-together">Chaining Visitors Together</a></h3>
<p>It would be exciting/useful to be able to chain these small actions together through the command line. For example:</p>
<pre><code>utk extract bios.rom \
    remove a2dad2a-adadad-a2d2-ad23a3 \
    remove 9d8cd98-d9c8d9-d9c8-9d8c8c \
    replaceDXEWithFile bab8a98-a9ba89a-9aba-a98a9 linux.efi \
    validate \
    save new_bios.rom
</code></pre>
<p>Again, it is easy to write new actions in Go which modify nodes in the AST. Create a new file, new struct, and implement the visitFV/visitFile/visitSection methods to modify the AST.</p>
<p>TODO: reference the UEFI spec.</p>
<p>TODO: mention alternatives</p>
<ul>
<li>binwalk</li>
<li>fresh0r/romdump</li>
<li>UEFITool</li>
<li>uefi-firmware-parser</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-u-root-cpu-command"><a class="header" href="#the-u-root-cpu-command">The u-root <code>cpu</code> command</a></h1>
<p>Do you want to have all the tools on your  system that you have on your desktop, but you can't get them to fit in your tiny flash part? Do you want all your desktop files visible on your  system, but just remembered there's no disk on your  system? Are you tired of using <code>scp</code> or <code>wget</code> to move files around? Do you want to run <code>emacs</code> or <code>vim</code> on the  machine, but know they can't ever fit? What about <code>zsh</code>? How about being able to run commands on your  machine and have the output appear on your home file system? You say you'd like to make this all work without having to fill out web forms in triplicate to get your organization to Do Magic to your desktop?</p>
<p><strong>Your search is over: <code>cpu</code> is here to answer all your usability needs.</strong></p>
<h2 id="the-problem-running-your-program-on-some-other-system"><a class="header" href="#the-problem-running-your-program-on-some-other-system">The problem: running your program on some other system</a></h2>
<p>People often need to run a command on a remote system. That is easy when the remote system is the same as the system you are on, e.g., both systems are Ubuntu 16.04; and all the libraries, packages, and files are roughly the same. But what if the systems are different, say, Ubuntu 16.04 and Ubuntu 18.10? What if one is Centos, the other Debian? What if a required package is missing on the remote system, even though in all other ways they are the same?</p>
<p>While these systems are both Linux, and hence can provide Application Binary Interface (ABI) stability at the system call boundary, above that boundary stability vanishes. Even small variations between Ubuntu versions matter: symbol versions in C libraries differ, files are moved, and so on.</p>
<p>What is a user to do if they want to build a binary on one system, and run it on another system?</p>
<p>The simplest approach is to copy the source to that other system and compile it. That works sometimes. But there are limits: copying the source might not be allowed; the code might not even compile on the remote system; some support code might not be available, as for a library; and for embedded systems, there might not be a compiler on the remote system. Copy and compile is not always an option. In fact it rarely works nowadays, when even different Linux distributions are incompatible.</p>
<p>The next option is to use static linking. Static linking is the oldest form of binary on Linux systems. While it has the downside of creating larger binaries, in an age of efficient compilers that remove dead code, 100 gigabit networks, and giant disks and memory, that penalty is not the problem it once was. The growth in size of static binaries is nothing like the growth in efficiency and scale of our resources. Nevertheless, static linking is frowned upon nowadays and many libraries are only made available for dynamic linking.</p>
<p>Our user might use one of the many tools that package a binary and all its libraries into a single file, to be executed elsewhere. The u-root project even offers one such tool, called <code>pox</code>, for portable executables. <code>Pox</code> uses the dynamic loader to figure out all the shared libraries a program uses, and place them into the archive as well. Further, the user can specify additional files to carry along in case they are needed.</p>
<p>The problem here is that, if our user cares about binary size, this option is even worse. Dead code removal won’t work; the whole shared library has to be carried along. Nevertheless, this can work, in some cases.</p>
<p>So our user packages up their executable using <code>pox</code> or a similar tool, uses <code>scp</code> to get it to the remote machine, logs in via <code>ssh</code>, and all seems to be well, until at some point there is another message about a missing shared library! How can this be? The program that packaged it up checked for all possible shared libraries.</p>
<p>Unfortunately, shared libraries are now in the habit of loading other shared libraries, as determined by reading text files. It’s no longer possible to know what shared libraries are used; they can even change from one run of the program to the next. One can not find them all just by reading the shared library itself. A good example is the name service switch library, which uses <code>/etc/nsswitch.conf</code> to find other shared libraries. If <code>nsswitch.conf</code> is missing, or a library is missing, some versions of the name service switch library will core dump.</p>
<p>Not only must our user remember to bring along <code>/etc/nsswitch.conf</code>, they must also remember to bring along all the libraries it might use. This is also true of other services such as Pluggable Authentication Modules (PAM). And, further, the program they bring along might run other programs, with their own dependencies. At some point, as the set of files grows, frustrated users might decide to gather up all of <code>/etc/</code>, <code>/bin</code>, and other directories, in the hope that a wide enough net might bring along all that’s needed. The remote system will need lots of spare disk or memory! We’re right back where we started, with too many files for too little space.</p>
<p>In the worst case, to properly run a binary from one system, on another system, one must copy everything in the local file system to the remote system. That is obviously difficult, and might be impossible if the remote system has no disk, only memory.</p>
<p>One might propose having the remote system mount the local system via NFS or Samba. While this was a common approach years ago, it comes with its own set of problems: all the remote systems are now hostage to the reliability of the NFS or Samba server. But there’s a bigger problem: there is still no guarantee that the remote system is using the same library versions and files that the user’s desktop is using. The NFS server might provide, e.g. SUSE, to the remote system; the user’s desktop might be running Ubuntu. If the user compiles on their desktop, the binary might still not run on the remote system, as the SUSE libraries might be different. This is a common problem.</p>
<p>Still worse, with an NFS root, everyone can see everyone’s files. It’s like living in an apartment building with glass walls. Glass houses only look good in architecture magazines. People want privacy.</p>
<h3 id="what-ssh-does-not-provide"><a class="header" href="#what-ssh-does-not-provide">What SSH does not provide</a></h3>
<p><code>ssh</code> solves the problem of safely getting logged in to a remote machine. While this is no small accomplishment, it is a lot like being parachuted into a foreign land, where the rules are changed. It’s a lot nicer, when going to a new place, to be able to bring along some survival gear, if not your whole house!</p>
<p>Users need a way to log in to a machine, in a way similar to <code>ssh</code>, but they need to bring their environment with them. They need their login directory; their standard commands; their configuration files; and they need some privacy. Other users on the machine should not be able to see any of the things they bring with them. After all, everyone who goes camping wants to believe they are the only people at that campground!</p>
<h3 id="how-cpu-provides-what-we-need"><a class="header" href="#how-cpu-provides-what-we-need">How <code>cpu</code> provides what we need</a></h3>
<p><code>cpu</code> is a Go-based implementation of Plan 9's <code>cpu</code> command. It uses the go <code>ssh</code> package, so all your communications are as secure as <code>ssh</code>. It can be started from <code>/sbin/init</code> or even replace <code>/sbin/init</code>, so you have a tiny flash footprint. You can see the code at <a href="https://github.com/u-root/cpu">github.com:u-root/cpu</a>. It's also small: less than 20 files, including tests.</p>
<p><code>cpu</code> runs as both a client (on your desktop) and an <code>ssh</code> server (on your machine). On your desktop, it needs no special privilege. On the system, there is only one binary needed: the <code>cpu</code> daemon (<code>cpud</code>). As part of setting up a session, in addition to normal <code>ssh</code> operations, <code>cpu</code> sets up private name space at important places like <code>/home/$USER</code>, <code>/bin, /usr,</code>and so on. Nobody gets to see what other people’s files are.</p>
<p><code>Ssh</code> provides remote access. <code>cpu</code> goes one step further, providing what is called <em>resource sharing</em> -- resources, i.e., files from the client machine can be used directly on the remote machine, without needing to manually copy them. <code>cpud</code> implements resource sharing by setting up a <code>file system</code>mount on the remote machine and relaying file I/O requests back to the desktop <code>cpu</code> process. The desktop command services those requests; you don't need to run a special external server. One thing that is a bit confusing with <code>cpu</code>: the desktop client is a file server; the remote server’s Linux kernel is a file client. <code>cpu</code> has to do a bit more work to accomplish its task.</p>
<p><code>cpu</code> will change your life. You can forget about moving files via <code>scp</code>: once you '<code>cpu</code> in', the <code>/home</code> directory on your  node is your home directory. You can <code>cd ~</code>and see all your files. You can pick any shell you want, since the shell binary comes from your desktop, not flash. You don't have to worry about fitting <code>zsh</code> into flash ever again!</p>
<p>At Google we can now run <code>chipsec</code>, which imports 20M of Python libraries, because we have <code>cpu</code> and we can redirect <code>chipsec</code> output to files in our home directory.</p>
<p>Here is an example session:</p>
<p>In this command, we <code>cpu</code> to a PC Engines APU2. We have built a kernel and u-root initramfs containing just one daemon -- the <code>cpu</code> daemon -- into the flash image. The APU2 does not even need a disk; it starts running as a “<code>cpu</code> appliance.”</p>
<p>The <code>bash</code> is not on the <code>cpu</code> node; it will come from our desktop via the 9p mount.</p>
<pre><code class="language-bash">rminnich@xcpu:~/gopath/src/github.com/u-root/u-root$ cpu apu2
root@(none):/#
root@(none):/# ls ~
IDAPROPASSWORD  go      ida-7.2  projects
bin             gopath  papers   salishan2019random  snap
root@(none):/# exit
</code></pre>
<p>The <code>bash</code> and <code>ls</code> command, and the shared libraries they need, do not exist on the apu2; <code>cpu</code> makes sure that the client provides them to the <code>cpu</code> server. The home directory is, similarly, made available to the remote machine from the local machine.</p>
<p>A big benefit of <code>cpu</code> is that, as long as the network works, users can create very minimal flash images, containing just the <code>cpu</code> daemon, just enough to get the network going. Once the network is up, users can <code>'cpu</code> in', and everything they need is there. It actually looks like they are still logged in to their desktop, except, of course, truly local file systems such as <code>/proc</code> and <code>/sys</code> will come from the machine they are on, not their desktop.</p>
<h2 id="an-easy-overview-of-how-cpu-works"><a class="header" href="#an-easy-overview-of-how-cpu-works">An easy overview of how <code>cpu</code> works</a></h2>
<p><code>cpu</code>, as mentioned, consists of a client and a server. The client is on your desktop (or laptop), and the server is on the remote system. Both client and server use an <code>ssh</code> transport, meaning that the “wire” protocol is <code>ssh</code>. In this way, <code>cpu</code> is just like <code>ssh</code>.</p>
<p>As mentioned above, the situation for <code>cpu</code> is a bit more complicated than for <code>ssh</code>. <code>cpu</code> provides resource sharing, but not from the server to the client, but rather from the client to the server. The <code>cpu</code> client is a file server; the <code>cpu</code> server connects the kernel on the server machine to the file server in the client, as shown below. Things to note:</p>
<ol>
<li><code>cpud</code>, on the remote or server machine, sets up a “private name space mount” of <code>/tmp</code> for the program. “Private name space mount” just means that only that program, and its children, can see what is in its private <code>/tmp</code>. Other, external programs continue to use <code>/tmp</code>, but they are <em>different</em> instantiations of <code>/tmp</code>.</li>
<li>The private name space mount of <code>/tmp</code> is on a filesystem in RAM. The data stored in <code>/tmp</code> is not visible to other processes, and not persistent.</li>
<li><code>cpud</code> creates a directory, <code>cpu</code>, in the private <code>/tmp</code>; and mounts the server on it. This mount point is also invisible outside the process and its children.</li>
<li>To make sure that names like <code>/bin/bash</code>, and <code>/usr/lib/libc.so</code> work, <code>cpud</code> sets up <em>bind mounts</em> from, e.g., <code>/tmp/cpu/bin</code> to <code>/bin</code>. These are also private mounts, and do not affect any program outside the one <code>cpud</code> starts. Anytime the program and its children access files in <code>/bin</code>, <code>/lib</code>, <code>/usr</code>, <code>/home/$USER</code>, and so on, they are accessing files from the client machine via the built-in client file server.</li>
<li>The client <code>cpu</code> program passes the full environment from the client machine to <code>cpud</code>. When the client program requests that, e.g., <code>bash</code> be run, the <code>cpud</code> uses the PATH environment variable to locate <code>bash</code>. Because of the private name space mounts and binds, <code>bash</code> will be found in <code>/bin/bash</code>, and its libraries will be found in their usual place. This is an essential property of <code>cpu</code>, that the names used on the user’s machine work the same way on the remote machine. An overview of the process is shown below.</li>
</ol>
<img src="utilities/../images/cpu_overview.svg" width=600px>
<h2 id="cpu-startup"><a class="header" href="#cpu-startup"><code>cpu</code> startup</a></h2>
<p>The startup proceeds in several steps. Every session begins with an initial contact from the <code>cpu</code> client to the <code>cpu</code> server.</p>
<img src="utilities/../images/cpu_startup.svg" width=600px>
<p>The first step the <code>cpud</code> does is set up the mounts back to the client. It then sets up the bind mounts such as <code>/bin</code> to <code>/tmp/cpu/bin</code>. In the following figure, we compress the Linux kernel mount and bind mounts shown above into a smaller box called “name space.”</p>
<img src="utilities/../images/cpu_first_step.svg" width=600px>
<p>Next, <code>cpu</code> and the <code>cpud</code> set up the terminal management.</p>
<img src="utilities/../images/cpu_second_step.svg" width=600px>
<p>Finally, <code>cpud</code> sets up the program to run. Because the PATH variable has been transferred to <code>cpud</code>, and the name space includes <code>/bin</code> and <code>/lib</code>, the <code>cpud</code> can do a standard Linux <code>exec</code> system call without having to locate where everything is. Native kernel mechanisms create requests as files are referenced, and the <code>cpu</code> file server support does the rest.</p>
<img src="utilities/../images/cpu_third_step.svg" width=600px>
<p>Why do we only show one program instead of many? From the point of view of <code>cpud</code>, it only starts one program. From the point of view of users, there can be many. But if there is more than one program to start, <em>that is not the responsibility of <code>cpud</code></em>. If more than one program is run, they will be started by the program that <code>cpud</code> started, i.e., a command interpreter like the shell. Or it could be as simple as a one-off command like <code>date</code>. From the point of view of <code>cpud</code>, it’s all the same. <code>cpud</code> will wait until the process it started, and all its children, have exited. But <code>cpud</code>’s responsibilities to start a program ends with that first program.</p>
<p>But what happens when <code>cpud</code> runs that first program? Here is where it gets interesting, and, depending on your point of view, either magical, confounding, or counter-intuitive. We’ll go with magical.</p>
<h3 id="starting-that-first-program"><a class="header" href="#starting-that-first-program">Starting that first program</a></h3>
<p>As mentioned above, <code>cpud</code> sets up mounts for a name space, and calls the Linux <code>exec()</code> call to start the program.</p>
<p>We can actually watch all the <code>cpu</code> file server operations. The file server protocol is called 9P2000. We are going to present a filtered version of the file I/O from running a remote <code>date</code>; in practice, you can watch all the opens, reads, writes, and closes the remote process performs.</p>
<p>The trace for running <code>date</code> starts right when the remote program has called <code>exec</code>, and the kernel is starting to find the program to run<sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup>. The file opens look like this, on a user’s system:</p>
<pre><code class="language-txt">Open /bin/date
Open /lib/x86_64-linux-gnu/ld-2.27.so
Open /etc/ld.so.cache
Open /lib/x86_64-linux-gnu/libc-2.27.so
Open /usr/lib/locale/locale-archive
Open /usr/share/zoneinfo/America/Los_Angeles
</code></pre>
<p>The kernel opened <code>/bin/date</code>, determined what libraries (files ending in <code>.so</code>) it needed, and opened them as well.</p>
<p>We can compare this with a local execution:</p>
<pre><code class="language-txt">execve "/bin/date"
access "/etc/ld.so.nohwcap"
access "/etc/ld.so.preload"
openat "/etc/ld.so.cache"
access "/etc/ld.so.nohwcap"
openat "/lib/x86_64-linux-gnu/libc.so.6"
openat "/usr/lib/locale/locale-archive"
openat "/etc/localtime"
</code></pre>
<p>Note that several files do not show up in our trace; they are in <code>/etc</code>, and the <code>cpud</code> does not set up a bind mount over <code>/etc</code>. But the other files look very similar. You might wonder why the local version opens <code>/etc/localtime</code>, and the remote version opens <code>/usr/share/zoneinfo/America/Los_Angeles</code>.</p>
<p>The reason is that <code>etc/localtime</code> is a symlink:</p>
<pre><code class="language-bash">lrwxrwxrwx 1 root root 39 May 29 12:47 /etc/localtime -&gt; /usr/share/zoneinfo/America/Los_Angeles
</code></pre>
<p>The access to <code>/etc/localtime</code> does not get handled by the server; but the access to <code>/usr/share/zoneinfo/America/Los_Angeles</code>does.</p>
<p>What about different architectures? What if we are using an x86 but want to <code>cpu</code> to an ARM processor?</p>
<p>We can set the local <code>cpu</code> up to talk to a remote <code>cpu</code> that needs different binaries. We might have an entire ARM file system tree in <code>~/arm</code>, for example. We would then invoke <code>cpu</code> as follows:</p>
<pre><code class="language-bash">cpu -root ~/arm date
</code></pre>
<p>And the remote <code>cpud</code>, running on an ARM, would be provided with ARM binaries.</p>
<h3 id="learning-how-to-use-cpu"><a class="header" href="#learning-how-to-use-cpu">Learning how to use <code>cpu</code></a></h3>
<p><code>Cpu</code> can be a hard thing to learn, not because it is difficult, but because it is different. To paraphrase Yoda, you have to unlearn what you have learned. Forget about copying files from here to there; when you <code>cpu</code> there, it looks like your files are waiting for you.</p>
<p>You can start experimenting and learning about <code>cpu</code> by just running it locally.</p>
<h4 id="a-set-of-binaries-for-you-to-try"><a class="header" href="#a-set-of-binaries-for-you-to-try">A set of binaries for you to try</a></h4>
<p>In order for you to try it out, start by working with the set of <code>cpu</code> binaries at <a href="https://github.com/u-root/cpubinaries">https://github.com/u-root/cpubinaries</a>. With them, you can create a bootable, mountable USB image that you can download. The image contains a <code>cpu</code> client that runs on Linux, a private key, and, when booted, it starts a <code>cpu</code> daemon and waits to serve <code>cpu</code> clients. The <code>cpu</code> client is statically linked and hence should run on any Linux from the last 10 years or so.</p>
<p>The binaries include:</p>
<ul>
<li>A kernel (<code>cpukernel</code>) with a built-in initramfs containing <code>cpud</code>, as well as a public key. Also included, should you want to build your own, is the config file (<code>cpu.config</code>).</li>
<li>A binary client program, <code>cpu</code>, as well as the private key to use. You can place this key in <code>~/.ssh</code> or specify it via the <code>-key</code> option to <code>cpu</code>.</li>
<li>A script to run the USB stick via <code>qemu</code> (<code>TESTQEMU</code>); and a script to run a <code>cpu</code> command (<code>EXAMPLE</code>).</li>
<li>The <code>extlinux.conf</code> used for the USB stick.</li>
</ul>
<p><code>usbstick.xz</code> is a compressed USB stick image that is bootable. It will uncompress to about 7GB. You can use the <code>TESTQEMU</code> script to try it out, or use <code>dd</code> to write it to a USB stick and boot that stick on an x86 system.</p>
<p>Be careful how you use the keys; they're public. You should really only use them as part of the demo.</p>
<p>The <code>cpukernel</code> was built using the <code>github.com:/mainboards</code> repo. If you clone this repo, the following commands will rebuild the kernel:</p>
<ul>
<li><code>cd mainboards/intel/generic</code></li>
<li><code>make fetch</code></li>
<li><code>make cpukernel</code></li>
</ul>
<h4 id="how-to-use-the-cpu-binaries"><a class="header" href="#how-to-use-the-cpu-binaries">How to use the cpu binaries</a></h4>
<p>You’ll first need to start the server, and we show the entire sequence below, including unpacking the image:</p>
<pre><code class="language-bash">xz -d usbstick.xz
</code></pre>
<p>How you run <code>qemu</code> depends on whether you want graphics or not: if you are not in a windowing environment, add <code>-nographic</code> to the command below. In any event, at the <code>boot:</code> prompt, you can hit return or wait:</p>
<pre><code class="language-bash">bash QEMU -hda usbstick

SeaBIOS (version 1.13.0-1)
iPXE (http://ipxe.org) 00:03.0 CA00 PCI2.10 PnP PMM+3FF90750+3FED0750 CA00
Booting from Hard Disk...
SYSLINUX 6.03 EDD 20171017 Copyright (C) 1994-2014 H. Peter Anvin et al
boot:
.
.
.
Freeing unused kernel image (rodata/data gap) memory: 568K
rodata_test: all tests were successful
Run /init as init process
</code></pre>
<p>At this point, the <code>cpu</code> daemon is running, and you can try the <code>cpu</code> command:</p>
<pre><code class="language-bash">rminnich@minnich:/home/cpubinaries$ ./cpu -key cpu_rsa localhost date
Fri 16 Oct 2020 04:21:04 PM PDT
</code></pre>
<p>You can log in and notice that things are the same:</p>
<pre><code class="language-bash">rminnich@minnich:/home/cpubinaries$ ./cpu -key cpu_rsa localhost

root@192:/home/cpubinaries# ls
cpu         cpukernel  cpu_rsa.pub  extlinux.conf  QEMU       usbstick
cpu.config  cpu_rsa    EXAMPLE      LICENSE        README.md

root@192:/home/cpubinaries#
</code></pre>
<p>Note that you end up in the same directory on the remote node that you are in on the host; all the files are there. We can run any program on the remote node that we have on the host:</p>
<pre><code class="language-bash">root@192:/home/cpubinaries# which date
/usr/bin/date
root@192:/home/cpubinaries# date
Fri 16 Oct 2020 04:25:01 PM PDT
root@192:/home/cpubinaries# ldd /usr/bin/date
mount
    linux-vdso.so.1 (0x00007ffd83784000)
    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007efdb93db000)
    /lib64/ld-linux-x86-64.so.2 (0x00007efdb95e4000)
root@192:/home/cpubinaries# mount
...
cpu on /tmp type tmpfs (rw,relatime)
127.0.0.1 on /tmp/cpu type 9p (rw,nosuid,nodev,relatime,sync,dirsync,uname=rminnich,access=client,msize=65536,trans=fd,rfd=9,wfd=9)
rootfs on /tmp/local type rootfs (rw,size=506712k,nr_inodes=126678)
127.0.0.1 on /lib type 9p (rw,nosuid,nodev,relatime,sync,dirsync,uname=rminnich,access=client,msize=65536,trans=fd,rfd=9,wfd=9)
127.0.0.1 on /lib64 type 9p (rw,nosuid,nodev,relatime,sync,dirsync,uname=rminnich,access=client,msize=65536,trans=fd,rfd=9,wfd=9)
127.0.0.1 on /usr type 9p (rw,nosuid,nodev,relatime,sync,dirsync,uname=rminnich,access=client,msize=65536,trans=fd,rfd=9,wfd=9)
127.0.0.1 on /bin type 9p (rw,nosuid,nodev,relatime,sync,dirsync,uname=rminnich,access=client,msize=65536,trans=fd,rfd=9,wfd=9)
127.0.0.1 on /etc type 9p (rw,nosuid,nodev,relatime,sync,dirsync,uname=rminnich,access=client,msize=65536,trans=fd,rfd=9,wfd=9)
127.0.0.1 on /home type 9p (rw,nosuid,nodev,relatime,sync,dirsync,uname=rminnich,access=client,msize=65536,trans=fd,rfd=9,wfd=9)
root@192:/home/cpubinaries#
</code></pre>
<p>As you can see, <code>/tmp/cpu</code> is mounted via 9p back to the <code>cpu</code> client (recall that the <code>cpu</code> client is a 9p server, so your files are visible on the remote node). Further, you can see mounts on <code>/usr</code>, <code>/bin</code>, <code>/etc</code>, and so on. For this reason, we can run <code>date</code> and it will find its needed libraries in <code>/usr</code>, as the <code>ldd</code> command demonstrates.</p>
<h4 id="making-cpu-easier-to-use"><a class="header" href="#making-cpu-easier-to-use">Making cpu easier to use</a></h4>
<p>If you get tired of typing <code>-keys</code>, do the following: put your own <code>cpu_rsa</code> in <code>~/.ssh</code>; and copy the <code>cpu</code> binary to <code>bin</code> (or build a new one).</p>
<p>Warning! The <code>cpu</code> keys we provide in the repo are only to be used for this demo. You should not use them for any other purpose, as they are in a Github repo and hence open to the world.</p>
<h4 id="using-some-of-the-namespace"><a class="header" href="#using-some-of-the-namespace">Using some of the namespace</a></h4>
<p>Sometimes, you don’t want all the <code>/usr</code> and <code>/bin</code> directories to be replaced with those from your machine. You might, for example, <code>cpu</code> into an ARM system, and hence only need a <code>/home</code>, but nothing else.</p>
<p>The <code>-namespace</code> switch lets you control the namespace. It is structured somewhat like a path variable, with <code>:</code>-separated components. The default value is <code>/lib:/lib64:/usr:/bin:/etc:/home</code>. You can modify it or even force it to be empty: <code>-namespace=""</code>, for example. If it is empty, <code>cpud</code> will only mount the 9p server on <code>/tmp/cpu</code>.</p>
<p>This following example will cpu to an ARM64 host, sharing /home, but nothing else.</p>
<pre><code class="language-bash">cpu arm -namespace=/home /bin/date
</code></pre>
<p>For an different architecture system, we might want to specify that the /bin, /lib, and other directories have a different path on the remote than they have locally. The -namespace switch allows this via an = sign:</p>
<pre><code class="language-bash">cpu -namespace /lib:/lib64:/usr:/bin:/etc:/home arm /bin/date
</code></pre>
<p>In this case, <code>/bin</code>, <code>/usr</code>, and <code>/lib</code> on the remote system are supplied by <code>/arm/bin</code>, <code>/arm/lib</code>, and <code>/arm/usr</code> locally.</p>
<p>If we need to test <code>cpu</code> without doing bind mounts, we can specify a <code>PWD</code> that requires no mounts and an empty namespace:</p>
<pre><code class="language-txt">PWD=/ cpu -namespace="" -9p=false h /bin/ls
bbin
bin
buildbin
dev
env
etc
go
home
init
...
</code></pre>
<p>There is a bit of a subtlety about the interaction of the namespace and 9p switches, which we are still discussing: the -namespace value can override the -9p switch.</p>
<p>If you set -9p=false but have a non-empty namespace variable, then 9p will be set to true. So in this example, the -9p switch has no effect:</p>
<pre><code class="language-bash">cpu -9p=false h ls
</code></pre>
<p>Why is this? Because the default value of -namespace is non-empty. The open question: should -9p=false force the namespace to be empty; or should a none-empty namespace for -9p to be true? For now, we have chosen the latter approach.</p>
<p>Another possible approach is to log conflicting settings of these two switches and exit:</p>
<pre><code class="language-bash">cpu -9p=false h ls
error: 9p is false but the namespace is non-empty; to force an empty namespace use -namespace=""
</code></pre>
<p>We welcome comments on this issue.</p>
<h4 id="cpu-and-docker"><a class="header" href="#cpu-and-docker">cpu and Docker</a></h4>
<p>Maintaining file system images is inconvenient. We can use Docker containers on remote hosts instead. We can take a standard Docker container and, with suitable options, use docker to start the container with <code>cpu</code> as the first program it runs.</p>
<p>That means we can use any Docker image, on any architecture, at any time; and we can even run more than one at a time, since the namespaces are private.</p>
<p>In this example, we are starting a standard Ubuntu image:</p>
<pre><code class="language-bash">$ docker run -v /home/rminnich:/home/rminnich -v /home/rminnich/.ssh:/root/.ssh -v /etc/hosts:/etc/hosts --entrypoint /home/rminnich/go/bin/cpu -it ubuntu@sha256:073e060cec31fed4a86fcd45ad6f80b1f135109ac2c0b57272f01909c9626486 h
Unable to find image 'ubuntu@sha256:073e060cec31fed4a86fcd45ad6f80b1f135109ac2c0b57272f01909c9626486' locally
docker.io/library/ubuntu@sha256:073e060cec31fed4a86fcd45ad6f80b1f135109ac2c0b57272f01909c9626486: Pulling from library/ubuntu
a9ca93140713: Pull complete
Digest: sha256:073e060cec31fed4a86fcd45ad6f80b1f135109ac2c0b57272f01909c9626486
Status: Downloaded newer image for ubuntu@sha256:073e060cec31fed4a86fcd45ad6f80b1f135109ac2c0b57272f01909c9626486
WARNING: The requested image's platform (linux/arm64/v8) does not match the detected host platform (linux/amd64) and no specific platform was requested
1970/01/01 21:37:32 CPUD:Warning: mounting /tmp/cpu/lib64 on /lib64 failed: no such file or directory
$ ls
bbin  buildbin  env  go    init     lib    proc  tcz  ubin  var
bin   dev       etc  home  key.pub  lib64  sys   tmp  usr
</code></pre>
<p>Note that the image was update and then started. The <code>/lib64</code> mount fails, because there is no <code>/lib64</code> directory in the image, but that is harmless.</p>
<p>On the local host, on which we ran docker, this image will show up in docker <code>ps</code>:</p>
<pre><code class="language-bash">rminnich@a300:~$ docker ps
CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS     NAMES
b92a3576229b   ubuntu    "/home/rminnich/go/b…"   9 seconds ago   Up 9 seconds             inspiring_mcnulty
</code></pre>
<p>Even though the binaries themselves are running on the remote ARM system.</p>
<h4 id="cpu-and-virtiofs"><a class="header" href="#cpu-and-virtiofs">cpu and virtiofs</a></h4>
<p>While 9p is very general, because it is <em>transport-independent</em>, there are cases where we can get much better performance by using a less general file system. One such case is with virtofs.</p>
<p>Because virtiofs is purely from guest kernel vfs to host kernel vfs, via virtio transport, it has been measured to run at up to 100 times faster.</p>
<p>We can use virtiofs by specifying virtiofs mounts. cpud will look for an environemnt variable, <code>CPU_FSTAB</code>, which is in <code>fstab(5)</code> format. The client can specify an fstab in one of two ways. Either via the <code>-fstab</code> switch, in which case the client will populate the <code>CPU_FSTAB</code> variable with the contents of the file or by passing the <code>CPU_FSTAB</code> environment variable, which happens by default.</p>
<p>On the client side, the file specified via the -fstab takes precedence over any value of the CPU_FSTAB environment variable. On the server side, cpud does not use the -fstab switch, only using the environment variable.</p>
<p>Here is an example of using the CPU_FSTAB variable with one entry:</p>
<pre><code class="language-txt">CPU_FSTAB="myfs /mnt virtiofs rw 0 0" cpu v
</code></pre>
<p>In this case, the virtiofs server had the name myfs, and on the remote side, virtiofs was mounted on /mnt.</p>
<p>For the fstab case, the command looks like this:</p>
<pre><code class="language-bash">cpu -fstab fstab v
</code></pre>
<p>The fstab in this case would be</p>
<pre><code class="language-bash">myfs /mnt virtiofs rw 0 0
</code></pre>
<p>Note that both the environment variable and the fstab can have more than one entry, but they entries must be separate by newlines. Hence, this will not work:</p>
<pre><code class="language-txt">CPU_FSTAB=`cat fstab` cpu v
</code></pre>
<p>as shells insist on converting newlines to spaces.</p>
<p>The fstab can specify any file system. If there is a mount path to, e.g., Google drive, and it can be specified in fstab format, then cpu clients can use Google Drive files. Note, again, that these alternative mounts do not use the 9p server built in to the cpu client; they use the file systems provided on the cpu server machine.</p>
<p>There are thus several choices for setting up the mounts</p>
<ul>
<li>9p support by the cpu client</li>
<li>9p supported by the cpu client, with additional mounts via -fstab or -namespace</li>
<li>9p <em>without</em> any bind mounts, i.e. -9p=false -namespace "", in which case, on the remote machine, files from the client are visible in /tmp/cpu, but no bind mounts are done; with additional mounts provided by fstab mounts are provided</li>
<li>no 9p mounts at all, when -namespace="" -9p=false; with optional additional mounts via fstab</li>
<li>if there are no 9p mounts, and no fstab mounts, cpu is equivalent to ssh.</li>
</ul>
<hr>
<ol class="footnote-definition"><li id="footnote-1">
<p>For reference, the command we used: <code>cpu -dbg9p -d apu2 date</code> <a href="#fr-1-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="dut-a-simple-device-under-test-utility"><a class="header" href="#dut-a-simple-device-under-test-utility">DUT, a simple Device Under Test utility.</a></h1>
<p>Points of contact: <a href="https://github.com/rminnich">Ron Minnich</a></p>
<p>DUT is a simple Device Under Test program that gives you control of a node. It is intended to make very fast startup and control easy.</p>
<p>DUT is one program implementing three operations. The first, tester, is run on a test control system, such as your desktop; the second, called device, is run on the device; the third, called ssh and also run on the device, starts an ssh server assuming one is present.</p>
<p>DUT is intended to be very limited, with more sophisticated operations, should they be needed, being done over SSH.</p>
<p>DUT is found at github.com:linuxboot/dut.</p>
<p>This chapter describes how we build and use DUT.</p>
<h2 id="components"><a class="header" href="#components">Components</a></h2>
<p>DUT is intended to be built into a u-root image. First one must fetch it:</p>
<pre><code>go get github.com/linuxboot/dut
# ignore the warning message.
</code></pre>
<p>DUT source tree is structured such that a program called uinit is produced. This is convenient for u-root usage.</p>
<p>Building it into a u-root image is easy:</p>
<pre><code>go run $(GOPATH)/src/github.com/u-root/u-root -build=bb minimal github.com/linuxboot/dut/uinit
</code></pre>
<p>I almost always add an sshd to u-root; it's just too handy. U-root sshd does not support passwords, so you have to supply the public key:</p>
<pre><code>go run $(GOPATH)/src/github.com/u-root/u-root -build=bb -files key.pub minimal  github.com/linuxboot/dut/uinit   github.com/u-root/u-root/xcmds/sshd
</code></pre>
<h3 id="dut-on-the-device"><a class="header" href="#dut-on-the-device">DUT on the device</a></h3>
<p>On boot, the standard init program will find dut, and run it. The standard mode on a device is device mode, and dut will bring up the ethernet, currently using 192.168.0.2, and assuming the tester is 192.168.0.1 (this should be fixed ...). It will then attempt to connect to a uinit running in 'tester' mode on 192.168.0.1. Once connected, it functions as a server and waits for requests.</p>
<h3 id="dut-on-the-controller"><a class="header" href="#dut-on-the-controller">DUT on the controller</a></h3>
<p>Running on the controller is easy:</p>
<pre><code>uinit -m tester
</code></pre>
<p>On the controller, the program waits for a connection and then starts issuing commands to the device. The controller has the option of calling the following RPC functions:</p>
<pre><code>RPCWelcome - return a welcome message
RPCExit - exit the testing mode
RPCReboot - reboot the system
RPCKexec - kexec a kernel
RPCSsh - start the sshd
</code></pre>
<p>Each of these RPCs takes arguments and returns a result, with Welcome being the most fun:</p>
<pre><code>______________
&lt; welcome to DUT &gt;
  --------------
         \   ^__^
          \  (oo)\_______
             (__)\       )\/\
                 ||----w |
                 ||     ||
</code></pre>
<p>The current tester mode performs an RPC sequence I use for DXE cleaning, namely, a Welcome, followed by a Reboot, followed by a Welcome. This sequence verifies that I can get network going from power on, do a reboot, and reconnect after a reboot. It's been good for finding out if a particular DXE can be removed.</p>
<p>Once the second Welcome has happened, if an sshd is installed, it will have been started, and you can do additional commands.</p>
<h1 id="future-work"><a class="header" href="#future-work">Future work</a></h1>
<p>Obviously, much more can be done. But this is a useful foundation on which to build DUT environments.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="實作-linuxboot"><a class="header" href="#實作-linuxboot">實作 LinuxBoot</a></h1>
<p>The aim of LinuxBoot is to reduce complexity and obscure firmware by moving that functionality into kernel and user-space.</p>
<p>This chapter describes the procedures from a <a href="https://docs.google.com/presentation/d/1s9ka4v7leKeJa3116AQoNb9cv3OqmnW6pgn0ov9WiHo/edit?ts=5e2b227b#slide=id.g7ceec54197_4_163">LinuxBoot workshop</a> where an Atomic Pi board with UEFI firmware was converted to run LinuxBoot. The build materials associated with this are found at <a href="https://github.com/linuxboot/mainboards/tree/master/digitalloggers/atomicpi">digitalloggers/atomicpi</a>.</p>
<p>Read the below and consult the Makefile for the details of how it was implemented.</p>
<h2 id="a-quick-refresher-on-uefi"><a class="header" href="#a-quick-refresher-on-uefi">A quick refresher on UEFI</a></h2>
<p>UEFI has three sections:</p>
<ul>
<li>SEC ("Boot")</li>
<li>PEI ("Very early chip setup and DRAM programming")</li>
<li>DXE ("DRAM code")</li>
</ul>
<p>DXE process is very complex; some systems have 750 DXEs.</p>
<p>LinuxBoot replaces most of the UEFI software with Linux. LinuxBoot has an initramfs provided by <a href="./u-root.html">u-root</a>.</p>
<p>The above are stored inside a flash filesystem (FFS) inside a region of flash on your motherboard (the BIOS region). Another important region of flash is the ME region.</p>
<p>The Management Engine (ME) is an x86 CPU embedded in the Intel Platform Controller Hub (PCH). It runs the Minix operating system which boots first and enables hardware such as clocks and GPIOs. ME checks the contents of flash memory and is used to implement "BootGuard". If you reflash and the ME is in "BootGuard" mode, your machine will be unusable. You need to run a tool called <code>me_cleaner</code> on the image to disable BootGuard.</p>
<h2 id="how-do-you-get-linuxboot-on-your-hardware"><a class="header" href="#how-do-you-get-linuxboot-on-your-hardware">How do you get LinuxBoot on your hardware</a></h2>
<p>Start with a board running standard UEFI and proceed from "zero changes to FLASH" to "max changes" in 4 steps:</p>
<ul>
<li>Boot from USB stick via UEFI shell command <em>or</em> netboot (zero changes)</li>
<li>Find a way to read flash and write flash</li>
<li>Understand the flash layout</li>
<li>Prepare linux kernel and initrd/initramfs payload.</li>
<li>Replace UEFI Shell code section with Linux kernel and associated initrd (change part of one thing)</li>
<li>Remove as many DXEs as possible (change by removal). This change:
<ul>
<li>Speeds boot</li>
<li>Reduces panic possibilities</li>
<li>Removes exploits</li>
<li>In production, it has solved problems</li>
</ul>
</li>
<li>Clear ME region for initrd storage</li>
<li>Replace some DXEs with open source components (change by replacement)</li>
</ul>
<p>One of the challenges in the above is in finding (or reclaiming) enough space in flash to shoehorn your kernel and initrd into.</p>
<h2 id="tools-of-the-trade"><a class="header" href="#tools-of-the-trade">Tools of the trade</a></h2>
<p>There are two tools you use when you modify the UEFI flash image: <code>utk</code> and <code>me_cleaner</code>.</p>
<p>The ME Cleaner tool:</p>
<p><code>/usr/bin/python2 me_cleaner.py -s</code> <em>imagefile.bin</em></p>
<p><code>me_cleaner</code> sets the high assurance platform (HAP) bit. HAP provides a way to disable a feature on Intel chips that does not allow us to modify the UEFI image and install LinuxBoot. Setting the bit with <code>me_cleaner</code> disables the "feature".  Note that this does not always work; check with the LinuxBoot community.</p>
<p>When you run <code>me_cleaner</code>:</p>
<pre><code>~/projects/linuxboot/me_cleaner/me_cleaner.py -s /tmp/rom.bin
</code></pre>
<p>you should see output similar to the following:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left"></th></tr></thead><tbody>
<tr><td style="text-align: left"><code>Full image detected</code></td></tr>
<tr><td style="text-align: left"><code>Found FPT header at 0x1010</code></td></tr>
<tr><td style="text-align: left"><code>Found 20 partition(s)</code></td></tr>
<tr><td style="text-align: left"><code>Found FTPR header: FTPR partition spans from 0x6f000 to 0xe700</code></td></tr>
<tr><td style="text-align: left"><code>ME/TXE firmware version 2.0.5.3112 (generation 2)</code></td></tr>
<tr><td style="text-align: left"><code>Public key match: Intel TXE, firmware versions 2.x.x.x</code></td></tr>
<tr><td style="text-align: left"><code>The AltMeDisable bit is SET</code></td></tr>
<tr><td style="text-align: left"><code>Setting the AltMeDisable bit in PCHSTRP10 to disable Intel ME…</code></td></tr>
<tr><td style="text-align: left"><code>Checking the FTPR RSA signature... VALID</code></td></tr>
<tr><td style="text-align: left"><code>Done! Good luck!</code></td></tr>
</tbody></table>
</div>
<p>By applying <code>me_cleaner</code>, it has been observed that almost 4M of flash ram can be reclaimed for use. That 4M is enough to store a reasonably full featured compressed initrd image.</p>
<p>The <code>utk</code> tool can:</p>
<ul>
<li>Remove DXEs</li>
<li>Insert new DXEs</li>
<li>Replace the binary code of a DXE with a kernel</li>
<li>Reallocate space from the ME region to the BIOS region ("tighten")</li>
</ul>
<h2 id="linuxboot-implementation-steps"><a class="header" href="#linuxboot-implementation-steps">LinuxBoot Implementation steps</a></h2>
<h3 id="step-1-boot-linux-via-netboot--uefi-shell"><a class="header" href="#step-1-boot-linux-via-netboot--uefi-shell">Step 1: boot Linux via netboot / UEFI shell</a></h3>
<ul>
<li>netboot: standard BIOS-based PXE boot
<ul>
<li>Netboot is probably the most common working boot method on UEFI</li>
<li>We have never seen a system that did not have a net boot</li>
</ul>
</li>
<li>UEFI Shell (mentioned only for completeness)
<ul>
<li>Install Linux on FAT-32 media with a name of your choice (e.g. "kernel")
<ul>
<li>FAT-32, also known as MS-DOS file system</li>
</ul>
</li>
<li>Boot kernel at UEFI Shell prompt</li>
<li>We've run into a few systems that don't have a UEFI shell</li>
</ul>
</li>
</ul>
<h4 id="working-with-a-system-that-only-has-a-net-interface"><a class="header" href="#working-with-a-system-that-only-has-a-net-interface">Working with a system that only has a net interface</a></h4>
<p>If the system only has a net interface, you use Dynamic Host Configuration Protocol (DHCP), using broadcast DISCOVER, and Trivial File Transfer Protocol (TFTP) to get the boot information you need.</p>
<p>Configuration information is provided by REPLY to a DHCP request. The REPLY returns an IP, server, and a configuration file name that provides:</p>
<ul>
<li>Identity</li>
<li>What to boot</li>
<li>Where to get it</li>
</ul>
<p>Data is provided by TFTP. HTTP downloading takes a fraction of a second even for 16M kernels. With TFTP it's very slow and TFTP won't work with initramfs much large than 32MiB. Most LinuxBoot shops use or are transitioning to HTTP.</p>
<p>Note: Boot images require a kernel(bzImage) + an initramfs + a command line. They can be loaded as three pieces or compiled and loaded as one piece, as described in this section.</p>
<h3 id="step-2-read--write-the-flash"><a class="header" href="#step-2-read--write-the-flash">Step 2: read &amp; write the flash</a></h3>
<p>There are two main ways to read and write the flash - hardware and software.</p>
<p>Hardware: It is worth buying a Pomona 5250 SOIC Clip adapter to read directly by hardware to have something to roll back to if anything goes wrong. Avoid cheap SOIC clip adapters that don't allow you to use standard jumper leads. For a good example of using a Raspberry Pi 3/4 to read/write, see <a href="https://wiki.gentoo.org/wiki/Sakaki%27s_EFI_Install_Guide/Disabling_the_Intel_Management_Engine#imt_check">Sakaki's EFI Install Guide/Disabling the Intel Management Engine</a></p>
<p>Software: With a working boot image, use flashrom to read an image of your flash. To write you may need to disable flash protections (look for "ME Manufacturing mode" jumpers on your motherboard). Figure on generally using software methods for reading &amp; writing flash, but with hardware to drop back to.</p>
<h3 id="step-3-familiarise-yourself-with-the-flash-layout-and-identify-free-space"><a class="header" href="#step-3-familiarise-yourself-with-the-flash-layout-and-identify-free-space">Step 3: Familiarise yourself with the flash layout and identify free space</a></h3>
<p>Open your flash image with UEFITool, and locate the filesystem containing the DXE's (it will have the Shell or <code>Shell_Full</code> in it ). Check how much volume free space is in that filesystem - this will be an initial limit when you come to place your kernel and initramfs in it in step 5.</p>
<h3 id="step-4-prepare-linuxu-root-payload"><a class="header" href="#step-4-prepare-linuxu-root-payload">Step 4: Prepare linux/u-root payload</a></h3>
<p>Start small and work your way up.</p>
<ul>
<li>Use the tiny.config to configure your first kernel, and embed a small initramfs in-kernel (the u-root cpu payload is an excellent starting point).</li>
<li>One can have a full kernel/initramfs in around 2M of flash.</li>
<li>A more full featured kernel might consume 2M and a u-root bb distribution 4M, which may well exceed the volume free space.</li>
<li>When there isn't enough space in this filesystem, one can either start removing unused DXE's (step 6), or use space formerly used by the ME Region (step 7).</li>
</ul>
<h3 id="step-5-replace-shell-binary-section"><a class="header" href="#step-5-replace-shell-binary-section">Step 5: replace Shell binary section</a></h3>
<ul>
<li>UEFI Shell is a DXE
<ul>
<li>DXEs are Portable Executable 32-bit binaries (PE32)</li>
<li>They have multiple sections, one of them being binary code</li>
<li>You need a flash image (in this case called <em>firmware.bin</em>). You can get it via vendor website, flashrom, or other mechanism.</li>
</ul>
</li>
<li>The following <code>utk</code> command replaces the Shell code section with a Linux kernel:
<ul>
<li><code>utk firmware.bin replace_pe32 Shell bzImage save</code> <em>new.bin</em></li>
<li>Note: It's always a PE32, even for 64-bit kernels. <em>new.bin</em> is a filename of your choosing.</li>
</ul>
</li>
<li>After running <code>utk</code>, you can reflash</li>
</ul>
<h3 id="step-6a-remove-as-many-dxes-as-possible"><a class="header" href="#step-6a-remove-as-many-dxes-as-possible">Step 6a: remove as many DXEs as possible</a></h3>
<ul>
<li>You can do an initial mass removal based on your current knowledge</li>
<li><code>utk</code> automates removing DXEs: this is the DXE cleaner
<ul>
<li><code>utk</code> removes a DXE, reflashes, checks if it boots, repeat This part should be easy: DXE can have a dependency section. In practice, it's hard: because dependency sections are full of errors and omissions. A lot of UEFI code does not check for failed DXE loads.</li>
</ul>
</li>
</ul>
<h3 id="step-6b-place-your-initramfs-in-me_cleaned-region"><a class="header" href="#step-6b-place-your-initramfs-in-me_cleaned-region">Step 6b: place your initramfs in me_cleaned region</a></h3>
<ul>
<li>Run <code>me_cleaner</code> and then utk tighten on the source image, then inspect the image using UEFITool. If successful, there will now be padding at the beginning of the BIOS region of a substantial size.</li>
<li>This padding space can be used, without the filesystem's knowledge, to stash an initramfs. The kernel is informed of the location this initramfs as an initrd kernel parameter.
<ul>
<li>Use the base address of this padding region to calculate the offset in the flash image where the initrd is stashed using dd.</li>
<li>Use the address (not base address) as the initramfs location in memory to pass as a kernel parameter.</li>
</ul>
</li>
</ul>
<h3 id="step-7-replace-closed-source-with-open-source"><a class="header" href="#step-7-replace-closed-source-with-open-source">Step 7: replace closed-source with open source</a></h3>
<ul>
<li>If you can build a DXE from source, you can use <code>utk</code> to remove the proprietary one and replace it with one built from source. You can get DXE source from the tianocore/EDK2 source repo at github.com. The GitHub repo has a <strong><em>limited</em></strong> number of DXEs in source form; i.e., you can't build a full working image using it.</li>
<li>There are scripts that let you compile individual DXEs, including the UEFI Shell and Boot Device Selection (BDS). These two DXEs have been compiled and are used in the Atomic Pi. Source-based BDS was needed to ensure the UEFI Shell was called.</li>
<li>You only need the UEFI Shell built long enough to replace it with Linux.</li>
</ul>
<h3 id="final-step-reflash-the-image"><a class="header" href="#final-step-reflash-the-image">Final step: reflash the image</a></h3>
<ul>
<li>"Native" reflash: Boot the system whatever way is easiest: netboot, usb, local disk, and run <code>flashrom -p internal -w _filename.bin_</code> where <em>filename.bin</em> is a filename of your choosing.</li>
<li>Run <code>flashrom</code> with an external device such as an sf100. There may be a header on the board, or you might have to use a clip. <code>flashrom -p dediprog:voltage=1.8 -w _filename.bin_</code></li>
</ul>
<p>The voltage option is required for the Atomic Pi.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用-corebootu-root-和-systemboot-的-linuxboot"><a class="header" href="#使用-corebootu-root-和-systemboot-的-linuxboot">使用 coreboot、u-root 和 systemboot 的 LinuxBoot</a></h1>
<p>Points of contact: <a href="https://github.com/insomniacslk">Andrea Barberio</a>, <a href="https://github.com/dhendrix">David Hendricks</a></p>
<p>This chapter describes how to build a LinuxBoot firmware based on coreboot, u-root and systemboot.  The examples will focus on <code>x86_64</code>, and the coreboot builds will cover virtual and physical OCP hardware.</p>
<h2 id="quick-start-with-coreboot"><a class="header" href="#quick-start-with-coreboot">Quick Start with coreboot</a></h2>
<p>Run these commands in a directory you create or in <code>/tmp</code>; do so because it creates some files and directories:</p>
<pre><code>$ go get github.com/linuxboot/corebootnerf
$ go run github.com/linuxboot/corebootnerf --fetch
... lots and lots of output!
</code></pre>
<p>This produces a coreboot image in coreboot-4.9/build/coreboot.rom You can now run this ROM image:</p>
<pre><code>qemu-system-x86_64 -serial stdio -bios coreboot-4.9/build/coreboot.rom
</code></pre>
<p>And see how it looks when you put this in a coreboot ROM image.</p>
<h2 id="components-1"><a class="header" href="#components-1">Components</a></h2>
<p>The final image is built on top of multiple open-source components:</p>
<ul>
<li><a href="https://coreboot.org">coreboot</a>, used for the platform initialization. Silicon and DRAM initialization are done here.</li>
<li><a href="https://kernel.org">Linux</a>, used to initialize peripherals and various device drivers like file systems, storage and network devices; network stack; a multiuser and multitasking environment.</li>
<li><a href="https://github.com/u-root/u-root">u-root</a>, an user-space environment that provides basic libraries and utilities to work in a Linux environment.</li>
<li><del><a href="https://systemboot.org">systemboot</a>, an additional set of libraries and tools on top of u-root, that provide a bootloader behaviour for various booting scenarios.</del> systemboot was merged into u-root.</li>
</ul>
<p>These components are built in reverse order. <code>u-root</code> and <code>systemboot</code> are built together in a single step.</p>
<h2 id="building-u-root"><a class="header" href="#building-u-root">Building u-root</a></h2>
<p>The first step is building the initramfs. This is done using the <code>u-root</code> ramfs builder, with additional tools and libraries from <code>systemboot</code>.</p>
<p>u-root is written in Go. We recommend using a relatively recent version of the Go toolchain. At the time of writing the latest is 1.11, and we recommend using at least version 1.10. Previous versions may not be fully supported.</p>
<p>Adjust your <code>PATH</code> to include <code>${GOPATH}/bin</code>, in order to find the <code>u-root</code> command that we will use in the next steps.</p>
<p>Then, fetch <code>u-root</code> and its dependencies:</p>
<pre><code>go get -u github.com/u-root/u-root
</code></pre>
<p>Then build the ramfs in busybox mode, and add fbnetboot, localboot, and a custom uinit to wrap everything together:</p>
<pre><code>u-root -build=bb core github.com/u-root/u-root/cmds/boot/{uinit,localboot,fbnetboot}
</code></pre>
<p>This command will generate a ramfs named <code>/tmp/initramfs_${os}_${arch}.cpio</code>, e.g. <code>/tmp/initramfs.linux_amd64.cpio</code>. You can specify an alternative output path with <code>-o</code>. Run <code>u-root -h</code> for additional command line parameters.</p>
<p>Note: the above command will include only pure-Go commands from <code>u-root</code>. If you need to include other files or non-Go binaries, use the <code>-file</code> option in <code>u-root</code>.  For example, you may want to include static builds of <code>kexec</code> or <code>flashrom</code>, that we build on https://github.com/systemboot/binaries .</p>
<p>Then, the initramfs has to be compressed. This step is necessary to embed the initramfs in the kernel as explained below, in order to maintain the image size smaller. Linux has a limited XZ compressor, so the compression requires specific options:</p>
<pre><code>xz --check=crc32 --lzma2=dict=512KiB /tmp/initramfs.linux_amd64.cpio
</code></pre>
<p>which will produce the file <code>/tmp/initramfs.linux_amd64.cpio.xz</code>.</p>
<p>The kernel compression requirements are documented under <a href="https://www.kernel.org/doc/Documentation/xz.txt">Documentation/xz.txt</a> (last checked 2018-12-03) in the kernel docs.</p>
<h2 id="building-a-suitable-linux-kernel"><a class="header" href="#building-a-suitable-linux-kernel">Building a suitable Linux kernel</a></h2>
<p>A sample config to use with QEMU can be downloaded here: <a href="coreboot.u-root.systemboot/linux-4.19.6-linuxboot.config">linux-4.19.6-linuxboot.config</a>.</p>
<p>You need a relatively recent kernel. Ideally a kernel 4.16, to have support for VPD variables, but a 4.11 can do the job too, if you don't care about boot entries and want "brute-force" booting only.</p>
<p>We will build a kernel with the following properties:</p>
<ul>
<li>small enough to fit most flash chips, and with some fundamental kernel features</li>
<li>that can run Go programs (mainly futex and epoll support)</li>
<li>with the relevant storage and network stack and drivers</li>
<li>with kexec support, so it can boot a new kernel</li>
<li>with kexec signature verification disabled (optional)</li>
<li>with devtmpfs enabled, since we don't use udev</li>
<li>XZ support to decompress the embedded initramfs</li>
<li>VPD (Vital Product Data) (optional)</li>
<li>TPM support (optional)</li>
<li>embed the u-root initramfs</li>
<li>and last but not least, "linuxboot" as default host name :)</li>
</ul>
<h3 id="download-kernel-sources"><a class="header" href="#download-kernel-sources">Download kernel sources</a></h3>
<p>You can either download a tarball from kernel.org, or get it via git and use a version tag. We recommend at least a kernel 4.16, in order to have VPD variables support.</p>
<pre><code># download the kernel tarball. Replace 4.19.6` with whatever kernel version you want
wget https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.19.6.tar.xz
tar xvJf linux-4.19.6.tar.xz
cd linux-4.19.6
make tinyconfig
</code></pre>
<p>You can also check out the <code>linux-stable</code> branch, that will point to the latest stable commit. You need to download it via <code>git</code> as follows:</p>
<pre><code>git clone --depth 1 -b linux-stable
git://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git
cd linux-stable
make tinyconfig
</code></pre>
<p>Some more information about tiny configs can be found at https://tiny.wiki.kernel.org (last checked 2018-12-01).</p>
<h3 id="a-few-fundamental-features"><a class="header" href="#a-few-fundamental-features">A few fundamental features</a></h3>
<p>Assuming we are running on <code>x86_64</code>, some basic features to enable are:</p>
<ul>
<li><code>64-bit kernel</code></li>
<li><code>General setup</code> → <code>Configure standard kernel features</code> → <code>Enable support for printk</code></li>
<li><code>General setup</code> → <code>Configure standard kernel features</code> → <code>Multiple users, groups and capabilities support</code> (this is not strictly required on LinuxBoot)</li>
<li><code>Processor type and features</code> → <code>Built-in kernel command line</code> (customize your command line here if needed, e.g. <code>earlyprintk=serial,ttyS0,57600 console=ttyS0,57600</code>)</li>
<li><code>Executable file formats / Emulations</code> → <code>Kernel support for ELF binaries</code> (you may want to enable more formats)</li>
<li><code>Networking support</code> → <code>Networking options</code> → <code>TCP/IP networking</code></li>
<li><code>Networking support</code> → <code>Networking options</code> → <code>The IPv6 protocol</code></li>
<li><code>Device Drivers</code> → <code>Character devices</code> → <code>Enable TTY</code></li>
<li><code>Device Drivers</code> → <code>Character devices</code> → <code>Serial drivers</code> → <code>8250/16550 and compatible serial support</code></li>
<li><code>Device Drivers</code> → <code>Character devices</code> → <code>Serial drivers</code> → <code>Console on 8250/16550 and compatible serial port</code></li>
<li><code>File systems</code> → <code>Pseudo filesystems</code> → <code>/proc file system support</code></li>
<li><code>File systems</code> → <code>Pseudo filesystems</code> → <code>sysfs file system support</code></li>
</ul>
<h3 id="requirements-for-go-111"><a class="header" href="#requirements-for-go-111">Requirements for Go 1.11</a></h3>
<p><code>Go</code> requires a few kernel features to work properly. At the time of writing, you need to enable <code>CONFIG_FUTEX</code> in your kernel config. Older versions of Go may require <code>CONFIG_EPOLL</code>.</p>
<p>In menuconfig:</p>
<ul>
<li><code>General setup</code> → <code>Configure standard kernel features (expert users)</code> → <code>Enable futex support</code></li>
<li><code>General setup</code> → <code>Configure standard kernel features (expert users)</code> → <code>Enable eventpoll support</code></li>
</ul>
<p>Additional information about Go's minimum requirements can be found at https://github.com/golang/go/wiki/MinimumRequirements (last checked 2018-12-01).</p>
<h3 id="enable-devtmpfs"><a class="header" href="#enable-devtmpfs">Enable devtmpfs</a></h3>
<p>Our system firmware uses u-root, which does not have (intentionally) an <code>udev</code> equivalent. Therefore, to have <code>/dev/</code> automatically populated at boot time you should enable devtmps.</p>
<p>Simply enable <code>CONFIG_DEVTMPFS</code> and <code>CONFIG_DEVTMPFS_MOUNT</code> in your kernel config.</p>
<p>In menuconfig:</p>
<ul>
<li><code>Device drivers</code> → <code>Generic Driver Options</code> → <code>Maintain a devtmpfs filesystem to mount at /dev</code></li>
<li><code>Device drivers</code> → <code>Generic Driver Options</code> → <code>Automount devtmpfs at /dev, after the kernel mounted the rootfs</code></li>
</ul>
<h3 id="additional-drivers"><a class="header" href="#additional-drivers">Additional drivers</a></h3>
<p>This really depends on your hardware. You may want to add all the relevant drivers for the platforms you plan to run LinuxBoot on. For example you may need to include NIC drivers, file system drivers, and any other device that you need at boot time.</p>
<p>For example, enable SCSI disk, SATA drivers, EXT4, and e1000 NIC driver. In menuconfig:</p>
<ul>
<li><code>Bus options</code> → <code>PCI support</code></li>
<li><code>Enable the block layer</code></li>
<li><code>Device drivers</code> → <code>Block devices</code> (required for SCSI and SATA)</li>
<li><code>Device drivers</code> → <code>SCSI device support</code> → <code>SCSI disk support</code></li>
<li><code>Device drivers</code> → <code>Serial ATA and Parallel ATA drivers</code></li>
<li><code>File systems</code> → <code>The Extended 4 (ext4) filesystem</code></li>
<li><code>Networking support</code> (required for e1000)</li>
<li><code>Device drivers</code> → <code>Network device support</code> → <code>Ethernet driver support</code> → <code>Intel(R) PRO/1000 Gigabit Ethernet support</code></li>
</ul>
<h3 id="enable-xz-kernel-and-initramfs-compression-support"><a class="header" href="#enable-xz-kernel-and-initramfs-compression-support">Enable XZ kernel and initramfs compression support</a></h3>
<p>The <code>u-root</code>-based RAMFS will be compressed with XZ and embedded in the kernel. Hence you need to enable XZ compression support. Make sure to have at least <code>CONFIG_HAVE_KERNEL_XZ</code>, <code>CONFIG_KERNEL_XZ</code>, <code>CONFIG_DECOMPRESS_XZ</code>.</p>
<p>In menuconfig:</p>
<ul>
<li><code>General setup</code> → <code>Kernel compression mode</code> → <code>XZ</code></li>
<li><code>General setup</code> → <code>Initial RAM filesystem and RAM disk (initramfs/initrd) support</code> → <code>Support initial ramdisk/ramfs compressed using XZ</code></li>
</ul>
<h3 id="enable-vpd"><a class="header" href="#enable-vpd">Enable VPD</a></h3>
<p>VPD stands for <a href="https://chromium.googlesource.com/chromiumos/platform/vpd/+/1c1806d8df4bb5976eed71a2e2bf156c36ccdce2/README.md">Vital Product Data</a>. We use VPD to store boot configuration for <code>localboot</code> and <code>fbnetboot</code>, similarly to UEFI's boot variables. Linux supports VPD out of the box, but you need at least a kernel 4.16.</p>
<p>Make sure to have <code>CONFIG_GOOGLE_VPD</code> enabled in your kernel config.</p>
<p>In menuconfig:</p>
<ul>
<li><code>Firmware drivers</code> → <code>Google Firmware Drivers</code> → <code>Coreboot Table Access - ACPI</code> → <code>Vital Product Data</code></li>
</ul>
<h3 id="tpm-support"><a class="header" href="#tpm-support">TPM support</a></h3>
<p>This also depends on your needs. If you plan to use TPM, and this is supported by your platform, make sure to enable <code>CONFIG_TCG_TPM</code>.</p>
<p>In menuconfig:</p>
<ul>
<li><code>Device drivers</code> → <code>Character devices</code> → <code>TPM Hardware Support</code> → (enable the relevant drivers)</li>
</ul>
<h3 id="include-the-initramfs"><a class="header" href="#include-the-initramfs">Include the initramfs</a></h3>
<p>As mentioned above, the kernel will embed the compressed initramfs image. Your kernel configuration should point to the appropriate file using the <code>CONFIG_INITRAMFS_SOURCE</code> directive. E.g.</p>
<pre><code>CONFIG_INITRAMFS_SOURCE="/path/to/initramfs_linux.x86_64.cpio.xz"
</code></pre>
<p>In menuconfig:</p>
<ul>
<li><code>General setup</code> → <code>Initial RAM filesystem and RAM disk (initramfs/initrd) support</code> → <code>Initramfs source file(s)</code></li>
</ul>
<h3 id="default-hostname"><a class="header" href="#default-hostname">Default hostname</a></h3>
<p>We use "linuxboot" as the default hostname. You may want to adjust it to a different value. You need to set <code>CONFIG_DEFAULT_HOSTNAME</code> for the purpose. For example:</p>
<pre><code>CONFIG_DEFAULT_HOSTNAME="linuxboot"
</code></pre>
<p>In menuconfig:</p>
<ul>
<li><code>General setup</code> → <code>Default hostname</code></li>
</ul>
<h3 id="build-the-kernel"><a class="header" href="#build-the-kernel">Build the kernel</a></h3>
<p>Once your configuration is ready, build the kernel as usual:</p>
<pre><code>make -j$(nproc --ignore=1)
</code></pre>
<p>The image will be located under <code>arch/${ARCH}/boot/bzImage</code> if your architecture supports bzImage (e.g. x86).</p>
<p>For more details on how to build a kernel, see https://kernelnewbies.org/KernelBuild (last checked 2018-12-01).</p>
<h2 id="building-coreboot"><a class="header" href="#building-coreboot">Building coreboot</a></h2>
<p>In this step we will build <code>coreboot</code> using the Linux kernel image that we built at the previous step as payload. This build is for a Qemu x86 target, the process may be somehow different for other platforms.</p>
<p>Steps overview:</p>
<ul>
<li>download coreboot from the git repo</li>
<li>build the compiler toolchain</li>
<li>configure coreboot for Qemu, and to use our <code>bzImage</code> as payload</li>
<li>build <code>coreboot.rom</code></li>
</ul>
<h3 id="download-coreboot"><a class="header" href="#download-coreboot">Download coreboot</a></h3>
<p>Our preferred method is to download coreboot from the git repository:</p>
<pre><code>git clone https://review.coreboot.org/coreboot.git
cd coreboot
</code></pre>
<h3 id="build-the-compiler-toolchain"><a class="header" href="#build-the-compiler-toolchain">Build the compiler toolchain</a></h3>
<p>This step is required to have, among other things, reproducible builds, and a compiler toolchain that is known to work with coreboot.</p>
<pre><code>make crossgcc-i386 CPUS=$(nproc) BUILD_LANGUAGES=c
</code></pre>
<p>The step above may ask you to install a few additional libraries or headers, do so as requested, with the exception of gcc-gnat, that we won't need.</p>
<h3 id="configure-coreboot-for-qemu-and-our-payload"><a class="header" href="#configure-coreboot-for-qemu-and-our-payload">Configure coreboot for Qemu and our payload</a></h3>
<p>Run <code>make menuconfig</code> to enter the coreboot configuration menus. Then:</p>
<p>Specify the platform we will run on:</p>
<ul>
<li><code>Mainboard</code> → <code>Mainboard vendor</code> → <code>Emulation</code></li>
<li><code>Mainboard</code> → <code>Mainboard Model</code> → <code>QEMU x86 q35/ich9 (aka qemu -M q35, since v1.4)</code></li>
</ul>
<p>Specify a large enough flash chip and CBFS size:</p>
<ul>
<li><code>Mainboard</code> → <code>ROM chip size</code> → <code>16 MB</code></li>
<li><code>Mainboard</code> → <code>Size of CBFS filesystem in ROM</code> → <code>0x1000000</code></li>
</ul>
<p>Specify our payload:</p>
<ul>
<li><code>Payload</code> → <code>Add a payload</code> → <code>A Linux payload</code></li>
<li><code>Payload</code> → <code>Linux path and filename</code> → path to your bzImage</li>
</ul>
<p>Then save your configuration and exit menuconfig.</p>
<h3 id="build-coreboot"><a class="header" href="#build-coreboot">Build coreboot</a></h3>
<p>This is done with a simple</p>
<pre><code>make -j$(nproc)
</code></pre>
<p>The coreboot build system will clone the relevant submodules, if it was not done already, and will build a coreboot ROM file that will contain the initialization code, and our bzImage payload. The output file is at <code>build/coreboot.rom</code>.</p>
<p>If everything works correctly you will get an output similar to the following:</p>
<pre><code>This image contains the following sections that can be manipulated with this tool:

'COREBOOT' (CBFS, size 16776704, offset 512)

It is possible to perform either the write action or the CBFS add/remove actions on every section listed above.
To see the image's read-only sections as well, rerun with the -w option.
    CBFSPRINT  coreboot.rom

FMAP REGION: COREBOOT
Name                           Offset     Type           Size   Comp
cbfs master header             0x0        cbfs header        32 none
fallback/romstage              0x80       stage           15300 none
fallback/ramstage              0x3cc0     stage           51805 none
config                         0x10780    raw               155 none
revision                       0x10880    raw               576 none
cmos_layout.bin                0x10b00    cmos_layout       548 none
fallback/dsdt.aml              0x10d80    raw              6952 none
fallback/payload               0x12900    simple elf    5883908 none
(empty)                        0x5af140   null         10800216 none
bootblock                      0xffbdc0   bootblock       16384 none

Built emulation/qemu-q35 (QEMU x86 q35/ich9)
</code></pre>
<h2 id="putting-everything-together"><a class="header" href="#putting-everything-together">Putting everything together</a></h2>
<p>TODO</p>
<h2 id="defining-boot-entries"><a class="header" href="#defining-boot-entries">Defining boot entries</a></h2>
<p>TODO</p>
<h2 id="running-on-a-virtual-machine"><a class="header" href="#running-on-a-virtual-machine">Running on a virtual machine</a></h2>
<p>The image built with the above steps can run on a QEMU virtual machine, using the machine type <code>q35</code>, as specified in the coreboot mainboard section. Assuming that your coreboot image is located at <code>build/coreboot.rom</code>, you can run the following command:</p>
<pre><code>sudo qemu-system-x86_64\        # sudo is required to enable KVM below
    -M q35 \                    # the machine type specified in the coreboot mainboard configuration
    -enable-kvm \               # use KVM to avail of hardware virtualization extensions
    -bios build/coreboot.rom \  # the coreboot ROM to run as system firmware
    -m 1024 \                   # the amount of RAM in MB
    -object rng-random,filename=/dev/urandom,id=rng0 \
                                # RNG to avoid DHCP lockups when waiting for entropy
    -nographic                  # redirect all the output to the console
</code></pre>
<p>If everything has been done correctly you should see, in order, the output from <code>coreboot</code>, <code>linux</code>, <code>u-root</code>, and <code>systemboot</code>. You can press <code>ctrl-c</code> when Systemboot instructs you to do so, to enter the <code>u-root</code> shell.</p>
<h2 id="running-on-real-ocp-hardware"><a class="header" href="#running-on-real-ocp-hardware">Running on real OCP hardware</a></h2>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="詞彙表"><a class="header" href="#詞彙表">詞彙表</a></h1>
<ul>
<li><em><strong>BIOS</strong></em>: Originally, BIOS was the software built into computers to send simple instructions to the hardware, allowing input and output before the operating system was loaded. It was a binary blob with no standardized structure that was responsible for initializing CPU and memory, and jumping to a hard-coded position on the master block of the first disk drive. BIOS has been largely replaced by UEFI. Many UEFI implementations still offer a "BIOS compatibility mode" which makes it behave like an old BIOS, with its features.</li>
<li><em><strong>busybox</strong></em>: Busybox is a single user-space binary which includes versions of a large number of system commands, including a shell. This package can be very useful for recovering from certain types of system failures, particularly those involving broken shared libraries. There are multiple implementations of busybox, such as git.busybox.net/busybox and github.com/u-root/u-root.</li>
<li><a href="https://doc.coreboot.org/"><em><strong>coreboot</strong></em></a>: A project to develop open source boot firmware for various architectures. Its design philosophy is to do the bare minimum necessary to ensure that hardware is usable and then pass control to a different program called the payload. The payload can then provide user interfaces, file system drivers, various policies etc. to load the OS.</li>
<li><em><strong>DHCP</strong></em>: A networking protocol that runs on a DHCP server and that automatically assigns an IP address from a pre-configured pool to any machine that queries it on boot up.</li>
<li><a href="https://github.com/tianocore/edk2"><em><strong>EDK II</strong></em></a>: An open source reference implementation of an UEFI-compliant firmware, originally developed by Intel</li>
<li><em><strong>firmware</strong></em>: A specific class of computer software that provides low-level control for a device's specific hardware. It is installed at the time of manufacturing and is the first program that runs when a computer is turned on. It checks to see what hardware components the computing device has, wakes the components up, and hands them over to the operating system that is to be installed on the machine. The current x86 firmware is based on Intel’s Universal Extensible Firmware Interface (UEFI).</li>
<li><em><strong>flashkernel</strong></em>: A small Linux kernel that is stored in flash and used as a boot stage (e.g. the kernel used in LinuxBoot). Debian and Ubuntu maintain a <code>flash-kernel</code> script to install the kernel and initramfs in a special location for embedded devices that can not boot the kernel and initramfs using the normal <code>/boot</code> mechanism</li>
<li><a href="https://github.com/linuxboot/heads"><em><strong>Heads</strong></em></a>: An open source firmware for laptops and servers, aimed at strong platform security. Developed by Trammell Hudson, based on stripped UEFI plus Linux, and BusyBox instead of u-root.</li>
<li><em><strong>iSCSI</strong></em>: A protocol that provides a way to make network-attached storage appear to be a local device to the hosts using it, allowing it to be (among other things) mounted as a regular local file system.</li>
<li><em><strong>kexec</strong></em>: A system call that enables you to load and boot into another kernel from the currently running kernel. kexec performs the function of the boot loader from within the kernel.</li>
<li><em><strong>LinuxBIOS</strong></em>: A project originated in 1999 from Ron Minnich, Stefan Reinauer and others. It was an experiment in the idea of running Linux as firmware. At that time Linux was not mature enough for a hardware initialization project, and while LinuxBIOS was successful in several performance-and-reliability critical environments, it didn't see mass adoption. It later became coreboot.</li>
<li><em><strong>LinuxBoot</strong></em>: LinuxBoot is not a product, but rather a concept. It's the idea of booting Linux (OS) with Linux (system firmware). In a way, the same concept pioneered by LinuxBIOS. It is like a Linux distribution, but for firmware. It is a collection of various open source components, combined to work as a consistent firmware OS.</li>
<li><em><strong>NERF</strong></em>: The original name for the LinuxBoot project composed of stripped UEFI plus Linux plus u-root. The name stands for Non-Extensible Reduced Firmware, as opposed to UEFI's Unified Extensible Firmware Interface. NERF is an UEFI replacement that is more compact and less extensible. While extensibility is nice and often desirable, too much extensibility can make a complex project very hard to maintain and keep secure.</li>
<li><em><strong>Open Source Firmware</strong></em>: OSF can be used to refer to Open Source Firmware or Open System Firmware depending on the context.</li>
<li><em><strong>Open System Firmware (OSF)</strong></em>: An official subproject of the Open Compute Project (OCP). OSF has been developed in the open, by various members of OCP that were interested in having open source system firmware. OSF defines a set of guidelines with contributions from Microsoft, Google, Facebook, Intel, 9elements, TwoSigma, and several other companies.</li>
<li><em><strong>OVMF</strong></em>: Open Virtual Machine Firmware. Open Virtual Machine Firmware is a build of EDK II for virtual machines. It includes full support for UEFI, including Secure Boot, allowing use of UEFI in place of a traditional BIOS in your EFI Initialization (PEI)|UEFI stage which runs before RAM is initialized, from cache and ROM. PEI is mostly C-code running in 32-bit protected flat mode.  The main goal of the PEI stage is to detect RAM. As soon as RAM is detected and configured, PEI stage give control to the DXE through DXE Initial Program Load (IPL) driver</li>
<li><em><strong>production kernel</strong></em>: LinuxBoot is not intended to be a runtime production kernel; rather, it is meant to replace specific UEFI functionality using Linux kernel capabilities and then boot the actual production kernel (prodkernel) on the machine. Kernel configuration files specific to LinuxBoot provide the needed Linux kernel capabilities without bloating the size of the BIOS with unnecessary drivers.</li>
<li><em><strong>PureBoot</strong></em>: A combination of disabling IME, coreboot, a TPM, Heads and the Librem Key (see <a href="https://tech.michaelaltfield.net/2023/02/16/evil-maid-heads-pureboot/#pureboot">Trusted Boot (Anti-Evil-Maid, Heads, and PureBoot)</a>)</li>
<li><em><strong>QEMU</strong></em>: An emulator that performs hardware virtualization. QEMU is a hosted virtual machine monitor.</li>
<li><em><strong>Secure Boot Preverifier (SEC)</strong></em>: In UEFI, the SEC stage initializes the CPU cache-as-RAM (CAR) and gives control to the PEI dispatcher. It is 99.9% assembly code (32-bit protected mode).</li>
<li><em><strong>u-boot</strong></em>: A very popular open source firmware and bootloader. Not to be confused with u-root.</li>
<li><em><strong>u-root</strong></em>: A modern, embedded user-space environment for Linux, with bootloader tools. See the section on u-root.</li>
<li><em><strong>UEFI</strong></em>: Unified Extensible Firmware Interface. It is Intel’s specification of a standard for system firmware. UEFI defines everything from the layout on the flash chip, to how to interface to peripherals, enables boot from disk or from a network, defines how UEFI applications work, etc). It is not an implementation, it's a standard. EDK II and OpenEDK II are UEFI implementations. UEFI is not closed source per-se, but in practice most implementations are.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="歷史"><a class="header" href="#歷史">歷史</a></h1>
<h2 id="bios-1"><a class="header" href="#bios-1">BIOS</a></h2>
<p><a href="https://en.wikipedia.org/wiki/BIOS">BIOS</a> is the good old, inscrutable way of initializing a hardware platform in the pre-UEFI days. It's a binary blob with no standardized structure, that is responsible for initializing CPU and memory, and jumping to a hard-coded position on the MBR of the first disk drive.</p>
<p>Starting around 2000, BIOS has been largely replaced by the standardized <a href="https://en.wikipedia.org/wiki/UEFI">UEFI</a>. Many UEFI implementations still offer a BIOS compatibility mode called CSM (Compatibility Support Module), which makes it behave like an old BIOS.</p>
<p>Note that the term "BIOS" is sometimes misused to refer to the general concept of <em>system firmware</em>, such as UEFI or even LinuxBoot. However, as "BIOS" refers to firmware with specific functionality, UEFI is definitely <em>not</em> a BIOS, nor is LinuxBoot a BIOS in the original sense.</p>
<h2 id="linuxbios"><a class="header" href="#linuxbios">LinuxBIOS</a></h2>
<p>The <a href="https://web.archive.org/web/20070430170020/http://www.linuxbios.org/Welcome_to_LinuxBIOS">LinuxBIOS</a> project was created in 1999 by Ron Minnich, Stefan Reinauer and others. It is not much younger than UEFI, but they were already experimenting the idea of running Linux as firmware. Like many great ideas, it was way ahead of its time. At that time Linux was not mature enough to be used in a hardware initialization project, and while LinuxBIOS was successful in several performance-and-reliability critical environments, it didn't see mass adoption.</p>
<p>In 2008 LinuxBIOS became <a href="https://www.coreboot.org/">coreboot</a>.</p>
<h2 id="linuxboot"><a class="header" href="#linuxboot">LinuxBoot</a></h2>
<h3 id="nerf"><a class="header" href="#nerf">NERF</a></h3>
<p>This is the original name for the stripped UEFI, plus Linux, plus u-root. The name stands for Non-Extensible Reduced Firmware, as opposed to UEFI's Unified Extensible Firmware Interface. Basically, saying that NERF is an UEFI replacement that prefers to be more compact, less extensible, and a bit more opinionated. While extensibility is nice and often desirable, too much extensibility and too many "yes" can make a complex project very hard to maintain and keep secure.</p>
<p>NERF was created by Ron Minnich while at Google in 2017. The project grew and was maintained by Google's "NERF team".</p>
<p>NERF eventually became the <a href="https://github.com/linuxboot/linuxboot/">linuxboot</a> build system.</p>
<h3 id="heads"><a class="header" href="#heads">Heads</a></h3>
<p><a href="https://github.com/linuxboot/heads">Heads</a> is an open source firmware for laptops and servers created by  Trammell Hudson (a.k.a. osreasrch), aimed at strong platform security. It is currently maintained by Thierry Laurion.</p>
<h3 id="see-also-2"><a class="header" href="#see-also-2">See also</a></h3>
<ul>
<li><a href="https://osresearch.net/">osresearch.net</a></li>
<li><a href="https://trmm.net/NERF/">trmm.net/NERF</a></li>
<li><a href="https://www.golem.de/news/freie-linux-firmware-google-will-server-ohne-intel-me-und-uefi-1710-130840-2.html">NERF-Projekt statt UEFI</a></li>
<li><a href="https://www.twosigma.com/articles/bringing-linux-back-to-the-server-bios-with-linuxboot/">Bringing Linux back to the Server BIOS with LinuxBoot</a></li>
<li><a href="https://www.twosigma.com/articles/linuxboot-a-fast-reliable-open-source-firmware-for-linux-servers/">LinuxBoot: A Fast, Reliable Open Source Firmware for Linux Servers</a></li>
<li><a href="https://www.twosigma.com/articles/safeboot-improving-the-safety-of-booting-linux-on-normal-laptops/">safeboot: Improving the Safety of Booting Linux on Normal Laptops</a></li>
</ul>
<h2 id="open-platform-firmware"><a class="header" href="#open-platform-firmware">Open Platform Firmware</a></h2>
<p><a href="https://www.opencompute.org/projects/open-system-firmware">Open Platform Firmware</a> (OPF), formerly Open System Firmware (OSF), is an official subproject of the <a href="https://www.opencompute.org">Open Compute Project</a> (OCP). OPF has been developed in the open, by various members of OCP that were interested in having open source system firmware. OPF defines a set of guidelines with contributions from Microsoft, Google, Facebook, Intel, 9elements, Two Sigma, and several other companies.</p>
<p>The important thing to keep in mind is that <strong>Open Platform Firmware is a project name</strong>, not an implementation, nor an idea. An implementation (like LinuxBoot or OpenEDK2) can be OPF-compliant if it follows the aforementioned guidelines.</p>
<p>Currently, Open Platform Firmware has two work streams:</p>
<ul>
<li>LinuxBoot, led by Google, Facebook, 9elements, ITRenew, TwoSigma, and others</li>
<li>OpenEDK II, led by Microsoft and Intel</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="案例研究"><a class="header" href="#案例研究">案例研究</a></h1>
<p>This chapter contains case studies for various solutions.</p>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ol>
<li><a href="case_studies/Ampere_study.html">Ampere study</a></li>
<li><a href="case_studies/Google_study.html">Google study</a></li>
<li><a href="case_studies/TiogaPass.html">OCP TiogaPass</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linuxboot-on-ampere-mt-jade-platform"><a class="header" href="#linuxboot-on-ampere-mt-jade-platform">LinuxBoot on Ampere Mt. Jade Platform</a></h1>
<p>The Ampere Altra Family processor based Mt. Jade platform is a high-performance ARM server platform, offering up to 256 processor cores in a dual socket configuration. The Tianocore EDK2 firmware for the Mt. Jade platform has been fully upstreamed to the tianocore/edk2-platforms repository, enabling the community to build and experiment with the platform's firmware using entirely open-source code. It also supports LinuxBoot, an open-source firmware framework that reduces boot time, enhances security, and increases flexibility compared to standard UEFI firmware.</p>
<p>Mt. Jade has also achieved a significant milestone by becoming <a href="https://community.arm.com/arm-community-blogs/b/architectures-and-processors-blog/posts/arm-systemready-ls">the first server certified under the Arm SystemReady LS certification program</a>. SystemReady LS ensures compliance with standardized boot and runtime environments for Linux-based systems, enabling seamless deployment across diverse hardware.  This certification further emphasizes Mt. Jade's readiness for enterprise and cloud-scale adoption by providing assurance of compatibility, performance, and reliability.</p>
<p>This case study explores the LinuxBoot implementation on the Ampere Mt. Jade platform, inspired by the approach used in <a href="case_studies/Google_study.html">Google's LinuxBoot deployment</a>.</p>
<h2 id="ampere-edk2-linuxboot-components"><a class="header" href="#ampere-edk2-linuxboot-components">Ampere EDK2-LinuxBoot Components</a></h2>
<p>The Mt. Jade platform embraces a hybrid firmware architecture, combining UEFI/EDK2 for hardware initialization and LinuxBoot for advanced boot functionalities. The platform aligns closely with step 6 in the LinuxBoot adoption model.</p>
<img src="case_studies/../images/Case-study-Ampere.svg">
<p>The entire boot firmware stack for the Mt. Jade is open source and available in the Github.</p>
<ul>
<li><strong>EDK2</strong>: The PEI and minimal (stripped-down) DXE drivers, including both common and platform code, are fully open source and resides in Tianocore edk2-platforms and edk2 repositories.</li>
<li><strong>LinuxBoot</strong>: The LinuxBoot binary (<a href="case_studies/../glossary.html">flashkernel</a>) for Mt. Jade is supported in the <a href="https://github.com/linuxboot/linuxboot/tree/main/mainboards/ampere/jade">linuxboot/linuxboot</a> repository.</li>
</ul>
<h2 id="ampere-solution-for-linuxboot-as-a-boot-device-selection"><a class="header" href="#ampere-solution-for-linuxboot-as-a-boot-device-selection">Ampere Solution for LinuxBoot as a Boot Device Selection</a></h2>
<p>Ampere has implemented and successfully upstreamed a solution for integrating LinuxBoot as a Boot Device Selection (BDS) option into the TianoCore EDK2 framework, as seen in commit <a href="https://github.com/tianocore/edk2/commit/62540372230ecb5318a9c8a40580a14beeb9ded0">ArmPkg: Implement PlatformBootManagerLib for LinuxBoot</a>. This innovation simplifies the boot process for the Mt. Jade platform and aligns with LinuxBoot's goals of efficiency and flexibility.</p>
<p>Unlike the earlier practice that replaced the UEFI Shell with a LinuxBoot flashkernel, Ampere's solution introduces a custom BDS implementation that directly boots into the LinuxBoot environment as the active boot option. This approach bypasses the need to load the UEFI Shell or UiApp (UEFI Setup Menu), which depend on numerous unnecessary DXE drivers.</p>
<p>To further enhance flexibility, Ampere introduced a new GUID specifically for the LinuxBoot binary, ensuring clear separation from the UEFI Shell GUID. This distinction allows precise identification of LinuxBoot components in the firmware.</p>
<h2 id="build-process"><a class="header" href="#build-process">Build Process</a></h2>
<p>Building a flashable EDK2 firmware image with an integrated LinuxBoot flashkernel for the Ampere Mt. Jade platform involves two main steps: building the LinuxBoot flashkernel and integrating it into the EDK2 firmware build.</p>
<h3 id="step-1-build-the-linuxboot-flashkernel"><a class="header" href="#step-1-build-the-linuxboot-flashkernel">Step 1: Build the LinuxBoot Flashkernel</a></h3>
<p>The LinuxBoot flash kernel is built as follows:</p>
<pre><code class="language-bash">git clone https://github.com/linuxboot/linuxboot.git
cd linuxboot/mainboards/ampere/jade &amp;&amp; make fetch flashkernel
</code></pre>
<p>After the build process completes, the flash kernel will be located at: linuxboot/mainboards/ampere/jade/flashkernel</p>
<h3 id="step-2-build-the-edk2-firmware-image-with-the-flash-kernel"><a class="header" href="#step-2-build-the-edk2-firmware-image-with-the-flash-kernel">Step 2: Build the EDK2 Firmware Image with the Flash Kernel</a></h3>
<p>The EDK2 firmware image is built with the LinuxBoot flashkernel integrated into the flash image using the following steps:</p>
<pre><code class="language-bash">git clone https://github.com/tianocore/edk2-platforms.git
git clone https://github.com/tianocore/edk2.git
git clone https://github.com/tianocore/edk2-non-osi.git
./edk2-platforms/Platform/Ampere/buildfw.sh -b RELEASE -t GCC -p Jade -l linuxboot/mainboards/ampere/jade/flashkernel
</code></pre>
<p>The <code>buildfw.sh</code> script automatically integrates the LinuxBoot flash kernel (provided via the -l option) as part of the final EDK2 firmware image.</p>
<p>This process generates a flashable EDK2 firmware image with embedded LinuxBoot, ready for deployment on the Ampere Mt. Jade platform.</p>
<h2 id="booting-with-linuxboot"><a class="header" href="#booting-with-linuxboot">Booting with LinuxBoot</a></h2>
<p>When powered on, the system will boot into the u-root and automatically kexec to the target OS.</p>
<pre><code class="language-text">Run /init as init process
1970/01/01 00:00:10 Welcome to u-root!
                              _
   _   _      _ __ ___   ___ | |_
  | | | |____| '__/ _ \ / _ \| __|
  | |_| |____| | | (_) | (_) | |_
   \__,_|    |_|  \___/ \___/ \__|

cgroup: Unknown subsys name 'perf_event'
init: 1970/01/01 00:00:10 Deprecation warning: use UROOT_NOHWRNG=1 on kernel cmdline instead of uroot.nohwrng
1970/01/01 00:00:10 Booting from the following block devices: [BlockDevice(name=nvme0n1, fs_uuid=) BlockDevice(name=nvme0n1p1, fs_uuid=d6c6-6306) BlockDevice(name=nvme0n1p2, fs_uuid=63402158-6266-48fb-b602-5f83f26bd0b9) BlockDevice(name=nvme0n1p3, fs_uuid=) BlockDevice(name=nvme1n1, fs_uuid=) BlockDevice(name=nvme1n1p1, fs_uuid=525c-92fb)]
1970/01/01 00:00:10 [grub] Got config file file:///tmp/u-root-mounts3457412855/nvme0n1p1/EFI/ubuntu/grub.cfg:
search.fs_uuid 63402158-6266-48fb-b602-5f83f26bd0b9 root
set prefix=($root)'/grub'
configfile $prefix/grub.cfg

1970/01/01 00:00:10 Warning: Grub parser could not parse ["search" "--fs-uuid" "63402158-6266-48fb-b602-5f83f26bd0b9" "root"]
1970/01/01 00:00:10 [grub] Got config file file:///tmp/u-root-mounts3457412855/nvme0n1p2/grub/grub.cfg
1970/01/01 00:00:10 Error: Expected 1 device with UUID "1334d6c5-c16f-46ba-9120-5127ae43bf63", found 0
1970/01/01 00:00:10 Error: Expected 1 device with UUID "1334d6c5-c16f-46ba-9120-5127ae43bf63", found 0


Welcome to LinuxBoot's Menu

Enter a number to boot a kernel:

1.  Ubuntu

2.  Ubuntu, with Linux 6.8.0-49-generic

3.  Ubuntu, with Linux 6.8.0-49-generic (recovery mode)

4.  Ubuntu, with Linux 6.8.0-48-generic

5.  Ubuntu, with Linux 6.8.0-48-generic (recovery mode)

6.  Reboot

7.  Enter a LinuxBoot shell


Enter an option ('01' is the default, 'e' to edit kernel cmdline):
 &gt; 07

&gt; dmidecode -t 4
# dmidecode-go
Reading SMBIOS/DMI data from sysfs.
SMBIOS 3.3.0 present.

Handle 0x0003, DMI type 4, 51 bytes
Processor Information
        Socket Designation: CPU01
        Type: Central Processor
        Family: ARMv8
        Manufacturer: Ampere(R)
        ID: 01 00 16 0A A1 00 00 00
        Signature: Implementor 0x0a, Variant 0x1, Architecture 6, Part 0x000, Revision 1
        Version: Ampere(R) Altra(R) Processor
        Voltage: 1.0 V
        External Clock: 25 MHz
        Max Speed: 3000 MHz
        Current Speed: 3000 MHz
        Status: Populated, Enabled
        Upgrade: Unknown
        L1 Cache Handle: 0x0001
        L2 Cache Handle: 0x0002
        L3 Cache Handle: Not Provided
        Serial Number: 000000000000000002550904033865B4
        Asset Tag: Not Set
        Part Number: Q80-30
        Core Count: 80
        Core Enabled: 80
        Thread Count: 80
        Characteristics:
                64-bit capable
                Multi-Core
                Execute Protection
                Enhanced Virtualization
                Power/Performance Control

Handle 0x0007, DMI type 4, 51 bytes
Processor Information
        Socket Designation: CPU02
        Type: Central Processor
        Family: ARMv8
        Manufacturer: Ampere(R)
        ID: 01 00 16 0A A1 00 00 00
        Signature: Implementor 0x0a, Variant 0x1, Architecture 6, Part 0x000, Revision 1
        Version: Ampere(R) Altra(R) Processor
        Voltage: 1.0 V
        External Clock: 25 MHz
        Max Speed: 3000 MHz
        Current Speed: 3000 MHz
        Status: Populated, Enabled
        Upgrade: Unknown
        L1 Cache Handle: 0x0005
        L2 Cache Handle: 0x0006
        L3 Cache Handle: Not Provided
        Serial Number: 000000000000000002560909033865B4
        Asset Tag: Not Set
        Part Number: Q80-30
        Core Count: 80
        Core Enabled: 80
        Thread Count: 80
        Characteristics:
                64-bit capable
                Multi-Core
                Execute Protection
                Enhanced Virtualization
                Power/Performance Control

&gt;
M-? toggle key help • C-d erase/stop • C-c clear/cancel • C-r search hist …
</code></pre>
<h2 id="future-work-1"><a class="header" href="#future-work-1">Future Work</a></h2>
<p>While the LinuxBoot implementation on the Ampere Mt. Jade platform represents a significant milestone, several advanced features and improvements remain to be explored. These enhancements would extend the platform's capabilities, improve its usability, and reinforce its position as a leading open source firmware solution. Key areas for future development include:</p>
<h3 id="secure-boot-with-linuxboot"><a class="header" href="#secure-boot-with-linuxboot">Secure Boot with LinuxBoot</a></h3>
<p>One of the critical areas for future development is enabling secure boot verification for the target operating system. In the LinuxBoot environment, the target OS is typically booted using kexec. However, it is unclear how Secure Boot operates in this context, as kexec bypasses traditional firmware-controlled secure boot mechanisms. Future work should investigate how to extend Secure Boot principles to kexec, ensuring that the OS kernel and its components are verified and authenticated before execution. This may involve implementing signature checks and utilizing trusted certificate chains directly within the LinuxBoot environment to mimic the functionality of UEFI Secure Boot during the kexec process.</p>
<h3 id="tpm-support-1"><a class="header" href="#tpm-support-1">TPM Support</a></h3>
<p>The platform supports TPM, but its integration with LinuxBoot is yet to be defined. Future work could explore utilizing the TPM for secure boot measurements, and system integrity attestation.</p>
<h3 id="expanding-support-for-additional-ampere-platforms"><a class="header" href="#expanding-support-for-additional-ampere-platforms">Expanding Support for Additional Ampere Platforms</a></h3>
<p>Building on the success of LinuxBoot on Mt. Jade, future efforts should expand support to other Ampere platforms.  This would ensure broader adoption and usability across different hardware configurations.</p>
<h3 id="optimizing-the-transition-between-uefi-and-linuxboot"><a class="header" href="#optimizing-the-transition-between-uefi-and-linuxboot">Optimizing the Transition Between UEFI and LinuxBoot</a></h3>
<p>Improving the efficiency of the handoff between UEFI and LinuxBoot could further reduce boot times.  This optimization would involve refining the initialization process and minimizing redundant operations during the handoff.</p>
<h3 id="advanced-diagnostics-and-monitoring-tools"><a class="header" href="#advanced-diagnostics-and-monitoring-tools">Advanced Diagnostics and Monitoring Tools</a></h3>
<p>Adding more diagnostic and monitoring tools to the LinuxBoot u-root environment would enhance debugging and system management.  These tools could provide deeper insights into system performance and potential issues, improving reliability and maintainability.</p>
<h2 id="see-also-3"><a class="header" href="#see-also-3">See Also</a></h2>
<ul>
<li><a href="https://amperecomputing.com/blogs/linuxboot-on-ampere-platforms--a-new-old-approach-to-firmware">LinuxBoot on Ampere Platforms: A new (old) approach to firmware</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-linuxboot-project-at-google"><a class="header" href="#the-linuxboot-project-at-google">The LinuxBoot project at Google</a></h1>
<p>Google runs workloads across a number of clusters each with up to tens of thousands of machines. Firmware runs on these machines when they first start up. Google is pushing the state-of-the-art in many places including firmware. The discussion here about Google's implementation of LinuxBoot is limited to replacing specific UEFI <a href="case_studies/../glossary.html">firmware</a> functionality with a Linux kernel and runtime. Over the years this project has grown to include various initiatives with the overarching goal of moving from obscure, complex firmware to simpler, open source firmware.</p>
<h2 id="team"><a class="header" href="#team">Team</a></h2>
<p>There have been a number of contributors to the Google LinuxBoot project including:</p>
<ul>
<li>Ron Minnich (technical lead)</li>
<li>Gan-shun Lim</li>
<li>Ryan O'Leary</li>
<li>Prachi Laud</li>
<li>Chris Koch</li>
<li>Xuan Chen</li>
<li>Andrew Sun</li>
</ul>
<p>Ryan O'Leary is one of the Open Compute Platform Foundation <a href="https://www.opencompute.org/projects/open-system-firmware">Open System Firmware project</a> volunteer leads and Ron Minnich is the Open Compute Platform Foundation Incubation Committee Representative.</p>
<h2 id="goal"><a class="header" href="#goal">Goal</a></h2>
<p>The primary goal of Google's LinuxBoot is to modernize the firmware by simplifying it to technologies engineers understand and trust. In UEFI systems, LinuxBoot consists of a "full stack" solution of stripped-down UEFI firmware, a Linux kernel, and an initramfs with tools written in Go. Although these components all make up one bundle stored in ROM, there are three parts: the closed-source EFI firmware, a Linux kernel, and <a href="case_studies/../u-root.html">u-root</a>. The Linux kernel is an unmodified kernel.  The user-space initramfs image with Go tools for system booting is available as u-root. Due to this modularity, LinuxBoot can be used with a variety of systems. In many cases, for example, the same kernel and initramfs have been used, without recompilation, on both AMD and Intel x86 boards. The UEFI on these boards is always specific to the board, however.</p>
<h2 id="converting-a-uefi-firmware-image-to-use-linuxboot"><a class="header" href="#converting-a-uefi-firmware-image-to-use-linuxboot">Converting a UEFI firmware image to use LinuxBoot</a></h2>
<p>The conversion to LinuxBoot starts with generic UEFI. A UEFI computer boots in four main phases. The security phase (SEC) and the Pre-EFI Initialization Stage (PEI) are responsible for low-level operations to prepare the hardware and are usually specific to the hardware they are implemented for. After these two stages, the Driver Execution Environment (DXE) loads various drivers, and then the Boot Device Select (BDS) phase begins.</p>
<p>It is not possible to modify the SEC and PEI stages, as their components are tightly coupled to the chips on the board; even small changes to the chips require new SEC and PEI stages. LinuxBoot starts during the DXE stage, resulting in most of the drivers (and their associated attack surface) not being loaded. Instead, a Linux kernel is loaded as if it were a driver. By loading during the DXE, LinuxBoot runs after the first two stages of the UEFI, but takes over after that point, replacing the UEFI drivers. It therefore completely replaces a large portion of the boot process.</p>
<h2 id="phases-of-the-project"><a class="header" href="#phases-of-the-project">Phases of the project</a></h2>
<p>Google's LinuxBoot project is focused on moving UEFI boot functionality into the kernel and user-space. That is, converting UEFI firmware to run LinuxBoot. The project has taken the standard UEFI boot process and converted it to LinuxBoot for production environments. The steps to reach this goal are described below.</p>
<p>Step 1. Reduce or replace UEFI components</p>
<p>UEFI contains proprietary, closed-source, vendor-supplied firmware drivers and firmware. LinuxBoot replaces many Driver Execution Environment (DXE) modules used by UEFI and other firmware, particularly the network stack and file system modules, with Linux applications.</p>
<p>The following diagram shows the phases of the UEFI boot process. The items in <span style="color:red">red</span> are components that are either reduced or eliminated with LinuxBoot. The <span style="color:blue">dark blue</span> items on the left cannot be changed.</p>
<img src="case_studies/../images/Case-study-step1.svg" width=600px>
<p>In the real FLASH part, the SEC and PEI are actually only 10% of total, so we reduce the size of those boxes in this and following diagrams.</p>
<img src="case_studies/../images/Case-study-step1a.svg" width=600px>
<p>Another part of the conversion process was to modify the UEFI boot process to boot a LinuxBoot image as shown below.</p>
<img src="case_studies/../images/Case-study-step1b.svg" width=600px>
<p>Step 2. Delete or replace as many proprietary DXEs as required to make step 3 work. In most cases, none need to be removed.</p>
<img src="case_studies/../images/Case-study-step2.svg" width=600px>
<p>Step 3. Replace the UEFI shell with a Linux kernel + u-root</p>
<img src="case_studies/../images/Case-study-step3.svg" width=600px>
<p>When Linux boots it needs a root file system with utilities. LinuxBoot provides a file system based on u-root standard utilities written in Go.</p>
<p>Step 4. Through trial and error, continue to remove DXEs until you can't remove anymore.</p>
<p>The DXEs are delivered as binary blobs. There are three ways to handle them:</p>
<ol>
<li>The most desirable is to remove them and let Linux drivers take over what they did. This works well for USB, network, disk, and other drivers, as well as network protocols and file systems. In fact we have resolved many system reliability and performance issues just by removing DXEs!</li>
<li>The second way is to replace the DXE with an open source driver. This is less desirable, as the DXE environment is not as hardened as the Linux kernel environment.</li>
<li>The final, least desired option, is to continue to use the DXE. This is required if the DXE contains proprietary code that "tweaks" chipset settings, for example, memory timing or other controls, and there is no chance of ever bringing them to open source.</li>
</ol>
<img src="case_studies/../images/Case-study-step4.svg" width=600px>
<p>Step 5. Replace closed source DXEs with open source</p>
<p>If we can build a DXE from source, we can use <code>utk</code> to:</p>
<ul>
<li>Remove the proprietary one</li>
<li>Replace it with one built from source</li>
</ul>
<img src="case_studies/../images/Case-study-step5.svg" width=600px>
<p>Step 6. Next steps: complete LinuxBoot</p>
<p>LinuxBoot is currently in production, but the LinuxBoot project development continues to provide an open-source solution that does the following:</p>
<ol>
<li>Brings up the Linux kernel as a DXE in flash ROM instead of the UEFI shell.</li>
<li>Provides a Go based user-space that can then bring up the kernel that you want to run on the machine.</li>
<li>Enables writing traditional firmware applications such as bootloader, debugging, diagnosis, and error detection applications as cross-architecture and cross-platform portable Linux applications.</li>
</ol>
<p>The complete LinuxBoot solution is shown in the following diagram.</p>
<img src="case_studies/../images/Case-study-step6.svg" width=600px>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ocp-tiogapass-case-study"><a class="header" href="#ocp-tiogapass-case-study">OCP TiogaPass Case Study</a></h1>
<p>Points of contact: <a href="https://github.com/jonzhang-fb">Jonathan Zhang</a>, <a href="https://github.com/insomniacslk">Andrea Barberio</a>, <a href="https://github.com/dhendrix">David Hendricks</a>, <a href="https://github.com/agangidi53">Adi</a>, <a href="https://github.com/morganjangwiwynn">Morgan Jang</a>, <a href="https://github.com/johnnylinwiwynn">Johnny Lin</a></p>
<p>This case study describes information for firmware development community to use <a href="https://www.opencompute.org/">OCP</a> platform TiogaPass, made by <a href="http://www.wiwynn.com/english">Wiwynn Corporation</a>.</p>
<p>It contains following sections:</p>
<ul>
<li><a href="case_studies/TiogaPass.html#Quick-Start">Quick Start</a></li>
<li><a href="case_studies/TiogaPass.html#Details">Details</a>
<ul>
<li><a href="case_studies/TiogaPass.html#How-to-build">How to build</a></li>
<li><a href="case_studies/TiogaPass.html#How-to-operate">How to operate</a></li>
<li><a href="case_studies/TiogaPass.html#Platform-info">Platform info</a></li>
</ul>
</li>
<li><a href="case_studies/TiogaPass.html#Support">Support</a>
<ul>
<li><a href="case_studies/TiogaPass.html#Hardware-support">Hardware support</a></li>
<li><a href="case_studies/TiogaPass.html#Community-support">Community support</a></li>
<li><a href="case_studies/TiogaPass.html#Professional-support">Professional support</a></li>
</ul>
</li>
</ul>
<h2 id="quick-start-1"><a class="header" href="#quick-start-1">Quick Start</a></h2>
<ul>
<li>
<p><a href="http://www.wiwynn.com/english">Order the hardware</a> if you have not done so.</p>
</li>
<li>
<p>Download or build the firmware binary. The current solution is to boot embedded Linux kernel and initramfs as UEFI payload. Please contact Wiwynn to get a UEFI binary after ordering.</p>
</li>
<li>
<p>Flash the firmware.</p>
<ul>
<li>Copy the downloaded firmware to OpenBMC.</li>
<li>From OpenBMC
<pre><code>  fw-util mb --update bios --force ./&lt;firmware image name&gt;
</code></pre>
</li>
</ul>
</li>
<li>
<p>Boot and enjoy.</p>
<ul>
<li>From OpenBMC
<pre><code>  power-util mb reset
  sol-util mb
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="details"><a class="header" href="#details">Details</a></h2>
<h3 id="how-to-build"><a class="header" href="#how-to-build">How to build</a></h3>
<p>Follow <a href="case_studies/TiogaPass.html#Build-Details">Build Details</a> for details on how to get the source code, and how to build.</p>
<p>Boot flow of the current firmware solution is: Power on → minimized UEFI → LinuxBoot → target OS.</p>
<p>In near feature, the boot flow will be: power on → Coreboot → LinuxBoot → target OS.</p>
<h4 id="build-details"><a class="header" href="#build-details">Build Details</a></h4>
<ul>
<li>
<p>Download the code from <a href="https://github.com/linuxboot/linuxboot">linuxboot github</a></p>
<pre><code>  git clone https://github.com/linuxboot/linuxboot.git
</code></pre>
</li>
<li>
<p>You need to apply Wiwiynn's linuxboot patch for now</p>
<pre><code>cd linuxboot
wget -O TiogaPass.patch https://github.com/johnnylinwiwynn/linuxboot/commit/28ae8450b3b05c6e6b8c74e29d0974ccf711d5e6.patch
git am TiogaPass.patch
</code></pre>
</li>
<li>
<p>Build the kernel bzImage (has embedded initramfs) for linuxboot, please reference <a href="https://github.com/linuxboot/book/tree/master/coreboot.u-root.systemboot#building-u-root">Building u-root</a> and <a href="https://github.com/linuxboot/book/tree/master/coreboot.u-root.systemboot#building-a-suitable-linux-kernel">Building a suitable Linux kernel</a> for how to build the bzImage. You can always customize your Linux kernel configuration to suit your needs, please reference Wiwynn's kernel configuration file as a sample <a href="case_studies/linux_config">linux_config</a>.</p>
</li>
<li>
<p>Place the tioga.rom into linuxboot/boards/tioga which is provided from Wiwynn after ordering, and also put your bzImage to the root folder of linuxboot, and then make</p>
<pre><code>  cp path/to/tioga.rom linuxboot/boards/tioga
  cp path/to/bzImage linuxboot
  cd linuxboot
  BOARD=tioga make
</code></pre>
</li>
<li>
<p>You should see the built image at build/tioga/linuxboot.rom.</p>
</li>
</ul>
<h3 id="how-to-operate"><a class="header" href="#how-to-operate">How to operate</a></h3>
<p>Follow <strong>TBD section</strong> for details on:</p>
<ul>
<li>How to flash. The image can be flashed either out-of-band, or from LinuxBoot u-root shell, or from targetOS shell.</li>
<li>How to run LinuxBoot u-root shell commands.</li>
</ul>
<h3 id="platform-info"><a class="header" href="#platform-info">Platform info</a></h3>
<p>The SKU contains TiogaPass board, a debug card, a VGA card, a power adapter. The details can be obtained from the <a href="http://www.wiwynn.com/english">Wiwynn Corporation</a>.</p>
<p>Platform design details (including the design spec and schematics) can be found on the <a href="https://www.opencompute.org/products/108/wiwynn-tioga-pass-standard-sv7220g3-s-2u-ocp-server-up-to-768gb-8gb16gb32gb-ddr4-up-to-2666mts-12-dimm-slots">Open Compute Project UfiSpace product page</a>.</p>
<h2 id="support"><a class="header" href="#support">Support</a></h2>
<h3 id="hardware-support"><a class="header" href="#hardware-support">Hardware support</a></h3>
<p>Hardware support can be obtained from <a href="http://www.wiwynn.com/english">Wiwynn Corporation</a>.</p>
<h3 id="community-support"><a class="header" href="#community-support">Community support</a></h3>
<p><a href="https://www.opencompute.org/projects/open-system-firmware">OCP Open System Firmware</a> is where industry collaborates on how to move forward with OSF. The OCP OSF project has regular recorded meetings and a mailing list.</p>
<p><a href="https://www.linuxboot.org/">LinuxBoot open source community</a> is the community you can ask any technical questions. LinuxBoot community has a slack channel, a IRC channel, a mailing list and regular meetings.</p>
<h3 id="professional-support"><a class="header" href="#professional-support">Professional support</a></h3>
<p>Following companies provides professional support services:</p>
<p>** TBD **</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="frequently-asked-questions"><a class="header" href="#frequently-asked-questions">Frequently asked questions</a></h1>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<p><strong>Why does the u-root DHCP client take ages?</strong></p>
<p>The problem is a lack of early entropy. If your platform has a hardware random number generator then enable it with <code>CONFIG_ARCH_RANDOM</code> and trust it with <code>CONFIG_RANDOM_TRUST_CPU</code>. Otherwise, add <code>uroot.nohwrng</code> to your kernel command line so u-root use a non-blocking random number generator implementation.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>
        <script src="theme/js/language-picker.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
