<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Implementing LinuxBoot - LinuxBoot</title>


        <!-- Custom HTML head -->
        <script>
            const mdbookPath = "implementation.md";
            const mdbookPathToRoot = "";
        </script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/css/language-picker.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">LinuxBoot</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/linuxboot/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="implementing-linuxboot"><a class="header" href="#implementing-linuxboot">Implementing LinuxBoot</a></h1>
<p>The aim of LinuxBoot is to reduce complexity and obscure firmware by moving
that functionality into kernel and user-space.</p>
<p>This chapter describes the procedures from a <a href="https://docs.google.com/presentation/d/1s9ka4v7leKeJa3116AQoNb9cv3OqmnW6pgn0ov9WiHo/edit?ts=5e2b227b#slide=id.g7ceec54197_4_163">LinuxBoot
workshop</a>
where an Atomic Pi board with UEFI firmware was converted to run LinuxBoot. The
build materials associated with this are found at
<a href="https://github.com/linuxboot/mainboards/tree/master/digitalloggers/atomicpi">digitalloggers/atomicpi</a>.</p>
<p>Read the below and consult the Makefile for the details of how it was
implemented.</p>
<h2 id="a-quick-refresher-on-uefi"><a class="header" href="#a-quick-refresher-on-uefi">A quick refresher on UEFI</a></h2>
<p>UEFI has three sections:</p>
<ul>
<li>SEC ("Boot")</li>
<li>PEI ("Very early chip setup and DRAM programming")</li>
<li>DXE ("DRAM code")</li>
</ul>
<p>DXE process is very complex; some systems have 750 DXEs.</p>
<p>LinuxBoot replaces most of the UEFI software with Linux. LinuxBoot has an
initramfs provided by <a href="./u-root.html">u-root</a>.</p>
<p>The above are stored inside a flash filesystem (FFS) inside a region of flash
on your motherboard (the BIOS region). Another important region of flash is the
ME region.</p>
<p>The Management Engine (ME) is an x86 CPU embedded in the Intel Platform
Controller Hub (PCH). It runs the Minix operating system which boots first and
enables hardware such as clocks and GPIOs. ME checks the contents of flash
memory and is used to implement "BootGuard". If you reflash and the ME is in
"BootGuard" mode, your machine will be unusable. You need to run a tool called
<code>me_cleaner</code> on the image to disable BootGuard.</p>
<h2 id="how-do-you-get-linuxboot-on-your-hardware"><a class="header" href="#how-do-you-get-linuxboot-on-your-hardware">How do you get LinuxBoot on your hardware</a></h2>
<p>Start with a board running standard UEFI and proceed from "zero changes to
FLASH" to "max changes" in 4 steps:</p>
<ul>
<li>Boot from USB stick via UEFI shell command <em>or</em> netboot (zero changes)</li>
<li>Find a way to read flash and write flash</li>
<li>Understand the flash layout</li>
<li>Prepare linux kernel and initrd/initramfs payload.</li>
<li>Replace UEFI Shell code section with Linux kernel and associated initrd
(change part of one thing)</li>
<li>Remove as many DXEs as possible (change by removal). This change:
<ul>
<li>Speeds boot</li>
<li>Reduces panic possibilities</li>
<li>Removes exploits</li>
<li>In production, it has solved problems</li>
</ul>
</li>
<li>Clear ME region for initrd storage</li>
<li>Replace some DXEs with open source components (change by replacement)</li>
</ul>
<p>One of the challenges in the above is in finding (or reclaiming) enough space
in flash to shoehorn your kernel and initrd into.</p>
<h2 id="tools-of-the-trade"><a class="header" href="#tools-of-the-trade">Tools of the trade</a></h2>
<p>There are two tools you use when you modify the UEFI flash image: <code>utk</code> and
<code>me_cleaner</code>.</p>
<p>The ME Cleaner tool:</p>
<p><code>/usr/bin/python2 me_cleaner.py -s</code> <em>imagefile.bin</em></p>
<p><code>me_cleaner</code> sets the high assurance platform (HAP) bit. HAP provides a way to
disable a feature on Intel chips that does not allow us to modify the UEFI
image and install LinuxBoot. Setting the bit with <code>me_cleaner</code> disables the
"feature".  Note that this does not always work; check with the LinuxBoot
community.</p>
<p>When you run <code>me_cleaner</code>:</p>
<pre><code>~/projects/linuxboot/me_cleaner/me_cleaner.py -s /tmp/rom.bin
</code></pre>
<p>you should see output similar to the following:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left"></th></tr></thead><tbody>
<tr><td style="text-align: left"><code>Full image detected</code></td></tr>
<tr><td style="text-align: left"><code>Found FPT header at 0x1010</code></td></tr>
<tr><td style="text-align: left"><code>Found 20 partition(s)</code></td></tr>
<tr><td style="text-align: left"><code>Found FTPR header: FTPR partition spans from 0x6f000 to 0xe700</code></td></tr>
<tr><td style="text-align: left"><code>ME/TXE firmware version 2.0.5.3112 (generation 2)</code></td></tr>
<tr><td style="text-align: left"><code>Public key match: Intel TXE, firmware versions 2.x.x.x</code></td></tr>
<tr><td style="text-align: left"><code>The AltMeDisable bit is SET</code></td></tr>
<tr><td style="text-align: left"><code>Setting the AltMeDisable bit in PCHSTRP10 to disable Intel MEâ€¦</code></td></tr>
<tr><td style="text-align: left"><code>Checking the FTPR RSA signature... VALID</code></td></tr>
<tr><td style="text-align: left"><code>Done! Good luck!</code></td></tr>
</tbody></table>
</div>
<p>By applying <code>me_cleaner</code>, it has been observed that almost 4M of flash ram can
be reclaimed for use. That 4M is enough to store a reasonably full featured
compressed initrd image.</p>
<p>The <code>utk</code> tool can:</p>
<ul>
<li>Remove DXEs</li>
<li>Insert new DXEs</li>
<li>Replace the binary code of a DXE with a kernel</li>
<li>Reallocate space from the ME region to the BIOS region ("tighten")</li>
</ul>
<h2 id="linuxboot-implementation-steps"><a class="header" href="#linuxboot-implementation-steps">LinuxBoot Implementation steps</a></h2>
<h3 id="step-1-boot-linux-via-netboot--uefi-shell"><a class="header" href="#step-1-boot-linux-via-netboot--uefi-shell">Step 1: boot Linux via netboot / UEFI shell</a></h3>
<ul>
<li>netboot: standard BIOS-based PXE boot
<ul>
<li>Netboot is probably the most common working boot method on UEFI</li>
<li>We have never seen a system that did not have a net boot</li>
</ul>
</li>
<li>UEFI Shell (mentioned only for completeness)
<ul>
<li>Install Linux on FAT-32 media with a name of your choice (e.g. "kernel")
<ul>
<li>FAT-32, also known as MS-DOS file system</li>
</ul>
</li>
<li>Boot kernel at UEFI Shell prompt</li>
<li>We've run into a few systems that don't have a UEFI shell</li>
</ul>
</li>
</ul>
<h4 id="working-with-a-system-that-only-has-a-net-interface"><a class="header" href="#working-with-a-system-that-only-has-a-net-interface">Working with a system that only has a net interface</a></h4>
<p>If the system only has a net interface, you use Dynamic Host Configuration
Protocol (DHCP), using broadcast DISCOVER, and Trivial File Transfer Protocol
(TFTP) to get the boot information you need.</p>
<p>Configuration information is provided by REPLY to a DHCP request. The REPLY
returns an IP, server, and a configuration file name that provides:</p>
<ul>
<li>Identity</li>
<li>What to boot</li>
<li>Where to get it</li>
</ul>
<p>Data is provided by TFTP. HTTP downloading takes a fraction of a second even
for 16M kernels. With TFTP it's very slow and TFTP won't work with initramfs
much large than 32MiB. Most LinuxBoot shops use or are transitioning to HTTP.</p>
<p>Note: Boot images require a kernel(bzImage) + an initramfs + a command line.
They can be loaded as three pieces or compiled and loaded as one piece, as
described in this section.</p>
<h3 id="step-2-read--write-the-flash"><a class="header" href="#step-2-read--write-the-flash">Step 2: read &amp; write the flash</a></h3>
<p>There are two main ways to read and write the flash - hardware and software.</p>
<p>Hardware: It is worth buying a Pomona 5250 SOIC Clip adapter to read directly
by hardware to have something to roll back to if anything goes wrong. Avoid
cheap SOIC clip adapters that don't allow you to use standard jumper leads. For
a good example of using a Raspberry Pi 3/4 to read/write, see <a href="https://wiki.gentoo.org/wiki/Sakaki%27s_EFI_Install_Guide/Disabling_the_Intel_Management_Engine#imt_check">Sakaki's EFI
Install Guide/Disabling the Intel Management
Engine</a></p>
<p>Software: With a working boot image, use flashrom to read an image of your
flash. To write you may need to disable flash protections (look for "ME
Manufacturing mode" jumpers on your motherboard). Figure on generally using
software methods for reading &amp; writing flash, but with hardware to drop back
to.</p>
<h3 id="step-3-familiarise-yourself-with-the-flash-layout-and-identify-free-space"><a class="header" href="#step-3-familiarise-yourself-with-the-flash-layout-and-identify-free-space">Step 3: Familiarise yourself with the flash layout and identify free space</a></h3>
<p>Open your flash image with UEFITool, and locate the filesystem containing the
DXE's (it will have the Shell or <code>Shell_Full</code> in it ). Check how much volume free
space is in that filesystem - this will be an initial limit when you come to
place your kernel and initramfs in it in step 5.</p>
<h3 id="step-4-prepare-linuxu-root-payload"><a class="header" href="#step-4-prepare-linuxu-root-payload">Step 4: Prepare linux/u-root payload</a></h3>
<p>Start small and work your way up.</p>
<ul>
<li>Use the tiny.config to configure your first kernel, and embed a small
initramfs in-kernel (the u-root cpu payload is an excellent starting point).</li>
<li>One can have a full kernel/initramfs in around 2M of flash.</li>
<li>A more full featured kernel might consume 2M and a u-root bb distribution 4M,
which may well exceed the volume free space.</li>
<li>When there isn't enough space in this filesystem, one can either start
removing unused DXE's (step 6), or use space formerly used by the ME Region
(step 7).</li>
</ul>
<h3 id="step-5-replace-shell-binary-section"><a class="header" href="#step-5-replace-shell-binary-section">Step 5: replace Shell binary section</a></h3>
<ul>
<li>UEFI Shell is a DXE
<ul>
<li>DXEs are Portable Executable 32-bit binaries (PE32)</li>
<li>They have multiple sections, one of them being binary code</li>
<li>You need a flash image (in this case called <em>firmware.bin</em>). You can get
it via vendor website, flashrom, or other mechanism.</li>
</ul>
</li>
<li>The following <code>utk</code> command replaces the Shell code section with a Linux
kernel:
<ul>
<li><code>utk firmware.bin replace_pe32 Shell bzImage save</code> <em>new.bin</em></li>
<li>Note: It's always a PE32, even for 64-bit kernels. <em>new.bin</em> is a filename
of your choosing.</li>
</ul>
</li>
<li>After running <code>utk</code>, you can reflash</li>
</ul>
<h3 id="step-6a-remove-as-many-dxes-as-possible"><a class="header" href="#step-6a-remove-as-many-dxes-as-possible">Step 6a: remove as many DXEs as possible</a></h3>
<ul>
<li>You can do an initial mass removal based on your current knowledge</li>
<li><code>utk</code> automates removing DXEs: this is the DXE cleaner
<ul>
<li><code>utk</code> removes a DXE, reflashes, checks if it boots, repeat
This part should be easy: DXE can have a dependency section. In practice,
it's hard: because dependency sections are full of errors and omissions. A lot
of UEFI code does not check for failed DXE loads.</li>
</ul>
</li>
</ul>
<h3 id="step-6b-place-your-initramfs-in-me_cleaned-region"><a class="header" href="#step-6b-place-your-initramfs-in-me_cleaned-region">Step 6b: place your initramfs in me_cleaned region</a></h3>
<ul>
<li>Run <code>me_cleaner</code> and then utk tighten on the source image, then inspect the
image using UEFITool. If successful, there will now be padding at the
beginning of the BIOS region of a substantial size.</li>
<li>This padding space can be used, without the filesystem's knowledge, to stash
an initramfs. The kernel is informed of the location this initramfs as an
initrd kernel parameter.
<ul>
<li>Use the base address of this padding region to calculate the offset in
the flash image where the initrd is stashed using dd.</li>
<li>Use the address (not base address) as the initramfs location in memory to
pass as a kernel parameter.</li>
</ul>
</li>
</ul>
<h3 id="step-7-replace-closed-source-with-open-source"><a class="header" href="#step-7-replace-closed-source-with-open-source">Step 7: replace closed-source with open source</a></h3>
<ul>
<li>If you can build a DXE from source, you can use <code>utk</code> to remove the
proprietary one and replace it with one built from source. You can get DXE
source from the tianocore/EDK2 source repo at github.com. The GitHub repo has a
<strong><em>limited</em></strong> number of DXEs in source form; i.e., you can't build a full
working image using it.</li>
<li>There are scripts that let you compile individual DXEs, including the UEFI
Shell and Boot Device Selection (BDS). These two DXEs have been compiled and
are used in the Atomic Pi. Source-based BDS was needed to ensure the UEFI
Shell was called.</li>
<li>You only need the UEFI Shell built long enough to replace it with Linux.</li>
</ul>
<h3 id="final-step-reflash-the-image"><a class="header" href="#final-step-reflash-the-image">Final step: reflash the image</a></h3>
<ul>
<li>"Native" reflash: Boot the system whatever way is easiest: netboot, usb,
local disk, and run <code>flashrom -p internal -w _filename.bin_</code> where
<em>filename.bin</em> is a filename of your choosing.</li>
<li>Run <code>flashrom</code> with an external device such as an sf100. There may be a
header on the board, or you might have to use a clip.
<code>flashrom -p dediprog:voltage=1.8 -w _filename.bin_</code></li>
</ul>
<p>The voltage option is required for the Atomic Pi.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="utilities/dut.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="coreboot.u-root.systemboot/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="utilities/dut.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="coreboot.u-root.systemboot/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>
        <script src="theme/js/language-picker.js"></script>


    </div>
    </body>
</html>
