<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>All about u-root - LinuxBoot</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">LinuxBoot</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/linuxboot/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="all-about-u-root"><a class="header" href="#all-about-u-root">All about u-root</a></h1>
<p>U-root is an embeddable root file system intended to be placed in a flash
device as part of the firmware image, along with a Linux kernel. The program
source code is installed in the root file system contained in the firmware
flash part and compiled on demand. All the u-root utilities, roughly
corresponding to standard Unix utilities, are written in Go, a modern,
type-safe language with garbage collection and language-level support for
concurrency and inter-process communication.</p>
<p>Unlike most embedded root file systems, which consist largely of binaries,
u-root has only 5: an init program and 4 Go compiler binaries. When a program
is first run, it, and any not-yet-built packages it uses are compiled to a
RAM-based file system. The first invocation of a program takes a fraction of a
second, as it is compiled. Packages are only compiled once, so the slowest
build is always the first one, on boot, which takes about 3 seconds. Subsequent
invocations are very fast, usually a millisecond or so.</p>
<p>U-root blurs the line between script-based distros such as Perl Linux<sup class="footnote-reference" id="fr-24-1"><a href="#footnote-24">1</a></sup> and
binary-based distros such as BusyBox<sup class="footnote-reference" id="fr-26-1"><a href="#footnote-26">2</a></sup>. It has the flexibility of Perl Linux
and the performance of BusyBox. Scripts and builtins are written in Go, not a
shell scripting language. U-root is a new way to package and distribute file
systems for embedded systems, and the use of Go promises a dramatic improvement
in their security.</p>
<h2 id="u-root-and-embedded-systems"><a class="header" href="#u-root-and-embedded-systems">U-root and embedded systems</a></h2>
<p>Embedding kernels and root file systems in BIOS flash is a common technique for
gaining boot time performance and platform customization<sup class="footnote-reference" id="fr-25-1"><a href="#footnote-25">3</a></sup> <sup class="footnote-reference" id="fr-14-1"><a href="#footnote-14">4</a></sup> <sup class="footnote-reference" id="fr-23-1"><a href="#footnote-23">5</a></sup>.
Almost all new firmware includes a multiprocess operating system with a full
complement of file systems, network drivers, and protocol stacks, all contained
in an embedded file system. In some cases, the kernel is only booted long
enough to boot another kernel. In others, the kernel that is booted and the
file system it contains constitute the operational environment of the
device<sup class="footnote-reference" id="fr-15-1"><a href="#footnote-15">6</a></sup>. These so-called “embedded root file systems” also contain a set of
standard Unix-style programs used for both normal operation and maintenance.
Space on the device is at a premium, so these programs are usually written in C
using the BusyBox toolkit<sup class="footnote-reference" id="fr-26-2"><a href="#footnote-26">2</a></sup>, or in an interpretive language such as Perl<sup class="footnote-reference" id="fr-24-2"><a href="#footnote-24">1</a></sup>
or Forth. BusyBox in particular has found wide usage in embedded appliance
environments, as the entire root file system can be contained in under one MiB.</p>
<p>Embedded systems, which were once standalone, are now almost always network
connected. Network connected systems face a far more challenging security
environment than even a few years ago. In response to the many successful
attacks against shell interpreters<sup class="footnote-reference" id="fr-11-1"><a href="#footnote-11">7</a></sup> and C programs<sup class="footnote-reference" id="fr-8-1"><a href="#footnote-8">8</a></sup>, we have started to
look at using a more secure, modern language in embedded root file systems,
namely, Go<sup class="footnote-reference" id="fr-21-1"><a href="#footnote-21">9</a></sup> <sup class="footnote-reference" id="fr-16-1"><a href="#footnote-16">10</a></sup>.</p>
<p>Go is a new systems programming language created by Google. Go has strong
typing; language level support for concurrency; inter-process communication via
channels, a la Occam<sup class="footnote-reference" id="fr-13-1"><a href="#footnote-13">11</a></sup>, Limbo<sup class="footnote-reference" id="fr-17-1"><a href="#footnote-17">12</a></sup>, and Alef<sup class="footnote-reference" id="fr-27-1"><a href="#footnote-27">13</a></sup>; runtime type safety and
other protective measures; dynamic allocation and garbage collection; closures;
and a package syntax, similar to Java, that makes it easy to determine what
packages a given program needs. The modern language constructs make Go a much
safer language than C. This safety is critical for network-attached embedded
systems, which usually have network utilities written in C, including web
servers, network servers including sshd, and programs that provide access to a
command interpreter, itself written in C. All are proving to be vulnerable to
the attack-rich environment that the Internet has become. Buffer overflow
attacks affecting C-based firmware code (among other things) in 2015 include
GHOST and the so-called FSVariable.c bug in Intel’s UEFI firmware. Buffer
overflows in Intel’s UEFI and Active Management Technology (AMT) have also been
discovered in several versions in recent years.</p>
<p>Both UEFI<sup class="footnote-reference" id="fr-12-1"><a href="#footnote-12">14</a></sup> and AMT<sup class="footnote-reference" id="fr-4-1"><a href="#footnote-4">15</a></sup> are embedded operating systems, loaded from flash that
run network-facing software. Attacks against UEFI have been extensively
studied<sup class="footnote-reference" id="fr-9-1"><a href="#footnote-9">16</a></sup>. Most printers are network-attached and are a very popular
exploitation target<sup class="footnote-reference" id="fr-6-1"><a href="#footnote-6">17</a></sup>. Firmware is not visible to most users and is updated
much less frequently (if at all) than programs. It is the first software to
run, at power on reset. Exploits in firmware are extremely difficult to detect,
because firmware is designed to be as invisible as possible. Firmware is
extremely complex; UEFI is roughly equivalent in size and capability to a Unix
kernel. Firmware is usually closed and proprietary, with nowhere near the level
of testing of kernels. These properties make firmware an ideal place for
so-called advanced persistent threats<sup class="footnote-reference" id="fr-10-1"><a href="#footnote-10">18</a></sup> <sup class="footnote-reference" id="fr-18-1"><a href="#footnote-18">19</a></sup> <sup class="footnote-reference" id="fr-5-1"><a href="#footnote-5">20</a></sup>. Once an exploit is
installed, it is almost impossible to remove, since the exploit can inhibit its
removal by corrupting the firmware update process. The only sure way to mitigate
a firmware exploit is to destroy the hardware.</p>
<p>U-root is an excellent option for embedded systems. U-root contains only 5
binaries, 4 of them from the Go toolchain, and the 5th is an init binary. The
rest of the programs are contained in BIOS flash in source form, including
packages. The search path is arranged so that when a command is invoked, if it
is not in <code>/bin</code>, an installer is invoked instead which compiles the program
into <code>/bin</code>. If the build succeeds, the command is executed. This first
invocation takes a fraction of a second, depending on program complexity. After
that, the RAM-based, statically linked binaries run in about a millisecond.
Scripts are written in Go, not a shell scripting language, with two benefits:
the shell can be simple, with fewer corner cases, and the scripting environment
is substantially improved since Go is more powerful than most shell scripting
languages, but also less fragile and less prone to parsing bugs.</p>
<h2 id="u-root-design"><a class="header" href="#u-root-design">U-root design</a></h2>
<p>The u-root boot image is a build toolchain and a set of programs in source
form. When first used, a program and any needed but not-yet-built packages are
built and installed, typically in a fraction of a second. With later uses, the
binary is executed. The root file system is almost entirely unformed on boot;
<code>/init</code> sets up the key directories and mounts, including common ones such as
<code>/etc</code> and <code>/proc</code>.</p>
<p>Since the init program itself is only 132 lines of code and is easy to change,
the structure is very flexible and allows for many use cases, for example:</p>
<ul>
<li>Additional binaries: if the 3 seconds it takes to get to a shell is too
long (some applications such as automotive computing require 800 ms startup
time), and there is room in flash, some programs can be precompiled into /bin.</li>
<li>Build it all on boot: if on-demand compilation is not desired, a background
thread in the init process can build all the programs on boot.</li>
<li>Selectively remove binaries after use: if RAM space is at a premium, once
booted, a script can remove everything in <code>/bin</code>. Utilities or commands
that are used will be rebuilt on demand.</li>
<li>Always build on demand: run in a mode in which programs are never written
to <code>/bin</code> and always rebuilt on demand. This is a very practical option
given that program compilation is so fast.</li>
<li>Lockdown: if desired, the system can be locked down once booted in one of
several ways: the entire <code>/src</code> tree can be removed, for example, or just the
compiler toolchain can be deleted.</li>
</ul>
<h2 id="u-root-functionality"><a class="header" href="#u-root-functionality">U-root functionality</a></h2>
<p>U-root is packaged as an LZMA-compressed initial RAM file system (initramfs) in
cpio format. It is contained in a Linux compressed kernel image, also know as
bzImage. The bootloader (for example, syslinux) or firmware (for example,
coreboot) loads the bzImage into memory and starts it. The Linux kernel sets up
a RAM-based root file system and unpacks the u-root file system into it. This
initial root file system contains the Go toolchain (4 binaries), an init
binary, the u-root program source, and the entire Go source tree, which
provides packages needed for u-root programs.</p>
<p>All Unix systems start an init process on boot and u-root is no exception. The
init for u-root sets up some basic directories, symlinks, and files. It builds
a command installer and invokes the shell. This process is described in more
detail below. The boot file system layout is shown in Table 1.</p>
<p>The src directory is where programs and u-root packages reside. The go/bin
directory is for any Go tools built after boot; the go/pkg/tool directory
contains binaries for various architecture/kernel combinations. The directory
in which a compiler toolchain is placed provides information about the target
OS and architecture, for example, the Go build places binaries for Linux on x86
64 in <code>/go/pkg/tool/linux</code> <code>amd64/</code>. Note that there is no <code>/bin</code> or many of
the other directories expected in a root file system. The init binary builds
them. It creates an empty <code>/bin</code> which is filled with binaries on demand as
shown in Table 2.The u-root root file system has very little state.</p>
<p>For most programs to work, the file system must be more complete. Image space
is saved by having init create additional file system structure at boot time:
it fills in the missing parts of the root filesystem. It creates <code>/dev</code> and
<code>/proc</code> and mounts them. It creates an empty <code>/bin</code> which is filled with
binaries on demand.</p>
<p>In addition to <code>/bin</code>, there is a directory called <code>/buildbin</code>. <code>Buildbin</code> and
the correct setup of $PATH are the keys to making on-demand compilation work.
The init process sets $PATH to <code>/go/bin:/bin:/buildbin:/usr/local/bin</code>. Init
also builds <code>installcommand</code> using the Go bootstrap builder and creates a
complete set of symlinks. As a final step, init execs <code>sh</code>.</p>
<p>There is no <code>/bin/sh</code> at this point; the first <code>sh</code> found in $PATH is
<code>/buildbin/sh</code>. This is a symlink to <code>installcommand</code>. <code>Installcommand</code>, once
started, examines <code>argv[0]</code>, which is <code>sh</code>, and takes this as instruction to
build <code>/src/cmds/sh/.go</code> into <code>/bin</code> and then exec <code>/bin/sh</code>. There is no
difference between starting the first shell and any other program. Hence, part
of the boot process involves the construction of an installation tool to build
a binary for a shell which is then run.</p>
<p>If a user wants to examine the source to the shell, they can <code>cat</code>
<code>/src/cmds/sh/.go</code>. The <code>cat</code> command will be built and then show those files.
U-root is intended for network-based devices and hence good network
initialization code is essential. U-root includes a Go version of the IP and
DHCP programs, along with the docker netlink package and a DHCP package.</p>
<p>Table 1 below shows the initial layout of a u-root file system.</p>
<p>All Go compiler and runtime source is included under <code>/go/src</code>. All u-root
source is under <code>/src</code> and the compiler toolchain binaries are under <code>/go/pkg</code>.</p>
<div class="table-wrapper"><table><thead><tr><th>Directory</th><th style="text-align: center">Subdirectory</th><th style="text-align: left">Command</th></tr></thead><tbody>
<tr><td>/src</td><td style="text-align: center">cmds/</td><td style="text-align: left"></td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">builtin/builtin.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">/cat.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">/cmp.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">comm/comm.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">cp/cp.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">date/date.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">dmesg/dmesg.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">echo/echo.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">freq/freq.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">grep/grep.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">init/init.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">installcommand/installcommand.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">ip/ip.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">ldd/ldd.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">losetup/losetup.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">ls/ls.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">mkdir/mkdir.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">mount/mount.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">netcat/netcat.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">ping/ping.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">printenv/printenv.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">rm/rm.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">script/script.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">seq/seq.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">sh/{cd.go,parse.go,sh.go,time.go}</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">srvfiles/srvfiles.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">tcz/tcz.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">tee/tee.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">uniq/uniq.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">wc/wc.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">wget/wget.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">which/which.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">pkg/</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">dhcp/ (dhcp package source)</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">netlib/ (netlib package source)</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">golang.org (import package source)</td></tr>
<tr><td>/go</td><td style="text-align: center">src/</td><td style="text-align: left">Packages and toolchain</td></tr>
<tr><td></td><td style="text-align: center">pkg/</td><td style="text-align: left">tool/linux amd64/{6a,6c,6g,6l}</td></tr>
<tr><td></td><td style="text-align: center">misc/</td><td style="text-align: left">...</td></tr>
<tr><td></td><td style="text-align: center">tool/</td><td style="text-align: left">...</td></tr>
<tr><td></td><td style="text-align: center">bin/</td><td style="text-align: left">go</td></tr>
<tr><td></td><td style="text-align: center">include/</td><td style="text-align: left">...</td></tr>
<tr><td>/lib/</td><td style="text-align: center">libc.so</td><td style="text-align: left">Needed for tinycore linux packages</td></tr>
<tr><td></td><td style="text-align: center">libm.so</td><td style="text-align: left"></td></tr>
</tbody></table>
</div>
<p><strong>Table 1</strong>: Initial layout of a u-root filesystem</p>
<p>Table 2 below shows the layout after <code>/init</code> has run.</p>
<div class="table-wrapper"><table><thead><tr><th>Directory</th><th style="text-align: center">Subdirectory</th><th style="text-align: left">Command</th></tr></thead><tbody>
<tr><td>/src</td><td style="text-align: center">cmds/</td><td style="text-align: left"></td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">builtin/builtin.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">/cat.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">/cmp.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">comm/comm.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">cp/cp.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">date/date.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">dmesg/dmesg.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">echo/echo.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">freq/freq.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">grep/grep.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">init/init.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">installcommand/installcommand.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">ip/ip.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">ldd/ldd.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">losetup/losetup.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">ls/ls.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">mkdir/mkdir.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">mount/mount.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">netcat/netcat.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">ping/ping.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">printenv/printenv.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">rm/rm.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">script/script.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">seq/seq.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">sh/{cd.go,parse.go,sh.go,time.go}</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">srvfiles/srvfiles.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">tcz/tcz.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">tee/tee.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">uniq/uniq.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">wc/wc.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">wget/wget.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">which/which.go</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">pkg/</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">dhcp/ (dhcp package source)</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">netlib/ (netlib package source)</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: left">golang.org (import package source)</td></tr>
<tr><td>/go</td><td style="text-align: center">src/</td><td style="text-align: left">Packages and toolchain</td></tr>
<tr><td></td><td style="text-align: center">pkg/</td><td style="text-align: left">tool/linux amd64/{6a,6c,6g,6l}</td></tr>
<tr><td></td><td style="text-align: center">misc/</td><td style="text-align: left">...</td></tr>
<tr><td></td><td style="text-align: center">tool/</td><td style="text-align: left">...</td></tr>
<tr><td></td><td style="text-align: center">bin/</td><td style="text-align: left">go</td></tr>
<tr><td></td><td style="text-align: center">include/</td><td style="text-align: left">...</td></tr>
<tr><td>/lib/</td><td style="text-align: center">libc.so</td><td style="text-align: left">Needed for tinycore linux packages</td></tr>
<tr><td></td><td style="text-align: center">libm.so</td><td style="text-align: left"></td></tr>
</tbody></table>
</div>
<p><strong>Table 2</strong>: Layout after <code>/init</code> has run.</p>
<p><code>/buildbin</code> contains symlinks to enable the on-demand compilation, and other
standard directories and mount points are ready.</p>
<h2 id="the-u-root-shell"><a class="header" href="#the-u-root-shell">The u-root shell</a></h2>
<p>U-root provides a shell that is stripped down to the fundamentals: it can read
commands in using the Go scanner package; it can expand (that is, glob) the
command elements, using the Go filepath package, and it can run the resulting
commands, either programs or shell builtins. It supports pipelines and IO
redirection. At the same time, the shell defines no language of its own for
scripting and builtins. Instead, the u-root shell uses the Go compiler. In that
sense, the u-root shell reflects a break in important ways with the last few
decades of shell development, which has seen shells and their language grow
ever more complex and, partially as a result, ever more insecure<sup class="footnote-reference" id="fr-19-1"><a href="#footnote-19">21</a></sup> and
fragile<sup class="footnote-reference" id="fr-11-2"><a href="#footnote-11">7</a></sup>.</p>
<p>The shell has several builtin commands, and you can extend it with builtin
commands of your own. First, you need to understand the basic source structure
of u-root shell builtins. Then, you will learn about user-defined builtins.</p>
<p>All shell builtins, including the ones that come with the shell by default, are
written with a standard Go init pattern which installs one or more builtins.</p>
<p>Builtins in the shell are defined by a name and a function. One or more
builtins can be described in a source file. The name is kept in a map and the
map is searched for a command name before looking in the file system. The
function must accept a string as a name and a (possibly zero-length) array of
string arguments, and return an error. In order to connect the builtin to the
map, a programmer must provide an <code>init</code> function which adds the name and
function to the map. The <code>init</code> function is special in that it is run by Go
when the program starts up. In this case, the <code>init</code> function just installs a
builtin for the time command.</p>
<p>Figure 1 and Figure 2 below show the shell builtin for time.</p>
<pre><code class="language-go">// Package main is the 'root' of the package hierarchy for a program.
// This code is part of the main program, not another package,
// and is declared as package main.

package main

// A Go source file list all the packages on which it has a direct
// dependency.

import (
  "fmt"
  "os"
  "time"
  )

// init() is an optional function. If init () is present in a file,
// the Go compiler and runtime arrange for it to be called at
// program startup. It is therefore like a constructor.

func init () {
    // addBuiltIn is provided by the u−root shell for the addition of
    // builtin commands. Builtins must have a standard type:
    // - The first parameter is a string
    // - The second is a string array which may be 0 length
    // - The return is the Go error type
    // In this case, we are creating a builtincalled time that calls
    // the timecmd function.

  addBuiltIn ( "time " , timecmd )
  }
</code></pre>
<p><strong>Figure 1</strong>: The code for the time builtin, Part I: setup</p>
<pre><code class="language-go">// The timecmd function is passed the name of a command to run,
// optional arguments, and returns an error. It:
// - gets the starttime using Now from the time package
// - runs the command using the u−root shell runit function
// - computes a duration using Since from the time package
// - if there is an error, prints the error to os.Stderr
// - uses fmt. Printf to print the duration to os.Stderr
// Note that since runtime always handles the error, by printing
// it, it always returns nil. Most builtins return the error.
// Here you can see the usage of the imported packages
// from the imports statement above.

func timecmd (name string, args [] string )
error {
      start: = time. Now ()
      err := run it (name, args)
        if err != nil {

      fmt. Fprintf (os. Stderr, ”%v\n”, err)

  }
  cost := time . Since (start)
  fmt.Printf(os.Stderr, ”%v ”,cost)

    // This function is special in that it handles the error, and hence
    // does not return an error.
    // Most other builtins return the error.

  return nil
  }

</code></pre>
<p><strong>Figure 2</strong>: The code for the shell time builtin, Part II</p>
<h2 id="scripting-and-builtins"><a class="header" href="#scripting-and-builtins">Scripting and builtins</a></h2>
<p>To support scripting and builtins, u-root provides two programs: script and
builtin. The script program allows users to specify a Go fragment on the
command line, and runs that fragment as a program. The builtin program allows a
Go fragment to be built into the shell as a new command. Builtins are
persistent; the builtin command instantiates a new shell with the new command
built in. Scripts run via the script command are not persistent.</p>
<p>A basic hello builtin can be defined on the command line:</p>
<pre><code>builtin hello '{ fmt.Printf("Hello\n") }'
</code></pre>
<p>The fragment is defined by the {} pair. Given a fragment that starts with a {,
the builtin command generates all the wrapper boiler plate needed. The builtin
command is slightly different from the script command in that the Go fragment
is bundled into one argument. The command accepts multiple pairs of command
name and Go code fragments, allowing multiple new builtin commands to be
installed in the shell.</p>
<p>Builtin creates a new shell at <code>/bin/sh</code> with the source at <code>/src/cmds/sh/</code>.
Invocations of <code>/bin/sh</code> by this shell and its children will use the new shell.</p>
<p>Processes spawned by this new shell can access the new shell source and can run
the builtin command again and create a shell that further extends the new
shell. Processes outside the new shell’s process hierarchy can not use this new
shell or the builtin source. When the new shell exits, the builtins are no
longer visible in any part of the file system. We use Linux mount name spaces
to create this effect<sup class="footnote-reference" id="fr-22-1"><a href="#footnote-22">22</a></sup>. Once the builtin command has verified that the Go
fragment is valid, it builds a new, private namespace with the shell source,
including the new builtin source. From that point on, the new shell and its
children will only use the new shell. The parent process and other processes
outside the private namespace continue to use the old shell.</p>
<p>Figure 3 below shows an example usage of the script command.</p>
<p>This script implements printenv. Note that it is not a complete Go program in
that it lacks a package statement, imports, a main function declaration, and a
return at the end. All the boilerplate is added by the script command, which
uses the Go imports package to scan the code and create the import statements
required for compilation (in this case, both fmt and os packages are imported).
Because the u-root shell is so simple, there is no need to escape many of these
special characters. The complex parsing tasks have been offloaded to Go.
Builtins are implemented in almost the same way. The builtin command takes the
Go fragment and creates a standard shell builtin Go source file which conforms
to the builtin pattern. This structure is easy to generate programmatically,
building on the techniques used for the script command.</p>
<pre><code>script{ fmt.Printf("%v\n", os.Environ()) }
</code></pre>
<p><strong>Figure 3</strong>: Go fragment for a printenv script. Code structure is inserted and
packages are determined automatically.</p>
<h2 id="environment-variables"><a class="header" href="#environment-variables">Environment variables</a></h2>
<p>The u-root shell supports environment variables, but manages them differently
than most Unix environments. The variables are maintained in a directory called
<code>/env</code>; the file name corresponds to the environment variable name, and the
files contents are the value. When it is starting a new process, the shell
populates child process environment variables from the <code>/env</code> directory. The
syntax is the same; $ followed by a name directs the shell to substitute the
value of the variable in the argument by prepending <code>/env</code> to the path and
reading the file.</p>
<p>The shell variables described above are relative paths; <code>/env</code> is prepended to
them. In the u-root shell, the name can also be an absolute path. For example,
the command script $<code>/home/$USER/scripts/hello</code> will substitute the value of
the <code>hello</code> script into the command line and then run the script command. The
ability to place arbitrary text from a file into an argument is proving to be
extremely convenient, especially for script and builtin commands.</p>
<h2 id="using-external-packages-and-programs"><a class="header" href="#using-external-packages-and-programs">Using external packages and programs</a></h2>
<p>No root file system can provide all the packages all users want, and u-root is
no exception. You need to have the ability to load external packages from
popular Linux distros. The <code>tcz</code> command can be used to load external packages
from the TinyCore Linux distribution, also known as <em>tinycore</em>. A tinycore
package is a mountable file system image, containing all the package files,
including a file listing any additional package dependencies. To load these
packages, u-root provides the <code>tcz</code> command which fetches the package and
needed dependencies. Hence, if a user wants emacs, they need merely type <code>tcz emacs</code>, and emacs will become available in <code>/usr/local/bin</code>. The tinycore
packages directory can be a persistent directory or it can be empty on each
boot.</p>
<p>The <code>tcz</code> command is quite flexible as to what packages it loads and where they
are loaded from. Users can specify the host name which provides the packages,
the TCP port on which to connect, the version of tinycore to use, and the
architecture. The <code>tcz</code> command must loopback mount each package as it is
fetched, and hence must cache them locally. It will not refetch already cached
packages. This cache can be volatile or maintained on more permanent storage.
Performance varies depending on the network being used and the number of
packages being loaded, but averages about 1 second per package on a
WIFI-attached laptop. U-root also provides a small web server, called
<em>srvfiles</em>, that can be used to serve locally cached tinycore packages for
testing. The entire server is 18 lines of Go.</p>
<h2 id="on-demand-compilation"><a class="header" href="#on-demand-compilation">On-Demand Compilation</a></h2>
<p>On-Demand compilation is one of the oldest ideas in computer science.
Slimline Open Firmware (SLOF)<sup class="footnote-reference" id="fr-7-1"><a href="#footnote-7">23</a></sup> is a FORTHbased implementation of Open
Firmware developed by IBM for some of its Power and Cell processors. SLOF is
capable of storing all of Open Firmware as source in the flash memory and
compiling components to indirect threading on demand<sup class="footnote-reference" id="fr-2-1"><a href="#footnote-2">24</a></sup>.</p>
<p>In the last few decades, as our compiler infrastructure has gotten slower and
more complex, true on-demand compilation has split into two different forms.
First is the on-demand compilation of source into executable byte codes, as in
Python. The byte codes are not native but are more efficient than source. If
the python interpreter finds the byte code it will interpret that instead of
source to provide improved performance. Java takes the process one step further
with the Just In Time compilation of byte code to machine code<sup class="footnote-reference" id="fr-20-1"><a href="#footnote-20">25</a></sup> to boost
performance.</p>
<h2 id="embedding-kernel-and-root-file-systems-in-flash"><a class="header" href="#embedding-kernel-and-root-file-systems-in-flash">Embedding kernel and root file systems in flash</a></h2>
<p>The LinuxBIOS project<sup class="footnote-reference" id="fr-14-2"><a href="#footnote-14">4</a></sup> <sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">26</a></sup>, together with clustermatic<sup class="footnote-reference" id="fr-25-2"><a href="#footnote-25">3</a></sup>, used an embedded
kernel and simple root file system to manage supercomputing clusters. Due to
space constraints of 1 MiB or less of flash, clusters embedded only a
single-processor Linux kernel with a daemon. The daemon was a network
bootloader that downloaded a more complex SMP kernel and root file system and
started them. Clusters built this way were able to boot 1024 nodes in the time
it took the standard PXE network boot firmware to find a working network
interface.</p>
<p>Early versions of One Laptop Per Child used LinuxBIOS, with Linux in flash as a
boot loader, to boot the eventual target. This system was very handy, as they
were able to embed a full WIFI stack in flash with Linux, and could boot test
OLPC images over WIFI. The continuing growth of the Linux kernel, coupled with
the small flash size on OLPC, eventually led OLPC to move to Open Firmware.</p>
<p>AlphaPower shipped their Alpha nodes with a so-called Direct Boot Linux, or
DBLX. This work was never published, but the code was partially released on
sourceforge.net just as AlphaPower went out of business.  Compaq also worked
with a Linux-As-Bootloader for the iPaq.</p>
<p>Car computers and other embedded ARM systems frequently contain a kernel and an
ext2 formatted file system in NOR flash, that is, flash that can be treated as
memory instead of a block device. Many of these kernels use the so-called
eXecute In Place<sup class="footnote-reference" id="fr-3-1"><a href="#footnote-3">27</a></sup> (XIP) patch, which allows the kernel to page binaries
directly from the memory-addressable flash rather than copying it to RAM,
providing a significant savings in system startup time. A downside of this
approach is that the executables can not be compressed, which puts further
pressure on the need to optimize binary size. NOR flash is very slow, and
paging from it comes at a significant performance cost. Finally, an
uncompressed binary image stored in NOR flash has a much higher monetary cost
than the same image stored in RAM since the cost per bit is so much higher.</p>
<p>UEFI<sup class="footnote-reference" id="fr-12-2"><a href="#footnote-12">14</a></sup> contains a non-Linux kernel (the UEFI firmware binary) and a full set
of drivers, file systems, network protocol stacks, and command binaries in the
firmware image. It is a full operating system environment realized as firmware.</p>
<p>The ONIE project<sup class="footnote-reference" id="fr-23-2"><a href="#footnote-23">5</a></sup> is a more recent realization of the Kernel-in-flash idea,
based on Linux. ONIE packs a Linux kernel and Busybox binaries into a very
small package. Since the Linux build process allows an initial RAM file system
(initramfs) to be built directly into the kernel binary, some companies are now
embedding ONIE images into flash with coreboot. Sage Engineering has shown a
bzImage with a small Busybox packed into a 4M image. ONIE has brought new life
to an old idea: packaging a kernel and small set of binaries in flash to create
a fast, capable boot system.</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<hr>
<ol class="footnote-definition"><li id="footnote-24">
<p>VARIOUS. No papers were published; see perllinux.sourceforge.net. <a href="#fr-24-1">↩</a> <a href="#fr-24-2">↩2</a></p>
</li>
<li id="footnote-26">
<p>WELLS, N. Busybox: A swiss army knife for linux. Linux J. 2000, 78es
(Oct. 2000). <a href="#fr-26-1">↩</a> <a href="#fr-26-2">↩2</a></p>
</li>
<li id="footnote-25">
<p>WATSON, G. R., SOTTILE, M. J., MINNICH, R. G., CHOI, S.-E., AND
HERTDRIKS, E. Pink: A 1024-node single-system image linux cluster. In High
Performance Computing and Grid in Asia Pacific Region, 2004. Proceedings.
Seventh International Conference on (2004), IEEE, pp. 454–461. <a href="#fr-25-1">↩</a> <a href="#fr-25-2">↩2</a></p>
</li>
<li id="footnote-14">
<p>MINNICH, R. G. Linuxbios at four. Linux J. 2004, 118 (Feb. 2004), 8–. <a href="#fr-14-1">↩</a> <a href="#fr-14-2">↩2</a></p>
</li>
<li id="footnote-23">
<p>VARIOUS. No papers have been published on onie; see onie.org. <a href="#fr-23-1">↩</a> <a href="#fr-23-2">↩2</a></p>
</li>
<li id="footnote-15">
<p>MOON, S.-P., KIM, J.-W., BAE, K.-H., LEE, J.-C., AND SEO, D.-W. Embedded
linux implementation on a commercial digital tv system. Consumer
Electronics, IEEE Transactions on 49, 4 (Nov 2003), 1402–1407. <a href="#fr-15-1">↩</a></p>
</li>
<li id="footnote-11">
<p>KOZIOL, J., LITCHFIELD, D., AITEL, D., ANLEY, C., EREN, S., MEHTA, N.,
AND HASSELL, R. The Shellcoder’s Handbook. Wiley Indianapolis, 2004. <a href="#fr-11-1">↩</a> <a href="#fr-11-2">↩2</a></p>
</li>
<li id="footnote-8">
<p>DURUMERIC, Z., KASTEN, J., ADRIAN, D., HALDERMAN, J. A., BAILEY, M., LI,
F., WEAVER, N., AMANN, J., BEEKMAN, J., PAYER, M., ET AL. The matter of
heartbleed. In Proceedings of the 2014 Conference on Internet Measurement
Conference (2014), ACM, pp. 475–488. <a href="#fr-8-1">↩</a></p>
</li>
<li id="footnote-21">
<p>TEAM, G. The go programming language specification. Tech. rep.,
Technical Report <a href="http://golang/">http://golang</a>. org/doc/doc/go spec.
html, Google Inc, 2009. <a href="#fr-21-1">↩</a></p>
</li>
<li id="footnote-16">
<p>PIKE, R. Another go at language design. Stanford University Computer
Systems Laboratory Colloquium. <a href="#fr-16-1">↩</a></p>
</li>
<li id="footnote-13">
<p>MAY,D.Occam.ACMSigplanNotices18,4(1983),69–79. <a href="#fr-13-1">↩</a></p>
</li>
<li id="footnote-17">
<p>RITCHIE, D. M. The limbo programming language. Inferno Programmer’s
Manual 2 (1997). <a href="#fr-17-1">↩</a></p>
</li>
<li id="footnote-27">
<p>WINTERBOTTOM, P. Alef language reference manual. Plan 9 Programmer’s Man
(1995). <a href="#fr-27-1">↩</a></p>
</li>
<li id="footnote-12">
<p>LEWIS, T. Uefi overview, 2007. <a href="#fr-12-1">↩</a> <a href="#fr-12-2">↩2</a></p>
</li>
<li id="footnote-4">
<p>BOGOWITZ, B., AND SWINFORD, T. Intel⃝R active management technology
reduces it costs with improved pc manageability. Technology@ Intel Magazine
(2004). <a href="#fr-4-1">↩</a></p>
</li>
<li id="footnote-9">
<p>KALLENBERG, C., AND BULYGIN, Y. All your boot are belong to us intel,
mitre. cansecwest 2014. <a href="#fr-9-1">↩</a></p>
</li>
<li id="footnote-6">
<p>CUI, A., COSTELLO, M., AND STOLFO, S. J. When firmware modifications
attack: A case study of embedded exploitation. In NDSS (2013). <a href="#fr-6-1">↩</a></p>
</li>
<li id="footnote-10">
<p>KALLENBERG, C., KOVAH, X., BUTTERWORTH, J., AND CORNWELL, S. Extreme
privilege escalation on windows 8/uefi systems. <a href="#fr-10-1">↩</a></p>
</li>
<li id="footnote-18">
<p>SACCO, A. L., AND ORTEGA, A. A. Persistent bios infection. In CanSecWest
Applied Security Conference (2009). <a href="#fr-18-1">↩</a></p>
</li>
<li id="footnote-5">
<p>CELEDA, P., KREJCI, R., VYKOPAL, J., AND DRASAR, M. Embedded malware-an
analysis of the chuck norris botnet. In Computer Network Defense (EC2ND),
2010 European Conference on (2010), IEEE, pp. 3–10. <a href="#fr-5-1">↩</a></p>
</li>
<li id="footnote-19">
<p>SAMPATHKUMAR, R. Vulnerability Management for Cloud Computing-2014: A
Cloud Computing Security Essential. Rajakumar Sampathkumar, 2014. <a href="#fr-19-1">↩</a></p>
</li>
<li id="footnote-22">
<p>VAN HENSBERGEN, E., AND MINNICH, R. Grave robbers from outer space:
Using 9p2000 under linux. In USENIX Annual Technical Conference, FREENIX
Track (2005), pp. 83–94. <a href="#fr-22-1">↩</a></p>
</li>
<li id="footnote-7">
<p>DALY, D., CHOI, J. H., MOREIRA, J. E., AND WATERLAND, A. Base operating
system provisioning and bringup for a commercial supercomputer. In Parallel
and Distributed Processing Symposium, 2007. IPDPS 2007. IEEE International
(2007), IEEE, pp. 1–7. <a href="#fr-7-1">↩</a></p>
</li>
<li id="footnote-2">
<p>(AUTHOR OF SLOF), S. B. Personal conversation. <a href="#fr-2-1">↩</a></p>
</li>
<li id="footnote-20">
<p>SUGANUMA, T., OGASAWARA, T., TAKEUCHI, M., YASUE, T., KAWAHITO, M.,
ISHIZAKI, K., KOMATSU, H., AND NAKATANI, T. Overview of the ibm java
just-in-time compiler. IBM systems Journal 39, 1 (2000), 175–193. <a href="#fr-20-1">↩</a></p>
</li>
<li id="footnote-1">
<p>AGNEW, A., SULMICKI, A., MINNICH, R., AND ARBAUGH, W. A. Flexibility in
rom: A stackable open source bios. In USENIX Annual Technical Conference,
FREENIX Track (2003), pp. 115–124. <a href="#fr-1-1">↩</a></p>
</li>
<li id="footnote-3">
<p>BENAVIDES, T., TREON, J., HULBERT, J., AND CHANG, W. The enabling of an
execute-in-place architecture to reduce the embedded system memory
footprint and boot time. Journal of computers 3, 1 (2008), 79–89. <a href="#fr-3-1">↩</a></p>
</li>
</ol>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="tools-evaluation.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="u-root-qemu-demo.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="tools-evaluation.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="u-root-qemu-demo.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>


    </div>
    </body>
</html>
