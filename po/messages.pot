
msgid ""
msgstr ""
"Project-Id-Version: LinuxBoot\n"
"POT-Creation-Date: 2025-05-22T11:08:57+08:00\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: en\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/SUMMARY.md:1 src/intro.md:1
msgid "LinuxBoot Introduction"
msgstr ""

#: src/SUMMARY.md:2 src/use-cases.md:1
msgid "Use cases"
msgstr ""

#: src/SUMMARY.md:3
msgid "Talks and news coverage"
msgstr ""

#: src/SUMMARY.md:4 src/components.md:1
msgid "LinuxBoot Components"
msgstr ""

#: src/SUMMARY.md:5 src/tools-evaluation.md:1
msgid "Evaluation of tools"
msgstr ""

#: src/SUMMARY.md:6 src/petitboot.md:1
msgid "Petitboot"
msgstr ""

#: src/SUMMARY.md:7
msgid "OpenPOWER"
msgstr ""

#: src/SUMMARY.md:8
msgid "ODROID"
msgstr ""

#: src/SUMMARY.md:9 src/u-root.md:1
msgid "All about u-root"
msgstr ""

#: src/SUMMARY.md:10 src/u-root-qemu-demo.md:1
msgid "u-root demo with QEMU"
msgstr ""

#: src/SUMMARY.md:11
msgid "LinuxBoot utilities"
msgstr ""

#: src/SUMMARY.md:12 src/utilities/UEFI_Tool_Kit.md:1
msgid "UEFI Tool Kit"
msgstr ""

#: src/SUMMARY.md:13
msgid "The magical cpu command"
msgstr ""

#: src/SUMMARY.md:14
msgid "Device Under Test"
msgstr ""

#: src/SUMMARY.md:15 src/implementation.md:1
msgid "Implementing LinuxBoot"
msgstr ""

#: src/SUMMARY.md:16 src/coreboot.u-root.systemboot/index.md:1
msgid "LinuxBoot using coreboot, u-root and systemboot"
msgstr ""

#: src/SUMMARY.md:17 src/glossary.md:1
msgid "Glossary"
msgstr ""

#: src/SUMMARY.md:18 src/history.md:1
msgid "History"
msgstr ""

#: src/SUMMARY.md:19 src/case_studies/index.md:1
msgid "Case Studies"
msgstr ""

#: src/SUMMARY.md:20
msgid "Ampere study"
msgstr ""

#: src/SUMMARY.md:21
msgid "Google study"
msgstr ""

#: src/SUMMARY.md:22
msgid "OCP TiogaPass"
msgstr ""

#: src/SUMMARY.md:23
msgid "Frequently Asked Questions"
msgstr ""

#: src/intro.md:3
msgid ""
"This is the official “LinuxBoot Book” for the LinuxBoot project. The book:"
msgstr ""

#: src/intro.md:5
msgid "Describes the LinuxBoot project"
msgstr ""

#: src/intro.md:6
msgid "Explains why you would want to use LinuxBoot"
msgstr ""

#: src/intro.md:7
msgid "Describes the components that comprise LinuxBoot"
msgstr ""

#: src/intro.md:8
msgid "Highlights the differences between other boot processes and LinuxBoot"
msgstr ""

#: src/intro.md:9
msgid "Guides you through the steps needed to implement LinuxBoot"
msgstr ""

#: src/intro.md:11
msgid "What is LinuxBoot?"
msgstr ""

#: src/intro.md:13
msgid ""
"LinuxBoot is the idea of replacing proprietary or corporate-driven "
"late-stage boot [firmware](./glossary.md) with the Linux kernel and a "
"community-based user-space. That idea grew into a project that over the "
"years includes various initiatives with the overarching goal of moving from "
"obscure and complex firmware to simpler and open source firmware."
msgstr ""

#: src/intro.md:19
msgid ""
"The LinuxBoot project provides two reference implementations; `linuxboot` "
"and Heads. The [`linuxboot`](https://github.com/linuxboot/linuxboot) build "
"system outputs a boot payload consisting of a Linux kernel and an "
"[initramfs](https://de.wikipedia.org/wiki/Initramfs) that contains a minimal "
"Go user-space built using [u-root](https://github.com/u-root/u-root)."
msgstr ""

#: src/intro.md:25
msgid ""
"The Heads build system is more focused on local attestation, TPM DUK "
"seal/unseal operations, GPG-based security measurement, reproducible builds "
"and uses BusyBox to provide a much larger suite of Linux tools allowing it "
"to also be used as a recovery environment."
msgstr ""

#: src/intro.md:30
msgid "Many other implementations exist independently of the project:"
msgstr ""

#: src/intro.md:32
msgid ""
"[petitboot](https://github.com/open-power/petitboot) under the OpenPOWER "
"project originally targeting the PS3"
msgstr ""

#: src/intro.md:34
msgid ""
"[k-boot](https://github.com/BayLibre/k-boot) developed by BayLibre in 2023 "
"using BusyBox"
msgstr ""

#: src/intro.md:36
msgid "[nmbl](https://github.com/rhboot/nmbl-poc) developed by RedHat in 2024"
msgstr ""

#: src/intro.md:37
msgid "[ZFSBootMenu](https://docs.zfsbootmenu.org/en/latest)"
msgstr ""

#: src/intro.md:39
msgid ""
"And there is a long history of similar implementations including projects "
"that are no longer maintained:"
msgstr ""

#: src/intro.md:42
msgid ""
"MILO on Alpha started before 2000 (see [What is "
"MILO?](https://tldp.org/HOWTO/MILO-HOWTO/what-section.html))"
msgstr ""

#: src/intro.md:44
msgid "kboot developed by Werner Almesberger in 2005"
msgstr ""

#: src/intro.md:46
msgid ""
"These projects all attempt to reduce the role of firmware to a small, "
"fixed-function core whose only purpose is to get a flash-based Linux kernel "
"started. This “bare essentials” firmware prepares the hardware and starts a "
"Linux kernel and a user-space environment will run on the machine. Go is the "
"recommended user-space environment, but is not required."
msgstr ""

#: src/intro.md:52
msgid "Why LinuxBoot is needed"
msgstr ""

#: src/intro.md:54
msgid ""
"Sometimes firmware contains drivers and utilities. They can have bugs, or be "
"unmaintained, which can be a source of problems and security issues. "
"LinuxBoot replaces proprietary, closed-source, vendor-supplied firmware "
"drivers with Linux drivers. This enables engineers writing Linux drivers and "
"engineers writing firmware drivers to focus on one set of drivers. Those "
"drivers will, as a result, have a larger set of contributors and reviewers, "
"and because the drivers are part of Linux, standard industry coding "
"infrastructure can be used to improve them. Finally, because these Linux "
"drivers are currently being run around the clock at scale, they will have "
"fewer bugs."
msgstr ""

#: src/intro.md:64
msgid "What LinuxBoot does"
msgstr ""

#: src/intro.md:66
msgid ""
"LinuxBoot replaces many Driver Execution Environment (DXE) modules used by "
"Unified Extensible Firmware Interface (UEFI) and other firmware, "
"particularly the network stack and file system modules, with Linux "
"applications."
msgstr ""

#: src/intro.md:70
msgid ""
"LinuxBoot brings up the Linux kernel as a DXE in flash ROM instead of the "
"UEFI shell. The Linux kernel, with a provided Go based user-space, can then "
"load the runtime kernel. The LinuxBoot paradigm enables writing traditional "
"firmware applications such as boot loader, debugging, diagnosis, and error "
"detection applications as cross-architecture and cross-platform portable "
"Linux applications."
msgstr ""

#: src/intro.md:77
msgid ""
"When Linux boots it needs a root file system with utilities. One such root "
"filesystem used for LinuxBoot is based on u-root standard utilities written "
"in Go. The following diagram shows the current state of the UEFI boot "
"process and what is planned for the transition to LinuxBoot."
msgstr ""

#: src/intro.md:82
msgid ""
"[![comparison of UEFI boot and "
"LinuxBoot](./images/UEFI-versus-LinuxBoot.svg)](./images/UEFI-versus-LinuxBoot.svg)"
msgstr ""

#: src/intro.md:84
msgid "Benefits of using the Go user-space environment and compiler"
msgstr ""

#: src/intro.md:86
msgid ""
"Go is a systems programming language created by Google. Go has strong "
"typing, language level support for concurrency, inter-process communication "
"via channels, runtime type safety and other protective measures, dynamic "
"allocation and garbage collection, and closures. Go has a package name "
"notation similar to Java that makes it clear to determine what packages a "
"given program needs."
msgstr ""

#: src/intro.md:92
msgid ""
"The modern language constructs make Go a much safer language than C. This "
"safety is critical for network-attached embedded systems, which usually have "
"network utilities written in C, including web servers, network servers "
"including `sshd`, and programs that provide access to a command interpreter, "
"itself written in C. All are proving to be vulnerable to the attack-rich "
"environment that the Internet has become."
msgstr ""

#: src/intro.md:99
msgid ""
"Even the most skilled programmers can make mistakes that in C can be "
"unrecoverable, especially on network connected systems. Currently, even the "
"lowest-level firmware in our PCs, printers, and thermostats is "
"network-connected. These programming mistakes are either impossible to make "
"in Go or, if made, are detected at runtime and result in the program exiting."
msgstr ""

#: src/intro.md:105
msgid ""
"The case for using a high-level, safe language like Go in low level embedded "
"firmware might be stronger than for user programs, because exploits at the "
"firmware level are nearly impossible to detect and mitigate."
msgstr ""

#: src/intro.md:109
msgid ""
"The challenge to using Go in a storage-constrained environment such as "
"firmware is that advanced language features lead to big binaries. Even a "
"date program is about 2 MiB. One Go binary, implementing one function, is "
"twice as large as a BusyBox binary implementing many functions. Currently, a "
"typical BIOS FLASH part is 16 MiB. Fitting many Go binaries into a single "
"BIOS flash part is not practical. The Go compiler is fast and its sheer "
"speed suggests a solution of having programs compiled only when they are "
"used. With this approach, you can build a root file system that has almost "
"no binaries except the Go compiler itself. The compiled programs and "
"packages can be saved to a RAM-based file system. Another solution is to "
"compile everything together into one BusyBox-style program. Alternatively, "
"programs can be fetched over the network, but compiling dynamically with Go "
"or creating a BusyBox program are the recommended solutions."
msgstr ""

#: src/intro.md:123
msgid "Benefits of LinuxBoot with UEFI servers"
msgstr ""

#: src/intro.md:125
msgid ""
"Most server firmware is based on Intel’s Universal Extensible Firmware "
"Interface (UEFI). LinuxBoot provides the following benefits over UEFI:"
msgstr ""

#: src/intro.md:128
msgid "Reliability"
msgstr ""

#: src/intro.md:130
msgid ""
"Improves boot reliability by replacing lightly-tested firmware drivers with "
"hardened Linux drivers"
msgstr ""

#: src/intro.md:132
msgid ""
"Proven approach for almost 20 years in military, consumer electronics, and "
"supercomputers – wherever reliability and performance are paramount"
msgstr ""

#: src/intro.md:134
msgid ""
"Fault Tolerance - Linux isolates processes\\*\\* \\*\\*(for example, when "
"`pxeboot` fails catastrophically, `diskboot` still works afterwards)"
msgstr ""

#: src/intro.md:137
msgid "Security"
msgstr ""

#: src/intro.md:139
msgid "Move “Ring 0” boot loaders to “Ring 3”"
msgstr ""

#: src/intro.md:140
msgid "`pxeboot` and `diskboot` do parsing and other logic in user-space"
msgstr ""

#: src/intro.md:141
msgid "Go provides memory safety and type safety"
msgstr ""

#: src/intro.md:142
msgid "A buggy parser is much less likely to affect other programs"
msgstr ""

#: src/intro.md:143
msgid "Kernel security patches can apply to firmware"
msgstr ""

#: src/intro.md:145
msgid "Flexibility"
msgstr ""

#: src/intro.md:147
msgid ""
"Can be used with coreboot, u-boot, OpenPOWER Abstraction Layer (OPAL), "
"SlimBootLoader, ARM Trusted Firmware (ATF)"
msgstr ""

#: src/intro.md:149
msgid ""
"Can boot multiple operating systems (Linux, Berkeley UNIX (BSD), XEN, "
"Windows)"
msgstr ""

#: src/intro.md:151
msgid "Supports the following server mainboards:"
msgstr ""

#: src/intro.md:152
msgid "QEMU emulated Q35 systems"
msgstr ""

#: src/intro.md:153
msgid "[Intel S2600WF](https://trmm.net/S2600wf)"
msgstr ""

#: src/intro.md:154
msgid "[Dell R630](https://trmm.net/NERF)"
msgstr ""

#: src/intro.md:155
msgid "Winterfell Open Compute node"
msgstr ""

#: src/intro.md:156
msgid "Leopard Open Compute node"
msgstr ""

#: src/intro.md:157
msgid "Tioga Pass Open Compute node"
msgstr ""

#: src/intro.md:158
msgid "Monolake Open Compute node (not tested)"
msgstr ""

#: src/intro.md:160
msgid "Boot speed"
msgstr ""

#: src/intro.md:162
msgid ""
"Improves boot time by removing unnecessary code; typically makes boot 20 "
"times faster"
msgstr ""

#: src/intro.md:165
msgid "Customization"
msgstr ""

#: src/intro.md:167
msgid ""
"Allows customization of the initramfs runtime to support site-specific needs "
"(both device drivers as well as custom executables)"
msgstr ""

#: src/intro.md:170
msgid "Engineering Productivity"
msgstr ""

#: src/intro.md:172
msgid "Write a driver once, not twice"
msgstr ""

#: src/intro.md:173
msgid ""
"Linux is **open, measurable, reproducible, and straightforward to update**"
msgstr ""

#: src/intro.md:174
msgid "Linux already has drivers for almost everything"
msgstr ""

#: src/intro.md:175
msgid "Kernel Engineers = Firmware Engineers"
msgstr ""

#: src/intro.md:176
msgid "Many more Engineers know Linux than know UEFI"
msgstr ""

#: src/intro.md:177
msgid "Reduced build time"
msgstr ""

#: src/intro.md:178
msgid "**30s** for initramfs"
msgstr ""

#: src/intro.md:179
msgid "**15s** for kernel (incremental)"
msgstr ""

#: src/intro.md:180
msgid "**~15s** to repack the bios image (using fiano/utk)"
msgstr ""

#: src/intro.md:181
msgid "**Total: ~1m** for a new full bios image, ready to be tested"
msgstr ""

#: src/intro.md:182
msgid "Testing and debugging"
msgstr ""

#: src/intro.md:183
msgid "`diskboot` and `pxeboot` already have unit tests"
msgstr ""

#: src/intro.md:184
msgid "Easier to write tests using resources (like network) with Linux"
msgstr ""

#: src/intro.md:185
msgid ""
"Open-source projects such as u-root follow excellent software practices such "
"as running automated test on each submitted change"
msgstr ""

#: src/intro.md:187
msgid "Much easier to debug Go user-space applications"
msgstr ""

#: src/intro.md:188
msgid "Test with a kernel in QEMU"
msgstr ""

#: src/use-cases.md:3
msgid ""
"The general concept of using a Linux kernel to boot into an operating system "
"sounds simple at first glance. The challenges in the details, in part not "
"only limited to using Linux, are being discussed in this chapter, with ideas "
"on solving specific problems in the domain of bootloaders."
msgstr ""

#: src/use-cases.md:8
msgid "Constrained environments"
msgstr ""

#: src/use-cases.md:10
msgid ""
"Booting a system means dealing with constraints. Those can have either of "
"two effects: spark creativity or keep you from pursuing a goal. On foot, you "
"can only reach as far in a day, whereas a vehicle gets you much further. "
"With LinuxBoot, we want to take the chance to reevaluate contemporary "
"designs and go beyond."
msgstr ""

#: src/use-cases.md:16
msgid ""
"When it comes to hardware, the vendor would choose the parts for their "
"product and consider them in their price calculation."
msgstr ""

#: src/use-cases.md:19
msgid ""
"One main constraint is the initial boot source. A System-on-Chip (SoC) "
"typically starts off with a mask ROM and continues with a simple storage "
"part, which may range from a SPI flash of a few megabytes up to eMMC or SD "
"cards of hundreds of megabytes or even gigabytes."
msgstr ""

#: src/use-cases.md:24
msgid ""
"We neglect other storages here that are attached via NVMe, SATA or other "
"high-speed buses, because those are commonly not supported by mask ROMs. "
"They are, on the other hand, what a bootloader offers to boot from, as well "
"as network sources."
msgstr ""

#: src/use-cases.md:29
msgid "Embedded devices"
msgstr ""

#: src/use-cases.md:31
msgid ""
"Many devices, nowadays known as IoT (Internet of Things), appliances, or "
"similar, have a narrow use case. They are meant to perform a specific set of "
"tasks, and thus can be tailored for it. In hardware terms, that often means "
"an SoC, a bit of storage, and peripherals. Debug interfaces are reduced or "
"removed for the final product."
msgstr ""

#: src/use-cases.md:37
msgid "Desktop, laptop, workstation and server systems"
msgstr ""

#: src/use-cases.md:39
msgid ""
"At this point, many systems are still based on x86 processors, coming with a "
"SPI flash on the board. While laptops and desktops mostly have a mere 16 or "
"32 megabytes to offer, high-end servers and workstations already have 64, "
"and even a second whole system called the Board Management Controller (BMC), "
"which has its own firmware and corresponding storage. Designs around those "
"constraints vary among OEMs."
msgstr ""

#: src/use-cases.md:46
msgid ""
"Note that it need not be that way. Arm based, RISC-V based and other systems "
"already show that you can expect more, such as booting off eMMC. Laptops and "
"desktop boards in that range are available as of now, even some servers and "
"workstations."
msgstr ""

#: src/use-cases.md:51
msgid "Single Board Computers (SBCs)"
msgstr ""

#: src/use-cases.md:53
msgid ""
"The SBC market has grown to such a degree that credit card size boards "
"nowadays comes with both small storage parts that can act as boot sources as "
"well as PCIe connectors that can hold NVMes of gigabytes and terabytes of "
"storage. This gives us the opportunity to work out a boot flow that provides "
"the end user with a very rich environment already early on before the main "
"operating system is loaded."
msgstr ""

#: src/talks-news.md:1
msgid "Coverage"
msgstr ""

#: src/talks-news.md:3
msgid "Talks"
msgstr ""

#: src/talks-news.md:5 src/talks-news.md:39
msgid "Date"
msgstr ""

#: src/talks-news.md:5
msgid "Presenter"
msgstr ""

#: src/talks-news.md:5 src/talks-news.md:39
msgid "Title"
msgstr ""

#: src/talks-news.md:7
msgid "12/27/2016"
msgstr ""

#: src/talks-news.md:7 src/talks-news.md:9
msgid "Trammell Hudson"
msgstr ""

#: src/talks-news.md:7
msgid "[Bootstraping a slightly more secure laptop](https://trmm.net/Heads_33c3)"
msgstr ""

#: src/talks-news.md:8
msgid "10/27/2017"
msgstr ""

#: src/talks-news.md:8
msgid "Ron Minnich"
msgstr ""

#: src/talks-news.md:8
msgid ""
"Replace your exploit-ridden firmware with a Linux kernel "
"([YouTube](https://www.youtube.com/watch?v=iffTJ1vPCSo), "
"[slides](https://schd.ws/hosted_files/osseu17/84/Replace%20UEFI%20with%20Linux.pdf))"
msgstr ""

#: src/talks-news.md:9
msgid "12/29/2017"
msgstr ""

#: src/talks-news.md:9
msgid ""
"[Bringing Linux back to the server BIOS with "
"LinuxBoot](https://trmm.net/LinuxBoot_34c3)"
msgstr ""

#: src/talks-news.md:10
msgid "09/13/2018"
msgstr ""

#: src/talks-news.md:10 src/talks-news.md:11
msgid "Andrea Barberio, David Hendricks"
msgstr ""

#: src/talks-news.md:10
msgid ""
"[Open Source Firmware @ "
"Facebook](https://www.osfc.io/2018/talks/open-source-firmware-facebook/)"
msgstr ""

#: src/talks-news.md:11
msgid "10/02/2018"
msgstr ""

#: src/talks-news.md:11
msgid ""
"[Turning Linux Engineers into Firmware "
"Engineers](https://2018ocpregionalsummit.sched.com/event/F8ax/turning-linux-engineers-into-firmware-engineers) "
"([slides](https://insomniac.slackware.it/static/2018_ocp_regional_summit_linuxboot_at_facebook.pdf), "
"[YouTube](https://www.youtube.com/watch?v=i84df1z6mdI))"
msgstr ""

#: src/talks-news.md:12
msgid "06/15/2024"
msgstr ""

#: src/talks-news.md:12
msgid "Marta Lewandowska"
msgstr ""

#: src/talks-news.md:12
msgid ""
"[No more boot loader: Please use the kernel "
"instead](https://pretalx.com/devconf-cz-2024/talk/W3AVCT/)"
msgstr ""

#: src/talks-news.md:14
msgid ""
"[Make Your System Firmware Faster, More Flexible and Reliable with "
"LinuxBoot](https://www.usenix.org/conference/lisa18/presentation/barberio) "
"by [David Hendricks](https://github.com/dhendrix) and [Andrea "
"Barberio](https://github.com/insomniacslk) at [LISA "
"2018](https://www.usenix.org/conference/lisa18) "
"([slides](https://insomniac.slackware.it/static/2018_lisa_linuxboot_at_facebook.pdf)) "
"(2018-10-31)"
msgstr ""

#: src/talks-news.md:20
msgid ""
"[Open Source Firmware - A love "
"story](https://www.youtube.com/watch?v=xfqKm190dbU) by [Philipp "
"Deppenwiese](https://cybersecurity.9elements.com) at "
"[35c3](https://events.ccc.de/congress/2018) "
"([slides](https://cdn.media.ccc.de/congress/2018/slides-h264-hd/35c3-9778-deu-eng-Open_Source_Firmware_hd-slides.mp4)) "
"(2018-12-27)"
msgstr ""

#: src/talks-news.md:25
msgid ""
"[Open Source Firmware at "
"Facebook](https://fosdem.org/2019/schedule/event/open_source_firmware_at_facebook/) "
"by [David Hendricks](https://github.com/dhendrix) and [Andrea "
"Barberio](https://github.com/insomniacslk) at [FOSDEM "
"2019](https://fosdem.org/2019/) "
"([video](https://video.fosdem.org/2019/K.4.401/open_source_firmware_at_facebook.mp4)) "
"([slides](https://insomniac.slackware.it/static/2019_fosdem_linuxboot_at_facebook.pdf)) "
"(2019-02-03)"
msgstr ""

#: src/talks-news.md:32
msgid ""
"[Kexec Evolutions for "
"LinuxBoot](https://www.osfc.io/2022/talks/kexec-evolutions-for-linuxboot/) "
"by David Hu at OSFC 2021"
msgstr ""

#: src/talks-news.md:34
msgid ""
"[No more boot loader: Please use the kernel "
"instead](https://pretalx.com/devconf-cz-2024/talk/W3AVCT/) at 2024 DevConf"
msgstr ""

#: src/talks-news.md:37
msgid "News"
msgstr ""

#: src/talks-news.md:39
msgid "Website"
msgstr ""

#: src/talks-news.md:41
msgid "01/25/2018"
msgstr ""

#: src/talks-news.md:41
msgid "Linux Foundation"
msgstr ""

#: src/talks-news.md:41
msgid ""
"[System Statup gets a Boost with new LinuxBoot "
"project](https://www.linuxfoundation.org/blog/system-startup-gets-a-boost-with-new-linuxboot-project/)"
msgstr ""

#: src/talks-news.md:42
msgid "02/15/2018"
msgstr ""

#: src/talks-news.md:42
msgid "Linux Journal"
msgstr ""

#: src/talks-news.md:42
msgid ""
"[Linux Journal: FOSS Project Spotlight: "
"LinuxBoot](https://www.linuxjournal.com/content/foss-project-spotlight-linuxboot/)"
msgstr ""

#: src/talks-news.md:43
msgid "03/08/2018"
msgstr ""

#: src/talks-news.md:43 src/talks-news.md:48
msgid "LWN"
msgstr ""

#: src/talks-news.md:43
msgid "[LWN.net: LinuxBoot: Linux as firmware](https://lwn.net/Articles/748586/)"
msgstr ""

#: src/talks-news.md:44
msgid "06/21/2018"
msgstr ""

#: src/talks-news.md:44 src/talks-news.md:45 src/talks-news.md:47
msgid "Phoronix"
msgstr ""

#: src/talks-news.md:44
msgid ""
"[Equus WHITEBOX OPEN: A Line Of Coreboot/LinuxBoot-Ready Xeon Scalable "
"Servers](https://www.phoronix.com/news/Equus-WHITEBOX-OPEN)"
msgstr ""

#: src/talks-news.md:45
msgid "02/06/2019"
msgstr ""

#: src/talks-news.md:45
msgid ""
"[At Just Over One Year Old, LinuxBoot Continues Making Inroads At Facebook & "
"Elsewhere](https://www.phoronix.com/news/LinuxBoot-2019)"
msgstr ""

#: src/talks-news.md:46
msgid "03/14/2019"
msgstr ""

#: src/talks-news.md:46
msgid "Facebook"
msgstr ""

#: src/talks-news.md:46
msgid ""
"[Facebook's LinuxBoot-powered F-16 high-performance fabric "
"network](https://code.fb.com/data-center-engineering/f16-minipack/)"
msgstr ""

#: src/talks-news.md:47
msgid "03/10/2023"
msgstr ""

#: src/talks-news.md:47
msgid ""
"[Lenovo Begins Supporting LinuxBoot Firmware With "
"ByteDance](https://www.phoronix.com/news/Lenovo-LinuxBoot-ByteDance)"
msgstr ""

#: src/talks-news.md:48
msgid "07/08/2024"
msgstr ""

#: src/talks-news.md:48
msgid "[Giving bootloaders the boot with nmbl](https://lwn.net/Articles/979789)"
msgstr ""

#: src/components.md:3
msgid "![image](./images/LinuxBoot-components.svg)"
msgstr ""

#: src/components.md:5
msgid "LinuxBoot consists of the following components:"
msgstr ""

#: src/components.md:7 src/components.md:12 src/history.md:3
msgid "BIOS"
msgstr ""

#: src/components.md:8 src/components.md:18
msgid "Linux kernel"
msgstr ""

#: src/components.md:9
msgid "u-root -> initramfs"
msgstr ""

#: src/components.md:14
msgid ""
"This does not have to be a specific BIOS; currently LinuxBoot supports UEFI "
"and [coreboot](https://coreboot.org/)."
msgstr ""

#: src/components.md:20
msgid ""
"LinuxBoot is not intended to be a runtime production kernel; rather, it is "
"meant to replace specific UEFI functionality using Linux kernel capabilities "
"and then boot the actual production kernel on the machine. Kernel "
"configuration files specific to LinuxBoot provide the needed Linux kernel "
"capabilities without bloating the size of the BIOS with unnecessary drivers."
msgstr ""

#: src/components.md:26
msgid ""
"These config files disable options that are not needed in the LinuxBoot "
"kernel and add some patches that are needed."
msgstr ""

#: src/components.md:30
msgid "Initial RAM filesystem  (initramfs)"
msgstr ""

#: src/components.md:32
msgid ""
"When Linux boots it needs a root file system that provides boot and startup "
"utilities. LinuxBoot uses [u-root](./glossary.md) to create an initramfs for "
"this purpose."
msgstr ""

#: src/components.md:37
msgid "What is an initramfs?"
msgstr ""

#: src/components.md:39
msgid ""
"The initramfs is a root file system that is embedded within the firmware "
"image itself. It is intended to be placed in a flash device along with the "
"Linux kernel as part of the firmware image for LinuxBoot. The initramfs is "
"essentially a set of directories bundled into a single cpio archive."
msgstr ""

#: src/components.md:44
msgid ""
"At boot time, the boot loader or firmware (for example, coreboot) loads the "
"bzImage and initramfs into memory and starts the kernel. The kernel checks "
"for the presence of the initramfs and, if found, unpacks it, mounts it as "
"`/` and runs `/init`."
msgstr ""

#: src/components.md:50
msgid ""
"There are many types of initramfs, in this topic we focus on u-root. u-root "
"is a Go user-space (a set of programs and libraries written in Go that are "
"used to interact with the kernel). It contains a toolset of standard Linux "
"applications and commands."
msgstr ""

#: src/components.md:55
msgid "u-root can create an initramfs in two different modes:"
msgstr ""

#: src/components.md:57
msgid "source mode, which contains:"
msgstr ""

#: src/components.md:58
msgid "Go toolchain binaries"
msgstr ""

#: src/components.md:59
msgid "A simple shell"
msgstr ""

#: src/components.md:60
msgid "Go source for tools to be compiled on the fly by the shell"
msgstr ""

#: src/components.md:61
msgid ""
"Busybox (bb) mode: This is one busybox-like binary comprising all the "
"requested utilities."
msgstr ""

#: src/components.md:64
msgid ""
"The initramfs provided by u-root implements the toolchain needed to securely "
"boot the machine from the network, perform identity verification, "
"communicate with different internal boot-related components, and kexec the "
"next kernel."
msgstr ""

#: src/components.md:68
msgid ""
"u-root is an open source project hosted on GitHub. Within the u-root "
"repository, we have executable commands in `cmds` and the packages "
"containing libraries and implementations in `pkg`."
msgstr ""

#: src/tools-evaluation.md:3
msgid "Three general questions guide all software projects:"
msgstr ""

#: src/tools-evaluation.md:5
msgid "what exists already? (implementations, tools and build systems)"
msgstr ""

#: src/tools-evaluation.md:6
msgid "what needs development? (UIs and such)"
msgstr ""

#: src/tools-evaluation.md:7
msgid "what is a good environment? (build + runtime)"
msgstr ""

#: src/tools-evaluation.md:9
msgid ""
"Not only do we want to answer those questions. We also keep track of the "
"options and decision process in this book in order for readers to make sense."
msgstr ""

#: src/tools-evaluation.md:12
msgid ""
"There are many existing tools already that we can leverage to implement the "
"idea of using Linux to boot into an operating system."
msgstr ""

#: src/tools-evaluation.md:15
msgid "Root filesystem"
msgstr ""

#: src/tools-evaluation.md:17
msgid ""
"Linux needs a root filesystem with at least one binary that is called "
"[`init`](https://docs.kernel.org/admin-guide/init.html). Since booting a "
"system is a cumbersome task, additional tools aid in both development and "
"investigating possible issues."
msgstr ""

#: src/tools-evaluation.md:22
msgid "Core utilities"
msgstr ""

#: src/tools-evaluation.md:24
msgid ""
"Unix already came with lots of little utilities for the user of the system, "
"which may be anyone from a system developer to an administrator of a shared "
"or provided system, or an end user. Further tools have been created over the "
"years, and the [GNU core "
"utilities](https://en.wikipedia.org/wiki/GNU_Core_Utilities) are essentially "
"a collection of tools resulting from merging other collections. Note that "
"there are still many other utilities that are not part of coreutils. At the "
"same time, there are multiple other implementations now, which differ in "
"terms of arguments and flags and possibly additional utilities they include."
msgstr ""

#: src/tools-evaluation.md:33 src/tools-evaluation.md:53
msgid "tool"
msgstr ""

#: src/tools-evaluation.md:33 src/tools-evaluation.md:53
msgid "language"
msgstr ""

#: src/tools-evaluation.md:33 src/tools-evaluation.md:53
msgid "license"
msgstr ""

#: src/tools-evaluation.md:33 src/tools-evaluation.md:53
msgid "usage"
msgstr ""

#: src/tools-evaluation.md:35
msgid "[BusyBox](https://busybox.net/)"
msgstr ""

#: src/tools-evaluation.md:35 src/tools-evaluation.md:36
#: src/tools-evaluation.md:37 src/tools-evaluation.md:55
#: src/tools-evaluation.md:56 src/tools-evaluation.md:57
msgid "C"
msgstr ""

#: src/tools-evaluation.md:35 src/tools-evaluation.md:55
#: src/tools-evaluation.md:57
msgid "GPLv2"
msgstr ""

#: src/tools-evaluation.md:35 src/history.md:51
msgid "Heads"
msgstr ""

#: src/tools-evaluation.md:36
msgid "[toybox](http://landley.net/toybox)"
msgstr ""

#: src/tools-evaluation.md:36
msgid "0BSD"
msgstr ""

#: src/tools-evaluation.md:36
msgid "Android"
msgstr ""

#: src/tools-evaluation.md:37
msgid "[GNU coreutils](https://www.gnu.org/software/coreutils/)"
msgstr ""

#: src/tools-evaluation.md:37
msgid "GPLv3"
msgstr ""

#: src/tools-evaluation.md:37 src/tools-evaluation.md:39
msgid "not for LinuxBoot"
msgstr ""

#: src/tools-evaluation.md:38
msgid "[u-root](https://u-root.org)"
msgstr ""

#: src/tools-evaluation.md:38 src/tools-evaluation.md:58
msgid "Go"
msgstr ""

#: src/tools-evaluation.md:38 src/tools-evaluation.md:58
msgid "BSD 3-Clause"
msgstr ""

#: src/tools-evaluation.md:38
msgid "ByteDance, Google et al"
msgstr ""

#: src/tools-evaluation.md:39
msgid "[uutils/coreutils](http://uutils.github.io/)"
msgstr ""

#: src/tools-evaluation.md:39 src/tools-evaluation.md:59
msgid "Rust"
msgstr ""

#: src/tools-evaluation.md:39
msgid "MIT"
msgstr ""

#: src/tools-evaluation.md:41
msgid "kexec implementations"
msgstr ""

#: src/tools-evaluation.md:43
msgid ""
"While [kexec itself is a Linux "
"syscall](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/uapi/linux/kexec.h), "
"it is not a one-shot operation. Loading multiple segments into memory, "
"synchronizing and unmounting file systems, and the eventual syscall to "
"[reboot](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/uapi/linux/reboot.h) "
"belong to the procedure. In addition, there are architecture specifics to "
"take into account. Thus, there are multiple implementations of kexec, which "
"are Linux programs that offer their own interfaces again to pass extra "
"arguments. Besides those standalone implementations, there are also "
"specialized boot loaders based on kexec that have their own extra logic, "
"such as FreeBSD's kload or petitboot."
msgstr ""

#: src/tools-evaluation.md:55
msgid ""
"[kexec-tools](https://git.kernel.org/pub/scm/utils/kernel/kexec/kexec-tools.git) "
"([GitHub mirror](https://github.com/horms/kexec-tools))"
msgstr ""

#: src/tools-evaluation.md:55
msgid "Heads, Petitboot"
msgstr ""

#: src/tools-evaluation.md:56
msgid "[systemd](https://systemd.io/) (wrapper)"
msgstr ""

#: src/tools-evaluation.md:56
msgid "LGPL-2.1+"
msgstr ""

#: src/tools-evaluation.md:56
msgid "systemd on UEFI"
msgstr ""

#: src/tools-evaluation.md:57
msgid "[kexecboot](https://github.com/kexecboot/kexecboot)"
msgstr ""

#: src/tools-evaluation.md:57 src/tools-evaluation.md:59
msgid "?"
msgstr ""

#: src/tools-evaluation.md:58
msgid "u-root (CLI+mod)"
msgstr ""

#: src/tools-evaluation.md:58
msgid "Google et al"
msgstr ""

#: src/tools-evaluation.md:59
msgid "[kexlinux](https://github.com/im-0/kexlinux)"
msgstr ""

#: src/tools-evaluation.md:59
msgid "LGPL-3.0+"
msgstr ""

#: src/petitboot.md:3
msgid ""
"petitboot is a Linux user-space application written in C that calls `kexec`. "
"The `kexec` installed in the initramfs is not the mainline kexec-tools "
"implementation, but a smaller implementation named "
"[kexec-lite](https://github.com/antonblanchard/kexec-lite). It is claimed to "
"be roughly 32 KB compared to kexec-tools, which is roughly 200 KB.[^1]"
msgstr ""

#: src/petitboot.md:9
msgid ""
"<https://github.com/antonblanchard/kexec-lite/issues/4#issuecomment-314936778>"
msgstr ""

#: src/openpower.md:1
msgid "OpenPOWER boot chain"
msgstr ""

#: src/openpower.md:3
msgid ""
"```mermaid\n"
"flowchart LR\n"
"    skiroot([\"skiroot (petitboot)\"])\n"
"    SBEs-->hostboot-->skiboot-->skiroot-->OS\n"
"```"
msgstr ""

#: src/openpower.md:9
msgid ""
"[Self-boot engines](https://github.com/open-power/sbe) (SBE) are split "
"between an on-chip ROM and an external EEPROM"
msgstr ""

#: src/openpower.md:11
msgid ""
"[hostboot](https://github.com/open-power/hostboot) is a C++ boot loader that "
"does DRAM initialization provides runtime services to skiboot or a hypervisor"
msgstr ""

#: src/openpower.md:13
msgid ""
"[skiboot](https://github.com/open-power/skiboot) is a C boot loader and "
"runtime firmware for OpenPOWER that loads skiroot."
msgstr ""

#: src/openpower.md:16
msgid ""
"skiroot is a term used to describe the LinuxBoot implementation for "
"OpenPOWER. A skiroot repository or package does not exist. The term is only "
"used in the kernel configuration, `skiroot_defconfig`.[^1]"
msgstr ""

#: src/openpower.md:20 src/odroid.md:26 src/history.md:57
msgid "See also"
msgstr ""

#: src/openpower.md:22
msgid ""
"[coreboot and Heads as an alternative firmware for OpenPOWER Talos "
"II](https://openpower.foundation/blog/coreboot-on-talos2/)"
msgstr ""

#: src/openpower.md:25
msgid ""
"<https://github.com/open-power/op-build/blob/master/openpower/configs/linux/skiroot_defconfig>"
msgstr ""

#: src/odroid.md:1
msgid "ODROID boot chain"
msgstr ""

#: src/odroid.md:3
msgid ""
"The [ODROID-N2](https://wiki.odroid.com/odroid-n2/hardware) comes with a SPI "
"flash as well as a connector for an eMMC flash and an SD card slot. The SoC "
"is an [Amlogic S922X which can boot from all those "
"storages](https://wiki.odroid.com/odroid-n2/software/boot_sequence), "
"depending on GPIO configuration and a fallback flow in the mask ROM. For "
"booting from SPI flash, the ODROID-N2 board has a switch, and comes with "
"[Petitboot](./petitboot.md) preinstalled[^1]."
msgstr ""

#: src/odroid.md:10
msgid "The SPI flash boot flow is as follows:"
msgstr ""

#: src/odroid.md:12
msgid ""
"```mermaid\n"
"flowchart LR\n"
"    maskrom[\"mask ROM\"]\n"
"    spl[\"U-Boot SPL\"]\n"
"    uboot[\"U-Boot main\"]\n"
"    petitboot([\"petitboot\"])\n"
"    maskrom-->spl-->uboot-->petitboot-->OS\n"
"```"
msgstr ""

#: src/odroid.md:21
msgid ""
"[U-Boot SPL](https://docs.u-boot.org/en/latest/usage/spl_boot.html) "
"initializes DRAM and loads U-Boot main (\"proper\")"
msgstr ""

#: src/odroid.md:23
msgid ""
"U-Boot main is set up to directly load Linux with Petitboot, which "
"implements LinuxBoot"
msgstr ""

#: src/odroid.md:28
msgid ""
"[ODROID forum discussion on porting Petitboot to "
"ODROID-N2](https://forum.odroid.com/viewtopic.php?f=182&t=33873)"
msgstr ""

#: src/odroid.md:31
msgid ""
"<https://wiki.odroid.com/getting_started/petitboot/os_installation_using_otg>"
msgstr ""

#: src/u-root.md:3
msgid ""
"U-root is an embeddable root file system intended to be placed in a flash "
"device as part of the firmware image, along with a Linux kernel. The program "
"source code is installed in the root file system contained in the firmware "
"flash part and compiled on demand. All the u-root utilities, roughly "
"corresponding to standard Unix utilities, are written in Go, a modern, "
"type-safe language with garbage collection and language-level support for "
"concurrency and inter-process communication."
msgstr ""

#: src/u-root.md:11
msgid ""
"Unlike most embedded root file systems, which consist largely of binaries, "
"u-root has only 5: an init program and 4 Go compiler binaries. When a "
"program is first run, it, and any not-yet-built packages it uses are "
"compiled to a RAM-based file system. The first invocation of a program takes "
"a fraction of a second, as it is compiled. Packages are only compiled once, "
"so the slowest build is always the first one, on boot, which takes about 3 "
"seconds. Subsequent invocations are very fast, usually a millisecond or so."
msgstr ""

#: src/u-root.md:19
msgid ""
"U-root blurs the line between script-based distros such as Perl Linux[^24] "
"and binary-based distros such as BusyBox[^26]. It has the flexibility of "
"Perl Linux and the performance of BusyBox. Scripts and builtins are written "
"in Go, not a shell scripting language. U-root is a new way to package and "
"distribute file systems for embedded systems, and the use of Go promises a "
"dramatic improvement in their security."
msgstr ""

#: src/u-root.md:26
msgid "U-root and embedded systems"
msgstr ""

#: src/u-root.md:28
msgid ""
"Embedding kernels and root file systems in BIOS flash is a common technique "
"for gaining boot time performance and platform customization[^25] [^14] "
"[^23]. Almost all new firmware includes a multiprocess operating system with "
"a full complement of file systems, network drivers, and protocol stacks, all "
"contained in an embedded file system. In some cases, the kernel is only "
"booted long enough to boot another kernel. In others, the kernel that is "
"booted and the file system it contains constitute the operational "
"environment of the device[^15]. These so-called “embedded root file systems” "
"also contain a set of standard Unix-style programs used for both normal "
"operation and maintenance. Space on the device is at a premium, so these "
"programs are usually written in C using the BusyBox toolkit[^26], or in an "
"interpretive language such as Perl[^24] or Forth. BusyBox in particular has "
"found wide usage in embedded appliance environments, as the entire root file "
"system can be contained in under one MiB."
msgstr ""

#: src/u-root.md:42
msgid ""
"Embedded systems, which were once standalone, are now almost always network "
"connected. Network connected systems face a far more challenging security "
"environment than even a few years ago. In response to the many successful "
"attacks against shell interpreters[^11] and C programs[^8], we have started "
"to look at using a more secure, modern language in embedded root file "
"systems, namely, Go[^21] [^16]."
msgstr ""

#: src/u-root.md:49
msgid ""
"Go is a new systems programming language created by Google. Go has strong "
"typing; language level support for concurrency; inter-process communication "
"via channels, a la Occam[^13], Limbo[^17], and Alef[^27]; runtime type "
"safety and other protective measures; dynamic allocation and garbage "
"collection; closures; and a package syntax, similar to Java, that makes it "
"easy to determine what packages a given program needs. The modern language "
"constructs make Go a much safer language than C. This safety is critical for "
"network-attached embedded systems, which usually have network utilities "
"written in C, including web servers, network servers including sshd, and "
"programs that provide access to a command interpreter, itself written in C. "
"All are proving to be vulnerable to the attack-rich environment that the "
"Internet has become. Buffer overflow attacks affecting C-based firmware code "
"(among other things) in 2015 include GHOST and the so-called FSVariable.c "
"bug in Intel’s UEFI firmware. Buffer overflows in Intel’s UEFI and Active "
"Management Technology (AMT) have also been discovered in several versions in "
"recent years."
msgstr ""

#: src/u-root.md:65
msgid ""
"Both UEFI[^12] and AMT[^4] are embedded operating systems, loaded from flash "
"that run network-facing software. Attacks against UEFI have been extensively "
"studied[^9]. Most printers are network-attached and are a very popular "
"exploitation target[^6]. Firmware is not visible to most users and is "
"updated much less frequently (if at all) than programs. It is the first "
"software to run, at power on reset. Exploits in firmware are extremely "
"difficult to detect, because firmware is designed to be as invisible as "
"possible. Firmware is extremely complex; UEFI is roughly equivalent in size "
"and capability to a Unix kernel. Firmware is usually closed and proprietary, "
"with nowhere near the level of testing of kernels. These properties make "
"firmware an ideal place for so-called advanced persistent threats[^10] [^18] "
"[^5]. Once an exploit is installed, it is almost impossible to remove, since "
"the exploit can inhibit its removal by corrupting the firmware update "
"process. The only sure way to mitigate a firmware exploit is to destroy the "
"hardware."
msgstr ""

#: src/u-root.md:80
msgid ""
"U-root is an excellent option for embedded systems. U-root contains only 5 "
"binaries, 4 of them from the Go toolchain, and the 5th is an init binary. "
"The rest of the programs are contained in BIOS flash in source form, "
"including packages. The search path is arranged so that when a command is "
"invoked, if it is not in `/bin`, an installer is invoked instead which "
"compiles the program into `/bin`. If the build succeeds, the command is "
"executed. This first invocation takes a fraction of a second, depending on "
"program complexity. After that, the RAM-based, statically linked binaries "
"run in about a millisecond. Scripts are written in Go, not a shell scripting "
"language, with two benefits: the shell can be simple, with fewer corner "
"cases, and the scripting environment is substantially improved since Go is "
"more powerful than most shell scripting languages, but also less fragile and "
"less prone to parsing bugs."
msgstr ""

#: src/u-root.md:93
msgid "U-root design"
msgstr ""

#: src/u-root.md:95
msgid ""
"The u-root boot image is a build toolchain and a set of programs in source "
"form. When first used, a program and any needed but not-yet-built packages "
"are built and installed, typically in a fraction of a second. With later "
"uses, the binary is executed. The root file system is almost entirely "
"unformed on boot; `/init` sets up the key directories and mounts, including "
"common ones such as `/etc` and `/proc`."
msgstr ""

#: src/u-root.md:102
msgid ""
"Since the init program itself is only 132 lines of code and is easy to "
"change, the structure is very flexible and allows for many use cases, for "
"example:"
msgstr ""

#: src/u-root.md:105
msgid ""
"Additional binaries: if the 3 seconds it takes to get to a shell is too long "
"(some applications such as automotive computing require 800 ms startup "
"time), and there is room in flash, some programs can be precompiled into "
"/bin."
msgstr ""

#: src/u-root.md:108
msgid ""
"Build it all on boot: if on-demand compilation is not desired, a background "
"thread in the init process can build all the programs on boot."
msgstr ""

#: src/u-root.md:110
msgid ""
"Selectively remove binaries after use: if RAM space is at a premium, once "
"booted, a script can remove everything in `/bin`. Utilities or commands that "
"are used will be rebuilt on demand."
msgstr ""

#: src/u-root.md:113
msgid ""
"Always build on demand: run in a mode in which programs are never written to "
"`/bin` and always rebuilt on demand. This is a very practical option given "
"that program compilation is so fast."
msgstr ""

#: src/u-root.md:116
msgid ""
"Lockdown: if desired, the system can be locked down once booted in one of "
"several ways: the entire `/src` tree can be removed, for example, or just "
"the compiler toolchain can be deleted."
msgstr ""

#: src/u-root.md:120
msgid "U-root functionality"
msgstr ""

#: src/u-root.md:122
msgid ""
"U-root is packaged as an LZMA-compressed initial RAM file system (initramfs) "
"in cpio format. It is contained in a Linux compressed kernel image, also "
"know as bzImage. The bootloader (for example, syslinux) or firmware (for "
"example, coreboot) loads the bzImage into memory and starts it. The Linux "
"kernel sets up a RAM-based root file system and unpacks the u-root file "
"system into it. This initial root file system contains the Go toolchain (4 "
"binaries), an init binary, the u-root program source, and the entire Go "
"source tree, which provides packages needed for u-root programs."
msgstr ""

#: src/u-root.md:131
msgid ""
"All Unix systems start an init process on boot and u-root is no exception. "
"The init for u-root sets up some basic directories, symlinks, and files. It "
"builds a command installer and invokes the shell. This process is described "
"in more detail below. The boot file system layout is shown in Table 1."
msgstr ""

#: src/u-root.md:136
msgid ""
"The src directory is where programs and u-root packages reside. The go/bin "
"directory is for any Go tools built after boot; the go/pkg/tool directory "
"contains binaries for various architecture/kernel combinations. The "
"directory in which a compiler toolchain is placed provides information about "
"the target OS and architecture, for example, the Go build places binaries "
"for Linux on x86 64 in `/go/pkg/tool/linux` `amd64/`. Note that there is no "
"`/bin` or many of the other directories expected in a root file system. The "
"init binary builds them. It creates an empty `/bin` which is filled with "
"binaries on demand as shown in Table 2.The u-root root file system has very "
"little state."
msgstr ""

#: src/u-root.md:146
msgid ""
"For most programs to work, the file system must be more complete. Image "
"space is saved by having init create additional file system structure at "
"boot time: it fills in the missing parts of the root filesystem. It creates "
"`/dev` and `/proc` and mounts them. It creates an empty `/bin` which is "
"filled with binaries on demand."
msgstr ""

#: src/u-root.md:152
msgid ""
"In addition to `/bin`, there is a directory called `/buildbin`. `Buildbin` "
"and the correct setup of $PATH are the keys to making on-demand compilation "
"work. The init process sets $PATH to "
"`/go/bin:/bin:/buildbin:/usr/local/bin`. Init also builds `installcommand` "
"using the Go bootstrap builder and creates a complete set of symlinks. As a "
"final step, init execs `sh`."
msgstr ""

#: src/u-root.md:158
msgid ""
"There is no `/bin/sh` at this point; the first `sh` found in $PATH is "
"`/buildbin/sh`. This is a symlink to `installcommand`. `Installcommand`, "
"once started, examines `argv[0]`, which is `sh`, and takes this as "
"instruction to build `/src/cmds/sh/.go` into `/bin` and then exec `/bin/sh`. "
"There is no difference between starting the first shell and any other "
"program. Hence, part of the boot process involves the construction of an "
"installation tool to build a binary for a shell which is then run."
msgstr ""

#: src/u-root.md:166
msgid ""
"If a user wants to examine the source to the shell, they can `cat` "
"`/src/cmds/sh/.go`. The `cat` command will be built and then show those "
"files. U-root is intended for network-based devices and hence good network "
"initialization code is essential. U-root includes a Go version of the IP and "
"DHCP programs, along with the docker netlink package and a DHCP package."
msgstr ""

#: src/u-root.md:172
msgid "Table 1 below shows the initial layout of a u-root file system."
msgstr ""

#: src/u-root.md:174
msgid ""
"All Go compiler and runtime source is included under `/go/src`. All u-root "
"source is under `/src` and the compiler toolchain binaries are under "
"`/go/pkg`."
msgstr ""

#: src/u-root.md:177 src/u-root.md:229
msgid "Directory"
msgstr ""

#: src/u-root.md:177 src/u-root.md:229
msgid "Subdirectory"
msgstr ""

#: src/u-root.md:177 src/u-root.md:229
msgid "Command"
msgstr ""

#: src/u-root.md:179 src/u-root.md:231
msgid "/src"
msgstr ""

#: src/u-root.md:179 src/u-root.md:231
msgid "cmds/"
msgstr ""

#: src/u-root.md:180 src/u-root.md:232
msgid "builtin/builtin.go"
msgstr ""

#: src/u-root.md:181 src/u-root.md:233
msgid "/cat.go"
msgstr ""

#: src/u-root.md:182 src/u-root.md:234
msgid "/cmp.go"
msgstr ""

#: src/u-root.md:183 src/u-root.md:235
msgid "comm/comm.go"
msgstr ""

#: src/u-root.md:184 src/u-root.md:236
msgid "cp/cp.go"
msgstr ""

#: src/u-root.md:185 src/u-root.md:237
msgid "date/date.go"
msgstr ""

#: src/u-root.md:186 src/u-root.md:238
msgid "dmesg/dmesg.go"
msgstr ""

#: src/u-root.md:187 src/u-root.md:239
msgid "echo/echo.go"
msgstr ""

#: src/u-root.md:188 src/u-root.md:240
msgid "freq/freq.go"
msgstr ""

#: src/u-root.md:189 src/u-root.md:241
msgid "grep/grep.go"
msgstr ""

#: src/u-root.md:190 src/u-root.md:242
msgid "init/init.go"
msgstr ""

#: src/u-root.md:191 src/u-root.md:243
msgid "installcommand/installcommand.go"
msgstr ""

#: src/u-root.md:192 src/u-root.md:244
msgid "ip/ip.go"
msgstr ""

#: src/u-root.md:193 src/u-root.md:245
msgid "ldd/ldd.go"
msgstr ""

#: src/u-root.md:194 src/u-root.md:246
msgid "losetup/losetup.go"
msgstr ""

#: src/u-root.md:195 src/u-root.md:247
msgid "ls/ls.go"
msgstr ""

#: src/u-root.md:196 src/u-root.md:248
msgid "mkdir/mkdir.go"
msgstr ""

#: src/u-root.md:197 src/u-root.md:249
msgid "mount/mount.go"
msgstr ""

#: src/u-root.md:198 src/u-root.md:250
msgid "netcat/netcat.go"
msgstr ""

#: src/u-root.md:199 src/u-root.md:251
msgid "ping/ping.go"
msgstr ""

#: src/u-root.md:200 src/u-root.md:252
msgid "printenv/printenv.go"
msgstr ""

#: src/u-root.md:201 src/u-root.md:253
msgid "rm/rm.go"
msgstr ""

#: src/u-root.md:202 src/u-root.md:254
msgid "script/script.go"
msgstr ""

#: src/u-root.md:203 src/u-root.md:255
msgid "seq/seq.go"
msgstr ""

#: src/u-root.md:204 src/u-root.md:256
msgid "sh/{cd.go,parse.go,sh.go,time.go}"
msgstr ""

#: src/u-root.md:205 src/u-root.md:257
msgid "srvfiles/srvfiles.go"
msgstr ""

#: src/u-root.md:206 src/u-root.md:258
msgid "tcz/tcz.go"
msgstr ""

#: src/u-root.md:207 src/u-root.md:259
msgid "tee/tee.go"
msgstr ""

#: src/u-root.md:208 src/u-root.md:260
msgid "uniq/uniq.go"
msgstr ""

#: src/u-root.md:209 src/u-root.md:261
msgid "wc/wc.go"
msgstr ""

#: src/u-root.md:210 src/u-root.md:262
msgid "wget/wget.go"
msgstr ""

#: src/u-root.md:211 src/u-root.md:263
msgid "which/which.go"
msgstr ""

#: src/u-root.md:212 src/u-root.md:217 src/u-root.md:264 src/u-root.md:269
msgid "pkg/"
msgstr ""

#: src/u-root.md:213 src/u-root.md:265
msgid "dhcp/ (dhcp package source)"
msgstr ""

#: src/u-root.md:214 src/u-root.md:266
msgid "netlib/ (netlib package source)"
msgstr ""

#: src/u-root.md:215 src/u-root.md:267
msgid "golang.org (import package source)"
msgstr ""

#: src/u-root.md:216 src/u-root.md:268
msgid "/go"
msgstr ""

#: src/u-root.md:216 src/u-root.md:268
msgid "src/"
msgstr ""

#: src/u-root.md:216 src/u-root.md:268
msgid "Packages and toolchain"
msgstr ""

#: src/u-root.md:217 src/u-root.md:269
msgid "tool/linux amd64/{6a,6c,6g,6l}"
msgstr ""

#: src/u-root.md:218 src/u-root.md:270
msgid "misc/"
msgstr ""

#: src/u-root.md:218 src/u-root.md:219 src/u-root.md:221 src/u-root.md:270
#: src/u-root.md:271 src/u-root.md:273 src/utilities/UEFI_Tool_Kit.md:489
msgid "..."
msgstr ""

#: src/u-root.md:219 src/u-root.md:271
msgid "tool/"
msgstr ""

#: src/u-root.md:220 src/u-root.md:272
msgid "bin/"
msgstr ""

#: src/u-root.md:220 src/u-root.md:272
msgid "go"
msgstr ""

#: src/u-root.md:221 src/u-root.md:273
msgid "include/"
msgstr ""

#: src/u-root.md:222 src/u-root.md:274
msgid "/lib/"
msgstr ""

#: src/u-root.md:222 src/u-root.md:274
msgid "libc.so"
msgstr ""

#: src/u-root.md:222 src/u-root.md:274
msgid "Needed for tinycore linux packages"
msgstr ""

#: src/u-root.md:223 src/u-root.md:275
msgid "libm.so"
msgstr ""

#: src/u-root.md:225
msgid "**Table 1**: Initial layout of a u-root filesystem"
msgstr ""

#: src/u-root.md:227
msgid "Table 2 below shows the layout after `/init` has run."
msgstr ""

#: src/u-root.md:277
msgid "**Table 2**: Layout after `/init` has run."
msgstr ""

#: src/u-root.md:279
msgid ""
"`/buildbin` contains symlinks to enable the on-demand compilation, and other "
"standard directories and mount points are ready."
msgstr ""

#: src/u-root.md:282
msgid "The u-root shell"
msgstr ""

#: src/u-root.md:284
msgid ""
"U-root provides a shell that is stripped down to the fundamentals: it can "
"read commands in using the Go scanner package; it can expand (that is, glob) "
"the command elements, using the Go filepath package, and it can run the "
"resulting commands, either programs or shell builtins. It supports pipelines "
"and IO redirection. At the same time, the shell defines no language of its "
"own for scripting and builtins. Instead, the u-root shell uses the Go "
"compiler. In that sense, the u-root shell reflects a break in important ways "
"with the last few decades of shell development, which has seen shells and "
"their language grow ever more complex and, partially as a result, ever more "
"insecure[^19] and fragile[^11]."
msgstr ""

#: src/u-root.md:295
msgid ""
"The shell has several builtin commands, and you can extend it with builtin "
"commands of your own. First, you need to understand the basic source "
"structure of u-root shell builtins. Then, you will learn about user-defined "
"builtins."
msgstr ""

#: src/u-root.md:299
msgid ""
"All shell builtins, including the ones that come with the shell by default, "
"are written with a standard Go init pattern which installs one or more "
"builtins."
msgstr ""

#: src/u-root.md:302
msgid ""
"Builtins in the shell are defined by a name and a function. One or more "
"builtins can be described in a source file. The name is kept in a map and "
"the map is searched for a command name before looking in the file system. "
"The function must accept a string as a name and a (possibly zero-length) "
"array of string arguments, and return an error. In order to connect the "
"builtin to the map, a programmer must provide an `init` function which adds "
"the name and function to the map. The `init` function is special in that it "
"is run by Go when the program starts up. In this case, the `init` function "
"just installs a builtin for the time command."
msgstr ""

#: src/u-root.md:312
msgid "Figure 1 and Figure 2 below show the shell builtin for time."
msgstr ""

#: src/u-root.md:315
msgid ""
"// Package main is the 'root' of the package hierarchy for a program.\n"
"// This code is part of the main program, not another package,\n"
"// and is declared as package main.\n"
msgstr ""

#: src/u-root.md:320
msgid ""
"// A Go source file list all the packages on which it has a direct\n"
"// dependency.\n"
msgstr ""

#: src/u-root.md:325
msgid "\"fmt\""
msgstr ""

#: src/u-root.md:326
msgid "\"os\""
msgstr ""

#: src/u-root.md:327
msgid "\"time\""
msgstr ""

#: src/u-root.md:329
msgid ""
"// init() is an optional function. If init () is present in a file,\n"
"// the Go compiler and runtime arrange for it to be called at\n"
"// program startup. It is therefore like a constructor.\n"
msgstr ""

#: src/u-root.md:335
msgid ""
"// addBuiltIn is provided by the u−root shell for the addition of\n"
"    // builtin commands. Builtins must have a standard type:\n"
"    // - The first parameter is a string\n"
"    // - The second is a string array which may be 0 length\n"
"    // - The return is the Go error type\n"
"    // In this case, we are creating a builtincalled time that calls\n"
"    // the timecmd function.\n"
msgstr ""

#: src/u-root.md:343
msgid "\"time \""
msgstr ""

#: src/u-root.md:347
msgid "**Figure 1**: The code for the time builtin, Part I: setup"
msgstr ""

#: src/u-root.md:350
msgid ""
"// The timecmd function is passed the name of a command to run,\n"
"// optional arguments, and returns an error. It:\n"
"// - gets the starttime using Now from the time package\n"
"// - runs the command using the u−root shell runit function\n"
"// - computes a duration using Since from the time package\n"
"// - if there is an error, prints the error to os.Stderr\n"
"// - uses fmt. Printf to print the duration to os.Stderr\n"
"// Note that since runtime always handles the error, by printing\n"
"// it, it always returns nil. Most builtins return the error.\n"
"// Here you can see the usage of the imported packages\n"
"// from the imports statement above.\n"
msgstr ""

#: src/u-root.md:374
msgid ""
"// This function is special in that it handles the error, and hence\n"
"    // does not return an error.\n"
"    // Most other builtins return the error.\n"
msgstr ""

#: src/u-root.md:383
msgid "**Figure 2**: The code for the shell time builtin, Part II"
msgstr ""

#: src/u-root.md:385
msgid "Scripting and builtins"
msgstr ""

#: src/u-root.md:387
msgid ""
"To support scripting and builtins, u-root provides two programs: script and "
"builtin. The script program allows users to specify a Go fragment on the "
"command line, and runs that fragment as a program. The builtin program "
"allows a Go fragment to be built into the shell as a new command. Builtins "
"are persistent; the builtin command instantiates a new shell with the new "
"command built in. Scripts run via the script command are not persistent."
msgstr ""

#: src/u-root.md:394
msgid "A basic hello builtin can be defined on the command line:"
msgstr ""

#: src/u-root.md:396
msgid ""
"```\n"
"builtin hello '{ fmt.Printf(\"Hello\\n"
"\") }'\n"
"```"
msgstr ""

#: src/u-root.md:400
msgid ""
"The fragment is defined by the {} pair. Given a fragment that starts with a "
"{, the builtin command generates all the wrapper boiler plate needed. The "
"builtin command is slightly different from the script command in that the Go "
"fragment is bundled into one argument. The command accepts multiple pairs of "
"command name and Go code fragments, allowing multiple new builtin commands "
"to be installed in the shell."
msgstr ""

#: src/u-root.md:407
msgid ""
"Builtin creates a new shell at `/bin/sh` with the source at `/src/cmds/sh/`. "
"Invocations of `/bin/sh` by this shell and its children will use the new "
"shell."
msgstr ""

#: src/u-root.md:410
msgid ""
"Processes spawned by this new shell can access the new shell source and can "
"run the builtin command again and create a shell that further extends the "
"new shell. Processes outside the new shell’s process hierarchy can not use "
"this new shell or the builtin source. When the new shell exits, the builtins "
"are no longer visible in any part of the file system. We use Linux mount "
"name spaces to create this effect[^22]. Once the builtin command has "
"verified that the Go fragment is valid, it builds a new, private namespace "
"with the shell source, including the new builtin source. From that point on, "
"the new shell and its children will only use the new shell. The parent "
"process and other processes outside the private namespace continue to use "
"the old shell."
msgstr ""

#: src/u-root.md:421
msgid "Figure 3 below shows an example usage of the script command."
msgstr ""

#: src/u-root.md:423
msgid ""
"This script implements printenv. Note that it is not a complete Go program "
"in that it lacks a package statement, imports, a main function declaration, "
"and a return at the end. All the boilerplate is added by the script command, "
"which uses the Go imports package to scan the code and create the import "
"statements required for compilation (in this case, both fmt and os packages "
"are imported). Because the u-root shell is so simple, there is no need to "
"escape many of these special characters. The complex parsing tasks have been "
"offloaded to Go. Builtins are implemented in almost the same way. The "
"builtin command takes the Go fragment and creates a standard shell builtin "
"Go source file which conforms to the builtin pattern. This structure is easy "
"to generate programmatically, building on the techniques used for the script "
"command."
msgstr ""

#: src/u-root.md:435
msgid ""
"```\n"
"script{ fmt.Printf(\"%v\\n"
"\", os.Environ()) }\n"
"```"
msgstr ""

#: src/u-root.md:439
msgid ""
"**Figure 3**: Go fragment for a printenv script. Code structure is inserted "
"and packages are determined automatically."
msgstr ""

#: src/u-root.md:442
msgid "Environment variables"
msgstr ""

#: src/u-root.md:444
msgid ""
"The u-root shell supports environment variables, but manages them "
"differently than most Unix environments. The variables are maintained in a "
"directory called `/env`; the file name corresponds to the environment "
"variable name, and the files contents are the value. When it is starting a "
"new process, the shell populates child process environment variables from "
"the `/env` directory. The syntax is the same; $ followed by a name directs "
"the shell to substitute the value of the variable in the argument by "
"prepending `/env` to the path and reading the file."
msgstr ""

#: src/u-root.md:453
msgid ""
"The shell variables described above are relative paths; `/env` is prepended "
"to them. In the u-root shell, the name can also be an absolute path. For "
"example, the command script $`/home/$USER/scripts/hello` will substitute the "
"value of the `hello` script into the command line and then run the script "
"command. The ability to place arbitrary text from a file into an argument is "
"proving to be extremely convenient, especially for script and builtin "
"commands."
msgstr ""

#: src/u-root.md:460
msgid "Using external packages and programs"
msgstr ""

#: src/u-root.md:462
msgid ""
"No root file system can provide all the packages all users want, and u-root "
"is no exception. You need to have the ability to load external packages from "
"popular Linux distros. The `tcz` command can be used to load external "
"packages from the TinyCore Linux distribution, also known as _tinycore_. A "
"tinycore package is a mountable file system image, containing all the "
"package files, including a file listing any additional package dependencies. "
"To load these packages, u-root provides the `tcz` command which fetches the "
"package and needed dependencies. Hence, if a user wants emacs, they need "
"merely type `tcz emacs`, and emacs will become available in "
"`/usr/local/bin`. The tinycore packages directory can be a persistent "
"directory or it can be empty on each boot."
msgstr ""

#: src/u-root.md:474
msgid ""
"The `tcz` command is quite flexible as to what packages it loads and where "
"they are loaded from. Users can specify the host name which provides the "
"packages, the TCP port on which to connect, the version of tinycore to use, "
"and the architecture. The `tcz` command must loopback mount each package as "
"it is fetched, and hence must cache them locally. It will not refetch "
"already cached packages. This cache can be volatile or maintained on more "
"permanent storage. Performance varies depending on the network being used "
"and the number of packages being loaded, but averages about 1 second per "
"package on a WIFI-attached laptop. U-root also provides a small web server, "
"called _srvfiles_, that can be used to serve locally cached tinycore "
"packages for testing. The entire server is 18 lines of Go."
msgstr ""

#: src/u-root.md:486
msgid "On-Demand Compilation"
msgstr ""

#: src/u-root.md:488
msgid ""
"On-Demand compilation is one of the oldest ideas in computer science. "
"Slimline Open Firmware (SLOF)[^7] is a FORTHbased implementation of Open "
"Firmware developed by IBM for some of its Power and Cell processors. SLOF is "
"capable of storing all of Open Firmware as source in the flash memory and "
"compiling components to indirect threading on demand[^2]."
msgstr ""

#: src/u-root.md:494
msgid ""
"In the last few decades, as our compiler infrastructure has gotten slower "
"and more complex, true on-demand compilation has split into two different "
"forms. First is the on-demand compilation of source into executable byte "
"codes, as in Python. The byte codes are not native but are more efficient "
"than source. If the python interpreter finds the byte code it will interpret "
"that instead of source to provide improved performance. Java takes the "
"process one step further with the Just In Time compilation of byte code to "
"machine code[^20] to boost performance."
msgstr ""

#: src/u-root.md:503
msgid "Embedding kernel and root file systems in flash"
msgstr ""

#: src/u-root.md:505
msgid ""
"The LinuxBIOS project[^14] [^1], together with clustermatic[^25], used an "
"embedded kernel and simple root file system to manage supercomputing "
"clusters. Due to space constraints of 1 MiB or less of flash, clusters "
"embedded only a single-processor Linux kernel with a daemon. The daemon was "
"a network bootloader that downloaded a more complex SMP kernel and root file "
"system and started them. Clusters built this way were able to boot 1024 "
"nodes in the time it took the standard PXE network boot firmware to find a "
"working network interface."
msgstr ""

#: src/u-root.md:514
msgid ""
"Early versions of One Laptop Per Child used LinuxBIOS, with Linux in flash "
"as a boot loader, to boot the eventual target. This system was very handy, "
"as they were able to embed a full WIFI stack in flash with Linux, and could "
"boot test OLPC images over WIFI. The continuing growth of the Linux kernel, "
"coupled with the small flash size on OLPC, eventually led OLPC to move to "
"Open Firmware."
msgstr ""

#: src/u-root.md:520
msgid ""
"AlphaPower shipped their Alpha nodes with a so-called Direct Boot Linux, or "
"DBLX. This work was never published, but the code was partially released on "
"sourceforge.net just as AlphaPower went out of business.  Compaq also worked "
"with a Linux-As-Bootloader for the iPaq."
msgstr ""

#: src/u-root.md:525
msgid ""
"Car computers and other embedded ARM systems frequently contain a kernel and "
"an ext2 formatted file system in NOR flash, that is, flash that can be "
"treated as memory instead of a block device. Many of these kernels use the "
"so-called eXecute In Place[^3] (XIP) patch, which allows the kernel to page "
"binaries directly from the memory-addressable flash rather than copying it "
"to RAM, providing a significant savings in system startup time. A downside "
"of this approach is that the executables can not be compressed, which puts "
"further pressure on the need to optimize binary size. NOR flash is very "
"slow, and paging from it comes at a significant performance cost. Finally, "
"an uncompressed binary image stored in NOR flash has a much higher monetary "
"cost than the same image stored in RAM since the cost per bit is so much "
"higher."
msgstr ""

#: src/u-root.md:537
msgid ""
"UEFI[^12] contains a non-Linux kernel (the UEFI firmware binary) and a full "
"set of drivers, file systems, network protocol stacks, and command binaries "
"in the firmware image. It is a full operating system environment realized as "
"firmware."
msgstr ""

#: src/u-root.md:541
msgid ""
"The ONIE project[^23] is a more recent realization of the Kernel-in-flash "
"idea, based on Linux. ONIE packs a Linux kernel and Busybox binaries into a "
"very small package. Since the Linux build process allows an initial RAM file "
"system (initramfs) to be built directly into the kernel binary, some "
"companies are now embedding ONIE images into flash with coreboot. Sage "
"Engineering has shown a bzImage with a small Busybox packed into a 4M image. "
"ONIE has brought new life to an old idea: packaging a kernel and small set "
"of binaries in flash to create a fast, capable boot system."
msgstr ""

#: src/u-root.md:550
msgid "References"
msgstr ""

#: src/u-root.md:552
msgid ""
"AGNEW, A., SULMICKI, A., MINNICH, R., AND ARBAUGH, W. A. Flexibility in rom: "
"A stackable open source bios. In USENIX Annual Technical Conference, FREENIX "
"Track (2003), pp. 115–124. [^2]: (AUTHOR OF SLOF), S. B. Personal "
"conversation. [^3]: BENAVIDES, T., TREON, J., HULBERT, J., AND CHANG, W. The "
"enabling of an execute-in-place architecture to reduce the embedded system "
"memory footprint and boot time. Journal of computers 3, 1 (2008), 79–89. "
"[^4]: BOGOWITZ, B., AND SWINFORD, T. Intel⃝R active management technology "
"reduces it costs with improved pc manageability. Technology@ Intel Magazine "
"(2004). [^5]: CELEDA, P., KREJCI, R., VYKOPAL, J., AND DRASAR, M. Embedded "
"malware-an analysis of the chuck norris botnet. In Computer Network Defense "
"(EC2ND), 2010 European Conference on (2010), IEEE, pp. 3–10. [^6]: CUI, A., "
"COSTELLO, M., AND STOLFO, S. J. When firmware modifications attack: A case "
"study of embedded exploitation. In NDSS (2013). [^7]: DALY, D., CHOI, J. H., "
"MOREIRA, J. E., AND WATERLAND, A. Base operating system provisioning and "
"bringup for a commercial supercomputer. In Parallel and Distributed "
"Processing Symposium, 2007. IPDPS 2007. IEEE International (2007), IEEE, pp. "
"1–7. [^8]: DURUMERIC, Z., KASTEN, J., ADRIAN, D., HALDERMAN, J. A., BAILEY, "
"M., LI, F., WEAVER, N., AMANN, J., BEEKMAN, J., PAYER, M., ET AL. The matter "
"of heartbleed. In Proceedings of the 2014 Conference on Internet Measurement "
"Conference (2014), ACM, pp. 475–488. [^9]: KALLENBERG, C., AND BULYGIN, Y. "
"All your boot are belong to us intel, mitre. cansecwest 2014. [^10]: "
"KALLENBERG, C., KOVAH, X., BUTTERWORTH, J., AND CORNWELL, S. Extreme "
"privilege escalation on windows 8/uefi systems. [^11]: KOZIOL, J., "
"LITCHFIELD, D., AITEL, D., ANLEY, C., EREN, S., MEHTA, N., AND HASSELL, R. "
"The Shellcoder’s Handbook. Wiley Indianapolis, 2004. [^12]: LEWIS, T. Uefi "
"overview, 2007. [^13]: MAY,D.Occam.ACMSigplanNotices18,4(1983),69–79. [^14]: "
"MINNICH, R. G. Linuxbios at four. Linux J. 2004, 118 (Feb. 2004), 8–. [^15]: "
"MOON, S.-P., KIM, J.-W., BAE, K.-H., LEE, J.-C., AND SEO, D.-W. Embedded "
"linux implementation on a commercial digital tv system. Consumer "
"Electronics, IEEE Transactions on 49, 4 (Nov 2003), 1402–1407. [^16]: PIKE, "
"R. Another go at language design. Stanford University Computer Systems "
"Laboratory Colloquium. [^17]: RITCHIE, D. M. The limbo programming language. "
"Inferno Programmer’s Manual 2 (1997). [^18]: SACCO, A. L., AND ORTEGA, A. A. "
"Persistent bios infection. In CanSecWest Applied Security Conference (2009). "
"[^19]: SAMPATHKUMAR, R. Vulnerability Management for Cloud Computing-2014: A "
"Cloud Computing Security Essential. Rajakumar Sampathkumar, 2014. [^20]: "
"SUGANUMA, T., OGASAWARA, T., TAKEUCHI, M., YASUE, T., KAWAHITO, M., "
"ISHIZAKI, K., KOMATSU, H., AND NAKATANI, T. Overview of the ibm java "
"just-in-time compiler. IBM systems Journal 39, 1 (2000), 175–193. [^21]: "
"TEAM, G. The go programming language specification. Tech. rep., Technical "
"Report [http://golang](http://golang/). org/doc/doc/go spec. html, Google "
"Inc, 2009. [^22]: VAN HENSBERGEN, E., AND MINNICH, R. Grave robbers from "
"outer space: Using 9p2000 under linux. In USENIX Annual Technical "
"Conference, FREENIX Track (2005), pp. 83–94. [^23]: VARIOUS. No papers have "
"been published on onie; see onie.org. [^24]: VARIOUS. No papers were "
"published; see perllinux.sourceforge.net. [^25]: WATSON, G. R., SOTTILE, M. "
"J., MINNICH, R. G., CHOI, S.-E., AND HERTDRIKS, E. Pink: A 1024-node "
"single-system image linux cluster. In High Performance Computing and Grid in "
"Asia Pacific Region, 2004. Proceedings. Seventh International Conference on "
"(2004), IEEE, pp. 454–461. [^26]: WELLS, N. Busybox: A swiss army knife for "
"linux. Linux J. 2000, 78es (Oct. 2000). [^27]: WINTERBOTTOM, P. Alef "
"language reference manual. Plan 9 Programmer’s Man (1995)."
msgstr ""

#: src/u-root-qemu-demo.md:3
msgid ""
"You can try out LinuxBoot without needing to build anything! You can try out "
"LinuxBoot needing only 3 commands."
msgstr ""

#: src/u-root-qemu-demo.md:6
msgid ""
"We have made Initial Ram File System (initramfs) images available for four "
"architectures: arm, aarch64, amd64 (a.k.a. x86_64), and riscv64."
msgstr ""

#: src/u-root-qemu-demo.md:9
msgid ""
"For now, we only have a kernel ready for x86_64, so the instructions below "
"apply to that."
msgstr ""

#: src/u-root-qemu-demo.md:12
msgid ""
"First, you can get the initramfs image, which mainly contains Go programs "
"from the u-root project."
msgstr ""

#: src/u-root-qemu-demo.md:19
msgid ""
"Next, you will need to get a kernel. We use a pre-built kernel from Arch "
"Linux."
msgstr ""

#: src/u-root-qemu-demo.md:26
msgid "Now you are ready to test LinuxBoot out."
msgstr ""

#: src/u-root-qemu-demo.md:29 src/u-root-qemu-demo.md:36
msgid "\"console=ttyS0\""
msgstr ""

#: src/u-root-qemu-demo.md:33
msgid "Or, for example, on Darwin:"
msgstr ""

#: src/u-root-qemu-demo.md:40
msgid "You will see the following:"
msgstr ""

#: src/u-root-qemu-demo.md:54
msgid "You can type uname:"
msgstr ""

#: src/u-root-qemu-demo.md:62
msgid "To exit qemu, just run the poweroff command:"
msgstr ""

#: src/u-root-qemu-demo.md:69
msgid "You have just run your first LinuxBoot kernel."
msgstr ""

#: src/utilities/index.md:1
msgid "LinuxBoot Utilities"
msgstr ""

#: src/utilities/index.md:3
msgid ""
"In order to bootstrap, build and maintain LinuxBoot projects, we provide a "
"handful of utilities for extracting, reducing, reworking, and stitching "
"firmware images."
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:3
msgid "Authors: Ryan O'Leary, Gan Shun Lim and Andrea Barberio"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:5
msgid ""
"In previous chapters, you learned how to read a raw ROM image from a flash "
"part. If you've been following along, you know the next step is to insert a "
"Linux kernel."
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:9
msgid ""
"Inspecting and modifying ROM images is tricky and can involve a fair amount "
"of tinkering. These images typically contain a number of file systems, "
"drivers, tables, data structures and opaque blobs. They also differ "
"significantly from the UNIX model of a file systems, thus cannot be "
"reasonably mounted in Linux."
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:14
msgid ""
"UEFI Tool Kit (UTK) is intended to be a one-stop-shop for reading, writing "
"and modifying UEFI images -- the most common type of firmware image for x86 "
"systems. UTK can parse a number of data structures including UEFI firmware "
"volumes, Intel firmware descriptors and FIT."
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:19
msgid "In this chapter, we'll go over how to:"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:21
msgid "Install UTK"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:22
msgid "Inspect ROMs"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:23
msgid "Modify ROMs"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:24
msgid "Common pitfalls"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:25
msgid "Extend UTK with additional commands"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:27
msgid "Synopsis"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:36
msgid "Quick start"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:38
msgid "We assume you have a way to read and write the FLASH into a file."
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:40
msgid ""
"Let's assume you have read FLASH into an image called ROM.bin and you have a "
"kernel, called bzImage, which you want to insert into ROM.bin. Be sure the "
"kernel is buildable as an EFI driver (DXE); see the pitfalls section. The "
"easiest option is to replace the UEFI shell. This is a quick and easy way to "
"get started. In the long term, you want to remove as much of UEFI as "
"possible, but replacing the shell is always our first step on a new board."
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:48
msgid "Get the tool:"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:54
msgid "Replace the shell:"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:60
msgid ""
"After that, you can flash NEWROM.bin and test. If anything goes wrong, such "
"as not enough space, you will need to refer to the more detailed "
"instructions below."
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:64
msgid "Installation"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:66
msgid ""
"At the time of writing, you must clone and build UTK from source -- binary "
"distributions are not officially available. The source code resides in the "
"[Fiano Github project](https://github.com/linuxboot/fiano/)."
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:70
msgid ""
"Aside: what is the difference between Fiano and UTK? The Fiano project "
"contains a few more tools besides UTK, but UTK is a big element."
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:73
msgid "We'll assume you already have Go installed. Check your installation with:"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:80
msgid ""
"Linux and the latest stable version of Go are recommended. Either download "
"the official binary distributions of Go or install from source. See "
"[https://golang.org/](https://golang.org/) for details."
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:84
msgid "With Go, download and install UTK:"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:90
msgid ""
"Running the above line installs `utk` to your `$GOPATH/bin` directory (or "
"`$HOME/go/bin` if the `GOPATH` environment variable is not set). Adding this "
"directory to your `$PATH` is recommended."
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:94
msgid "Make sure it works with:"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:124
msgid ""
"Don't fret if your list of operations differs. UTK is an evolving project!"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:126
msgid "Inspecting ROMs"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:128
msgid ""
"Throughout this section, we'll demonstrate commands for inspecting a UEFI "
"image. When confronted with a new image, run these commands to get a \"lay "
"of the land\"."
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:132
msgid "Start by downloading the UEFI image used in these examples:"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:134
msgid ""
"```\n"
"wget "
"https://github.com/linuxboot/fiano/raw/master/integration/roms/OVMF.rom\n"
"```"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:138
msgid ""
"Aside: alternatively, all UTK operations should work with your own UEFI "
"images. Simply substitute \"OVMF.rom\" with your own UEFI image in all the "
"examples below. If you encounter any problems, please file an issue at "
"[https://github.com/linuxboot/fiano/issues](https://github.com/linuxboot/fiano/issues)."
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:143
msgid "First, it is advisable to print a count of each firmware element:"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:145
msgid ""
"```\n"
"$ utk OVMF.rom count\n"
"{\n"
"        \"FirmwareTypeCount\": {\n"
"                \"BIOSRegion\": 1,\n"
"                \"File\": 118,\n"
"                \"FirmwareVolume\": 5,\n"
"                \"Section\": 365\n"
"        },\n"
"        \"FileTypeCount\": {\n"
"                \"EFI_FV_FILETYPE_APPLICATION\": 2,\n"
"                \"EFI_FV_FILETYPE_DRIVER\": 94,\n"
"                \"EFI_FV_FILETYPE_DXE_CORE\": 1,\n"
"                \"EFI_FV_FILETYPE_FFS_PAD\": 7,\n"
"                \"EFI_FV_FILETYPE_FIRMWARE_VOLUME_IMAGE\": 1,\n"
"                \"EFI_FV_FILETYPE_FREEFORM\": 3,\n"
"                \"EFI_FV_FILETYPE_PEIM\": 7,\n"
"                \"EFI_FV_FILETYPE_PEI_CORE\": 1,\n"
"                \"EFI_FV_FILETYPE_RAW\": 1,\n"
"                \"EFI_FV_FILETYPE_SECURITY_CORE\": 1\n"
"        },\n"
"        \"SectionTypeCount\": {\n"
"                \"EFI_SECTION_DXE_DEPEX\": 44,\n"
"                \"EFI_SECTION_FIRMWARE_VOLUME_IMAGE\": 2,\n"
"                \"EFI_SECTION_GUID_DEFINED\": 1,\n"
"                \"EFI_SECTION_PE32\": 99,\n"
"                \"EFI_SECTION_RAW\": 21,\n"
"                \"EFI_SECTION_USER_INTERFACE\": 99,\n"
"                \"EFI_SECTION_VERSION\": 99\n"
"        }\n"
"}\n"
"```"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:178
msgid ""
"The definition of a \"Firmware Element\" is in order. Firmware images are "
"hierarchical and can be represented as a tree. Each node in the tree is a "
"\"Firmware Element\". Each element has a type such as \"BIOSRegion\", "
"\"FirmwareVolume\", \"File\" and \"Section\" as seen above. Files (and "
"sections) themselves have an additional type dictated by the UEFI spec. "
"There are three major file types you should be aware of:"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:185
msgid ""
"`EFI_FV_FILETYPE_DRIVER`: This is the most numerous file type and is often "
"called a \"DXE\". They persist in memory even after their main function "
"exits."
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:187
msgid ""
"`EFI_FV_FILETYPE_APPLICATION`: Applications do not persist in memory after "
"exiting. For example, the EFI Shell is an EFI Application."
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:189
msgid ""
"`EFI_FV_FILETYPE_FIRMWARE_VOLUME_IMAGE`: These file types allow nesting "
"firmware volumes. You will see this when an entire firmware volume is "
"compressed."
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:193
msgid "TODO: Diagram showing a tree of these firmware elements."
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:195
msgid ""
"To view a human-readable tree of all the firmware elements, types and sizes, "
"run:"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:221
msgid ""
"This format is compact and easy for humans reading, but not ideal for "
"machine consumption. Use the `json` command to print everything (including "
"much more metadata) as JSON:"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:229
msgid ""
"Combine `utk` with the JSON query command, `jq` (`sudo apt-get install jq`), "
"and other UNIX commands to quickly write powerful queries. For example, the "
"following lists all the GUIDs, sorted and without duplicates:"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:233
msgid ""
"```\n"
"$ utk OVMF.rom json | jq -r '..|.GUID?|select(type==\"string\")' | sort -u\n"
"00000000-0000-0000-0000-000000000000\n"
"0167CCC4-D0F7-4F21-A3EF-9E64B7CDCE8B\n"
"0170F60C-1D40-4651-956D-F0BD9879D527\n"
"021722D8-522B-4079-852A-FE44C2C13F49\n"
"025BBFC7-E6A9-4B8B-82AD-6815A1AEAF4A\n"
"...\n"
"```"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:243
msgid "To only print the JSON for specific files, use the find command:"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:245
msgid ""
"```\n"
"# The find command uses a regex to match on the name or GUID.\n"
"# These three examples find and print the JSON for the same file:\n"
"$ utk OVMF.rom find 'Sh.*'\n"
"$ utk OVMF.rom find 'Shell'\n"
"$ utk OVMF.rom find 7C04A583-9E3E-4F1C-AD65-E05268D0B4D1\n"
"{\n"
"        \"Header\": {\n"
"                \"UUID\": {\n"
"                        \"UUID\": \"7C04A583-9E3E-4F1C-AD65-E05268D0B4D1\"\n"
"                },\n"
"                \"Type\": 9,\n"
"                \"Attributes\": 0\n"
"        },\n"
"        \"Type\": \"EFI_FV_FILETYPE_APPLICATION\",\n"
"        \"Sections\": [\n"
"                {\n"
"                        \"Header\": {\n"
"                                \"Type\": 21\n"
"                        },\n"
"                        \"Type\": \"EFI_SECTION_USER_INTERFACE\",\n"
"                        \"ExtractPath\": \"\",\n"
"                        \"Name\": \"Shell\"\n"
"                },\n"
"                ...\n"
"        ],\n"
"        \"ExtractPath\": \"\",\n"
"        \"DataOffset\": 24\n"
"}\n"
"```"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:276
msgid ""
"Note that UEFI uses GUIDs to identify files. Some files also have a name "
"which is stored within the file's UI section. Like `find`, most of UTKs "
"commands let you match a file by its name or GUID."
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:280
msgid ""
"The examples up until now have only dealt with file metadata and not the "
"file's contents. The `extract <DIR>` command extracts all the files from the "
"image and saves them to `<DIR>`. `<DIR>/summary.json` lists all the paths to "
"the extracted files along with their metadata."
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:289
msgid "After modifying the files, they can be reassembled with:"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:295
msgid "Modifying ROMs"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:297
msgid ""
"First, let's verify the image works by running it inside QEMU. This step is "
"not absolutely necessary, but gives us confidence the image works before and "
"after each change we make."
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:305
msgid "For the provided OVMF.rom image, this should boot to the EDK2 shell."
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:307
msgid "TODO: include screenshot of the EDK2 shell"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:309
msgid ""
"Multiple commands can be used together to form a pipeline. The first "
"argument always loads the image into memory and the last argument typically "
"writes the output. The commands in between operate on the image in memory "
"and are reminiscent of a UNIX pipeline. The general syntax is:"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:321
msgid "To see the pipeline in action, we introduce two new commands:"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:323
msgid ""
"`remove <file GUID or NAME regex>`: Remove a file from a firmware volume. "
"The search has the same semantics as `find`."
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:325
msgid ""
"`replace_pe32 <file GUID or NAME regex> <FILE>`: Replace the pe32 section of "
"a file with the given file. The search has the same semantics as `find`. The "
"file must be a valid pe32 binary."
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:328
msgid ""
"`save <FILE>`: Save the firmware image to the given file. Usually, this is "
"the last command in a pipeline."
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:331
msgid ""
"The following pipeline removes some unnecessary drivers (anything that "
"starts with Usb and the Legacy8259 driver which has the GUID "
"79ca4208-bba1-4a9a-8456-e1e66a81484e) and replaces the Shell with Linux. "
"Often you need to remove drivers to make room for Linux which makes the "
"pipeline convenient. This is the essence of LinuxBoot:"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:347
msgid ""
"That's all there to it! Try experimenting with the other commands such as "
"insert."
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:350
msgid "Common Pitfalls"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:352
msgid "Kernel is not built as a DXE or has not enabled UEFI stub mode"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:354
msgid ""
"In order to be properly bootable as a DXE, kernels must have the following "
"enabled:"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:362
msgid "Files are missing from the Firmware Volume"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:364
msgid ""
"When UTK does not recognize the compression format used by the particular "
"image, the files within it are not listed."
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:367
msgid "In the wild, three compression schemes are common:"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:369
msgid "Compression"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:369
msgid "GUID"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:369
msgid "UTK Support"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:371
msgid "Uncompressed"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:371 src/utilities/UEFI_Tool_Kit.md:372
msgid "Fully supported"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:372
msgid "LZMA"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:372
msgid "EE4E5898-3914-4259-9D6E-DC7BD79403CF"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:373
msgid "LZMA + x86"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:373
msgid "D42AE6BD-1352-4BFB-909A-CA72A6EAE889"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:373
msgid "Supported, but not tested"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:374
msgid "Tianocore"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:374
msgid "A31280AD-481E-41B6-95E8-127F4C984779"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:374
msgid ""
"Not supported, see [\\#226](https://github.com/linuxboot/fiano/issues/226)"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:376
msgid ""
"To determine which compression scheme you are using, search for the "
"respective GUID in the json summary."
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:379
msgid "File size too big"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:385
msgid ""
"When saving a UEFI image, files are added successively to each firmware "
"volume. The first file which overflows the volume's size causes this error."
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:388
msgid ""
"If you were inserting files, you will need to delete existing files to make "
"room."
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:390
msgid ""
"There is a special cases where this error is generated without any "
"operations:"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:396
msgid "How can this be? No changes should be made to the image!"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:398
msgid ""
"Not quite (and the complete list of differences can be found in the \"binary "
"equality section\") -- compressed volumes are recompressed."
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:401
msgid ""
"By default, UTK uses the Go compressor, which is generally worse than the "
"compression found in most UEFI images. Pass `--systemXZ=xz` as the first "
"argument to UTK to use a better compressor."
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:405
msgid ""
"(TODO for everything after this point) Arbitrary data before or after the "
"image"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:407
msgid ""
"Find a general solution which works for all images is a topic of research: "
"[\\#200](https://github.com/linuxboot/fiano/issues/200)."
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:410
msgid "Hard-coded addresses"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:412
msgid "Binary equality"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:414
#: src/coreboot.u-root.systemboot/index.md:404
#: src/coreboot.u-root.systemboot/index.md:408
#: src/coreboot.u-root.systemboot/index.md:434
msgid "TODO"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:416
msgid "Extending UTK"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:418
msgid "Visitor pattern means decoupling the structure from the operations."
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:420
msgid "pkg/uefi: structure"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:421
msgid "pkg/visitors: operations"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:423
msgid "Good resources:"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:425
msgid "https://sourcemaking.com/design_patterns/visitor"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:426
msgid "https://en.wikipedia.org/wiki/Visitor_pattern"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:428
msgid ""
"A good visitor still works when new Firmware are introduced. A good Firmware "
"still works when a new visitor is introduced."
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:431
msgid "AST"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:433
msgid ""
"Abstract Syntax Tree -- this is a concept borrowed from compilers. When "
"you're extracting the DXE to create a tree of structs containing a "
"simplified model, you're essentially creating an AST. Then think about how "
"patterns used in compiler architecture might apply to UTK."
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:438
msgid "Visitor Interface"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:440
msgid "Each visitor implements the following:"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:447
msgid "// ...\n"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:451
msgid ""
"Think of a visitor as an \"action\" or a \"transformation\" being applied on "
"the AST."
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:454
msgid "Visitor"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:456
msgid ""
"A struct implementing Visitor performs a transformation on the AST, for "
"example:"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:463
msgid "// Recursively apply on files in the FV.\n"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:480
msgid "You can imagine visitors being implemented for other actions, such as:"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:482
msgid "Remove a DXE with the given GUID from the AST"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:483
msgid "Replace a GUID with a file"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:484
msgid "Validate that all the nodes in the tree are valid"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:485
msgid "Find compressed files in the tree and decompress them"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:486
msgid "Assemble the AST back into an image."
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:487
msgid ""
"Recursively write the AST to the filesystem (what you currently do with "
"extract)"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:488
msgid "Print an overview of the files to the terminal for debugging"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:491
msgid ""
"It is easy to add more visitors without modifying existing code. Each action "
"can be in a separate file."
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:494
msgid "Applying"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:496
msgid ""
"Visitors are applied to the AST. Each node in the AST has an \"Apply\" "
"method, for example:"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:505
msgid "This is so the visitors can be applied recursively over the AST."
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:507
msgid "To apply the above RenameDXE visitor, you'd run:"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:510
msgid "\"Shell\""
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:510
msgid "\"NotShell\""
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:514
msgid "Chaining Visitors Together"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:516
msgid ""
"It would be exciting/useful to be able to chain these small actions together "
"through the command line. For example:"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:528
msgid ""
"Again, it is easy to write new actions in Go which modify nodes in the AST. "
"Create a new file, new struct, and implement the "
"visitFV/visitFile/visitSection methods to modify the AST."
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:532
msgid "TODO: reference the UEFI spec."
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:534
msgid "TODO: mention alternatives"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:536
msgid "binwalk"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:537
msgid "fresh0r/romdump"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:538
msgid "UEFITool"
msgstr ""

#: src/utilities/UEFI_Tool_Kit.md:539
msgid "uefi-firmware-parser"
msgstr ""

#: src/utilities/cpu.md:1
msgid "The u-root `cpu` command"
msgstr ""

#: src/utilities/cpu.md:3
msgid ""
"Do you want to have all the tools on your  system that you have on your "
"desktop, but you can't get them to fit in your tiny flash part? Do you want "
"all your desktop files visible on your  system, but just remembered there's "
"no disk on your  system? Are you tired of using `scp` or `wget` to move "
"files around? Do you want to run `emacs` or `vim` on the  machine, but know "
"they can't ever fit? What about `zsh`? How about being able to run commands "
"on your  machine and have the output appear on your home file system? You "
"say you'd like to make this all work without having to fill out web forms in "
"triplicate to get your organization to Do Magic to your desktop?"
msgstr ""

#: src/utilities/cpu.md:13
msgid ""
"**Your search is over: `cpu` is here to answer all your usability needs.**"
msgstr ""

#: src/utilities/cpu.md:15
msgid "The problem: running your program on some other system"
msgstr ""

#: src/utilities/cpu.md:17
msgid ""
"People often need to run a command on a remote system. That is easy when the "
"remote system is the same as the system you are on, e.g., both systems are "
"Ubuntu 16.04; and all the libraries, packages, and files are roughly the "
"same. But what if the systems are different, say, Ubuntu 16.04 and Ubuntu "
"18.10? What if one is Centos, the other Debian? What if a required package "
"is missing on the remote system, even though in all other ways they are the "
"same?"
msgstr ""

#: src/utilities/cpu.md:24
msgid ""
"While these systems are both Linux, and hence can provide Application Binary "
"Interface (ABI) stability at the system call boundary, above that boundary "
"stability vanishes. Even small variations between Ubuntu versions matter: "
"symbol versions in C libraries differ, files are moved, and so on."
msgstr ""

#: src/utilities/cpu.md:29
msgid ""
"What is a user to do if they want to build a binary on one system, and run "
"it on another system?"
msgstr ""

#: src/utilities/cpu.md:32
msgid ""
"The simplest approach is to copy the source to that other system and compile "
"it. That works sometimes. But there are limits: copying the source might not "
"be allowed; the code might not even compile on the remote system; some "
"support code might not be available, as for a library; and for embedded "
"systems, there might not be a compiler on the remote system. Copy and "
"compile is not always an option. In fact it rarely works nowadays, when even "
"different Linux distributions are incompatible."
msgstr ""

#: src/utilities/cpu.md:40
msgid ""
"The next option is to use static linking. Static linking is the oldest form "
"of binary on Linux systems. While it has the downside of creating larger "
"binaries, in an age of efficient compilers that remove dead code, 100 "
"gigabit networks, and giant disks and memory, that penalty is not the "
"problem it once was. The growth in size of static binaries is nothing like "
"the growth in efficiency and scale of our resources. Nevertheless, static "
"linking is frowned upon nowadays and many libraries are only made available "
"for dynamic linking."
msgstr ""

#: src/utilities/cpu.md:48
msgid ""
"Our user might use one of the many tools that package a binary and all its "
"libraries into a single file, to be executed elsewhere. The u-root project "
"even offers one such tool, called `pox`, for portable executables. `Pox` "
"uses the dynamic loader to figure out all the shared libraries a program "
"uses, and place them into the archive as well. Further, the user can specify "
"additional files to carry along in case they are needed."
msgstr ""

#: src/utilities/cpu.md:55
msgid ""
"The problem here is that, if our user cares about binary size, this option "
"is even worse. Dead code removal won’t work; the whole shared library has to "
"be carried along. Nevertheless, this can work, in some cases."
msgstr ""

#: src/utilities/cpu.md:59
msgid ""
"So our user packages up their executable using `pox` or a similar tool, uses "
"`scp` to get it to the remote machine, logs in via `ssh`, and all seems to "
"be well, until at some point there is another message about a missing shared "
"library! How can this be? The program that packaged it up checked for all "
"possible shared libraries."
msgstr ""

#: src/utilities/cpu.md:65
msgid ""
"Unfortunately, shared libraries are now in the habit of loading other shared "
"libraries, as determined by reading text files. It’s no longer possible to "
"know what shared libraries are used; they can even change from one run of "
"the program to the next. One can not find them all just by reading the "
"shared library itself. A good example is the name service switch library, "
"which uses `/etc/nsswitch.conf` to find other shared libraries. If "
"`nsswitch.conf` is missing, or a library is missing, some versions of the "
"name service switch library will core dump."
msgstr ""

#: src/utilities/cpu.md:74
msgid ""
"Not only must our user remember to bring along `/etc/nsswitch.conf`, they "
"must also remember to bring along all the libraries it might use. This is "
"also true of other services such as Pluggable Authentication Modules (PAM). "
"And, further, the program they bring along might run other programs, with "
"their own dependencies. At some point, as the set of files grows, frustrated "
"users might decide to gather up all of `/etc/`, `/bin`, and other "
"directories, in the hope that a wide enough net might bring along all that’s "
"needed. The remote system will need lots of spare disk or memory! We’re "
"right back where we started, with too many files for too little space."
msgstr ""

#: src/utilities/cpu.md:84
msgid ""
"In the worst case, to properly run a binary from one system, on another "
"system, one must copy everything in the local file system to the remote "
"system. That is obviously difficult, and might be impossible if the remote "
"system has no disk, only memory."
msgstr ""

#: src/utilities/cpu.md:89
msgid ""
"One might propose having the remote system mount the local system via NFS or "
"Samba. While this was a common approach years ago, it comes with its own set "
"of problems: all the remote systems are now hostage to the reliability of "
"the NFS or Samba server. But there’s a bigger problem: there is still no "
"guarantee that the remote system is using the same library versions and "
"files that the user’s desktop is using. The NFS server might provide, e.g. "
"SUSE, to the remote system; the user’s desktop might be running Ubuntu. If "
"the user compiles on their desktop, the binary might still not run on the "
"remote system, as the SUSE libraries might be different. This is a common "
"problem."
msgstr ""

#: src/utilities/cpu.md:99
msgid ""
"Still worse, with an NFS root, everyone can see everyone’s files. It’s like "
"living in an apartment building with glass walls. Glass houses only look "
"good in architecture magazines. People want privacy."
msgstr ""

#: src/utilities/cpu.md:103
msgid "What SSH does not provide"
msgstr ""

#: src/utilities/cpu.md:105
msgid ""
"`ssh` solves the problem of safely getting logged in to a remote machine. "
"While this is no small accomplishment, it is a lot like being parachuted "
"into a foreign land, where the rules are changed. It’s a lot nicer, when "
"going to a new place, to be able to bring along some survival gear, if not "
"your whole house!"
msgstr ""

#: src/utilities/cpu.md:110
msgid ""
"Users need a way to log in to a machine, in a way similar to `ssh`, but they "
"need to bring their environment with them. They need their login directory; "
"their standard commands; their configuration files; and they need some "
"privacy. Other users on the machine should not be able to see any of the "
"things they bring with them. After all, everyone who goes camping wants to "
"believe they are the only people at that campground!"
msgstr ""

#: src/utilities/cpu.md:117
msgid "How `cpu` provides what we need"
msgstr ""

#: src/utilities/cpu.md:119
msgid ""
"`cpu` is a Go-based implementation of Plan 9's `cpu` command. It uses the go "
"`ssh` package, so all your communications are as secure as `ssh`. It can be "
"started from `/sbin/init` or even replace `/sbin/init`, so you have a tiny "
"flash footprint. You can see the code at "
"[github.com:u-root/cpu](https://github.com/u-root/cpu). It's also small: "
"less than 20 files, including tests."
msgstr ""

#: src/utilities/cpu.md:126
msgid ""
"`cpu` runs as both a client (on your desktop) and an `ssh` server (on your "
"machine). On your desktop, it needs no special privilege. On the system, "
"there is only one binary needed: the `cpu` daemon (`cpud`). As part of "
"setting up a session, in addition to normal `ssh` operations, `cpu` sets up "
"private name space at important places like `/home/$USER`, `/bin, /usr,`and "
"so on. Nobody gets to see what other people’s files are."
msgstr ""

#: src/utilities/cpu.md:133
msgid ""
"`Ssh` provides remote access. `cpu` goes one step further, providing what is "
"called _resource sharing_ -- resources, i.e., files from the client machine "
"can be used directly on the remote machine, without needing to manually copy "
"them. `cpud` implements resource sharing by setting up a `file system`mount "
"on the remote machine and relaying file I/O requests back to the desktop "
"`cpu` process. The desktop command services those requests; you don't need "
"to run a special external server. One thing that is a bit confusing with "
"`cpu`: the desktop client is a file server; the remote server’s Linux kernel "
"is a file client. `cpu` has to do a bit more work to accomplish its task."
msgstr ""

#: src/utilities/cpu.md:143
msgid ""
"`cpu` will change your life. You can forget about moving files via `scp`: "
"once you '`cpu` in', the `/home` directory on your  node is your home "
"directory. You can `cd ~`and see all your files. You can pick any shell you "
"want, since the shell binary comes from your desktop, not flash. You don't "
"have to worry about fitting `zsh` into flash ever again!"
msgstr ""

#: src/utilities/cpu.md:149
msgid ""
"At Google we can now run `chipsec`, which imports 20M of Python libraries, "
"because we have `cpu` and we can redirect `chipsec` output to files in our "
"home directory."
msgstr ""

#: src/utilities/cpu.md:153
msgid "Here is an example session:"
msgstr ""

#: src/utilities/cpu.md:155
msgid ""
"In this command, we `cpu` to a PC Engines APU2. We have built a kernel and "
"u-root initramfs containing just one daemon -- the `cpu` daemon -- into the "
"flash image. The APU2 does not even need a disk; it starts running as a "
"“`cpu` appliance.”"
msgstr ""

#: src/utilities/cpu.md:160
msgid ""
"The `bash` is not on the `cpu` node; it will come from our desktop via the "
"9p mount."
msgstr ""

#: src/utilities/cpu.md:172
msgid ""
"The `bash` and `ls` command, and the shared libraries they need, do not "
"exist on the apu2; `cpu` makes sure that the client provides them to the "
"`cpu` server. The home directory is, similarly, made available to the remote "
"machine from the local machine."
msgstr ""

#: src/utilities/cpu.md:177
msgid ""
"A big benefit of `cpu` is that, as long as the network works, users can "
"create very minimal flash images, containing just the `cpu` daemon, just "
"enough to get the network going. Once the network is up, users can `'cpu` "
"in', and everything they need is there. It actually looks like they are "
"still logged in to their desktop, except, of course, truly local file "
"systems such as `/proc` and `/sys` will come from the machine they are on, "
"not their desktop."
msgstr ""

#: src/utilities/cpu.md:184
msgid "An easy overview of how `cpu` works"
msgstr ""

#: src/utilities/cpu.md:186
msgid ""
"`cpu`, as mentioned, consists of a client and a server. The client is on "
"your desktop (or laptop), and the server is on the remote system. Both "
"client and server use an `ssh` transport, meaning that the “wire” protocol "
"is `ssh`. In this way, `cpu` is just like `ssh`."
msgstr ""

#: src/utilities/cpu.md:191
msgid ""
"As mentioned above, the situation for `cpu` is a bit more complicated than "
"for `ssh`. `cpu` provides resource sharing, but not from the server to the "
"client, but rather from the client to the server. The `cpu` client is a file "
"server; the `cpu` server connects the kernel on the server machine to the "
"file server in the client, as shown below. Things to note:"
msgstr ""

#: src/utilities/cpu.md:197
msgid ""
"`cpud`, on the remote or server machine, sets up a “private name space "
"mount” of `/tmp` for the program. “Private name space mount” just means that "
"only that program, and its children, can see what is in its private `/tmp`. "
"Other, external programs continue to use `/tmp`, but they are _different_ "
"instantiations of `/tmp`."
msgstr ""

#: src/utilities/cpu.md:202
msgid ""
"The private name space mount of `/tmp` is on a filesystem in RAM. The data "
"stored in `/tmp` is not visible to other processes, and not persistent."
msgstr ""

#: src/utilities/cpu.md:204
msgid ""
"`cpud` creates a directory, `cpu`, in the private `/tmp`; and mounts the "
"server on it. This mount point is also invisible outside the process and its "
"children."
msgstr ""

#: src/utilities/cpu.md:207
msgid ""
"To make sure that names like `/bin/bash`, and `/usr/lib/libc.so` work, "
"`cpud` sets up _bind mounts_ from, e.g., `/tmp/cpu/bin` to `/bin`. These are "
"also private mounts, and do not affect any program outside the one `cpud` "
"starts. Anytime the program and its children access files in `/bin`, `/lib`, "
"`/usr`, `/home/$USER`, and so on, they are accessing files from the client "
"machine via the built-in client file server."
msgstr ""

#: src/utilities/cpu.md:213
msgid ""
"The client `cpu` program passes the full environment from the client machine "
"to `cpud`. When the client program requests that, e.g., `bash` be run, the "
"`cpud` uses the PATH environment variable to locate `bash`. Because of the "
"private name space mounts and binds, `bash` will be found in `/bin/bash`, "
"and its libraries will be found in their usual place. This is an essential "
"property of `cpu`, that the names used on the user’s machine work the same "
"way on the remote machine. An overview of the process is shown below."
msgstr ""

#: src/utilities/cpu.md:223
msgid "`cpu` startup"
msgstr ""

#: src/utilities/cpu.md:225
msgid ""
"The startup proceeds in several steps. Every session begins with an initial "
"contact from the `cpu` client to the `cpu` server."
msgstr ""

#: src/utilities/cpu.md:230
msgid ""
"The first step the `cpud` does is set up the mounts back to the client. It "
"then sets up the bind mounts such as `/bin` to `/tmp/cpu/bin`. In the "
"following figure, we compress the Linux kernel mount and bind mounts shown "
"above into a smaller box called “name space.”"
msgstr ""

#: src/utilities/cpu.md:237
msgid "Next, `cpu` and the `cpud` set up the terminal management."
msgstr ""

#: src/utilities/cpu.md:241
msgid ""
"Finally, `cpud` sets up the program to run. Because the PATH variable has "
"been transferred to `cpud`, and the name space includes `/bin` and `/lib`, "
"the `cpud` can do a standard Linux `exec` system call without having to "
"locate where everything is. Native kernel mechanisms create requests as "
"files are referenced, and the `cpu` file server support does the rest."
msgstr ""

#: src/utilities/cpu.md:249
msgid ""
"Why do we only show one program instead of many? From the point of view of "
"`cpud`, it only starts one program. From the point of view of users, there "
"can be many. But if there is more than one program to start, _that is not "
"the responsibility of `cpud`_. If more than one program is run, they will be "
"started by the program that `cpud` started, i.e., a command interpreter like "
"the shell. Or it could be as simple as a one-off command like `date`. From "
"the point of view of `cpud`, it’s all the same. `cpud` will wait until the "
"process it started, and all its children, have exited. But `cpud`’s "
"responsibilities to start a program ends with that first program."
msgstr ""

#: src/utilities/cpu.md:259
msgid ""
"But what happens when `cpud` runs that first program? Here is where it gets "
"interesting, and, depending on your point of view, either magical, "
"confounding, or counter-intuitive. We’ll go with magical."
msgstr ""

#: src/utilities/cpu.md:263
msgid "Starting that first program"
msgstr ""

#: src/utilities/cpu.md:265
msgid ""
"As mentioned above, `cpud` sets up mounts for a name space, and calls the "
"Linux `exec()` call to start the program."
msgstr ""

#: src/utilities/cpu.md:268
msgid ""
"We can actually watch all the `cpu` file server operations. The file server "
"protocol is called 9P2000. We are going to present a filtered version of the "
"file I/O from running a remote `date`; in practice, you can watch all the "
"opens, reads, writes, and closes the remote process performs."
msgstr ""

#: src/utilities/cpu.md:273
msgid ""
"The trace for running `date` starts right when the remote program has called "
"`exec`, and the kernel is starting to find the program to run[^1]. The file "
"opens look like this, on a user’s system:"
msgstr ""

#: src/utilities/cpu.md:286
msgid ""
"The kernel opened `/bin/date`, determined what libraries (files ending in "
"`.so`) it needed, and opened them as well."
msgstr ""

#: src/utilities/cpu.md:289
msgid "We can compare this with a local execution:"
msgstr ""

#: src/utilities/cpu.md:302
msgid ""
"Note that several files do not show up in our trace; they are in `/etc`, and "
"the `cpud` does not set up a bind mount over `/etc`. But the other files "
"look very similar. You might wonder why the local version opens "
"`/etc/localtime`, and the remote version opens "
"`/usr/share/zoneinfo/America/Los_Angeles`."
msgstr ""

#: src/utilities/cpu.md:307
msgid "The reason is that `etc/localtime` is a symlink:"
msgstr ""

#: src/utilities/cpu.md:313
msgid ""
"The access to `/etc/localtime` does not get handled by the server; but the "
"access to `/usr/share/zoneinfo/America/Los_Angeles`does."
msgstr ""

#: src/utilities/cpu.md:316
msgid ""
"What about different architectures? What if we are using an x86 but want to "
"`cpu` to an ARM processor?"
msgstr ""

#: src/utilities/cpu.md:319
msgid ""
"We can set the local `cpu` up to talk to a remote `cpu` that needs different "
"binaries. We might have an entire ARM file system tree in `~/arm`, for "
"example. We would then invoke `cpu` as follows:"
msgstr ""

#: src/utilities/cpu.md:327
msgid ""
"And the remote `cpud`, running on an ARM, would be provided with ARM "
"binaries."
msgstr ""

#: src/utilities/cpu.md:329
msgid "Learning how to use `cpu`"
msgstr ""

#: src/utilities/cpu.md:331
msgid ""
"`Cpu` can be a hard thing to learn, not because it is difficult, but because "
"it is different. To paraphrase Yoda, you have to unlearn what you have "
"learned. Forget about copying files from here to there; when you `cpu` "
"there, it looks like your files are waiting for you."
msgstr ""

#: src/utilities/cpu.md:336
msgid ""
"You can start experimenting and learning about `cpu` by just running it "
"locally."
msgstr ""

#: src/utilities/cpu.md:338
msgid "A set of binaries for you to try"
msgstr ""

#: src/utilities/cpu.md:340
msgid ""
"In order for you to try it out, start by working with the set of `cpu` "
"binaries at "
"[https://github.com/u-root/cpubinaries](https://github.com/u-root/cpubinaries). "
"With them, you can create a bootable, mountable USB image that you can "
"download. The image contains a `cpu` client that runs on Linux, a private "
"key, and, when booted, it starts a `cpu` daemon and waits to serve `cpu` "
"clients. The `cpu` client is statically linked and hence should run on any "
"Linux from the last 10 years or so."
msgstr ""

#: src/utilities/cpu.md:349
msgid "The binaries include:"
msgstr ""

#: src/utilities/cpu.md:351
msgid ""
"A kernel (`cpukernel`) with a built-in initramfs containing `cpud`, as well "
"as a public key. Also included, should you want to build your own, is the "
"config file (`cpu.config`)."
msgstr ""

#: src/utilities/cpu.md:354
msgid ""
"A binary client program, `cpu`, as well as the private key to use. You can "
"place this key in `~/.ssh` or specify it via the `-key` option to `cpu`."
msgstr ""

#: src/utilities/cpu.md:356
msgid ""
"A script to run the USB stick via `qemu` (`TESTQEMU`); and a script to run a "
"`cpu` command (`EXAMPLE`)."
msgstr ""

#: src/utilities/cpu.md:358
msgid "The `extlinux.conf` used for the USB stick."
msgstr ""

#: src/utilities/cpu.md:360
msgid ""
"`usbstick.xz` is a compressed USB stick image that is bootable. It will "
"uncompress to about 7GB. You can use the `TESTQEMU` script to try it out, or "
"use `dd` to write it to a USB stick and boot that stick on an x86 system."
msgstr ""

#: src/utilities/cpu.md:364
msgid ""
"Be careful how you use the keys; they're public. You should really only use "
"them as part of the demo."
msgstr ""

#: src/utilities/cpu.md:367
msgid ""
"The `cpukernel` was built using the `github.com:/mainboards` repo. If you "
"clone this repo, the following commands will rebuild the kernel:"
msgstr ""

#: src/utilities/cpu.md:370
msgid "`cd mainboards/intel/generic`"
msgstr ""

#: src/utilities/cpu.md:371
msgid "`make fetch`"
msgstr ""

#: src/utilities/cpu.md:372
msgid "`make cpukernel`"
msgstr ""

#: src/utilities/cpu.md:374
msgid "How to use the cpu binaries"
msgstr ""

#: src/utilities/cpu.md:376
msgid ""
"You’ll first need to start the server, and we show the entire sequence "
"below, including unpacking the image:"
msgstr ""

#: src/utilities/cpu.md:383
msgid ""
"How you run `qemu` depends on whether you want graphics or not: if you are "
"not in a windowing environment, add `-nographic` to the command below. In "
"any event, at the `boot:` prompt, you can hit return or wait:"
msgstr ""

#: src/utilities/cpu.md:403
msgid ""
"At this point, the `cpu` daemon is running, and you can try the `cpu` "
"command:"
msgstr ""

#: src/utilities/cpu.md:410
msgid "You can log in and notice that things are the same:"
msgstr ""

#: src/utilities/cpu.md:422
msgid ""
"Note that you end up in the same directory on the remote node that you are "
"in on the host; all the files are there. We can run any program on the "
"remote node that we have on the host:"
msgstr ""

#: src/utilities/cpu.md:450
msgid ""
"As you can see, `/tmp/cpu` is mounted via 9p back to the `cpu` client "
"(recall that the `cpu` client is a 9p server, so your files are visible on "
"the remote node). Further, you can see mounts on `/usr`, `/bin`, `/etc`, and "
"so on. For this reason, we can run `date` and it will find its needed "
"libraries in `/usr`, as the `ldd` command demonstrates."
msgstr ""

#: src/utilities/cpu.md:456
msgid "Making cpu easier to use"
msgstr ""

#: src/utilities/cpu.md:458
msgid ""
"If you get tired of typing `-keys`, do the following: put your own `cpu_rsa` "
"in `~/.ssh`; and copy the `cpu` binary to `bin` (or build a new one)."
msgstr ""

#: src/utilities/cpu.md:461
msgid ""
"Warning! The `cpu` keys we provide in the repo are only to be used for this "
"demo. You should not use them for any other purpose, as they are in a Github "
"repo and hence open to the world."
msgstr ""

#: src/utilities/cpu.md:465
msgid "Using some of the namespace"
msgstr ""

#: src/utilities/cpu.md:467
msgid ""
"Sometimes, you don’t want all the `/usr` and `/bin` directories to be "
"replaced with those from your machine. You might, for example, `cpu` into an "
"ARM system, and hence only need a `/home`, but nothing else."
msgstr ""

#: src/utilities/cpu.md:471
msgid ""
"The `-namespace` switch lets you control the namespace. It is structured "
"somewhat like a path variable, with `:`\\-separated components. The default "
"value is `/lib:/lib64:/usr:/bin:/etc:/home`. You can modify it or even force "
"it to be empty: `-namespace=\"\"`, for example. If it is empty, `cpud` will "
"only mount the 9p server on `/tmp/cpu`."
msgstr ""

#: src/utilities/cpu.md:477
msgid ""
"This following example will cpu to an ARM64 host, sharing /home, but nothing "
"else."
msgstr ""

#: src/utilities/cpu.md:483
msgid ""
"For an different architecture system, we might want to specify that the "
"/bin, /lib, and other directories have a different path on the remote than "
"they have locally. The -namespace switch allows this via an = sign:"
msgstr ""

#: src/utilities/cpu.md:491
msgid ""
"In this case, `/bin`, `/usr`, and `/lib` on the remote system are supplied "
"by `/arm/bin`, `/arm/lib`, and `/arm/usr` locally."
msgstr ""

#: src/utilities/cpu.md:494
msgid ""
"If we need to test `cpu` without doing bind mounts, we can specify a `PWD` "
"that requires no mounts and an empty namespace:"
msgstr ""

#: src/utilities/cpu.md:511
msgid ""
"There is a bit of a subtlety about the interaction of the namespace and 9p "
"switches, which we are still discussing: the -namespace value can override "
"the -9p switch."
msgstr ""

#: src/utilities/cpu.md:514
msgid ""
"If you set -9p=false but have a non-empty namespace variable, then 9p will "
"be set to true. So in this example, the -9p switch has no effect:"
msgstr ""

#: src/utilities/cpu.md:521
msgid ""
"Why is this? Because the default value of -namespace is non-empty. The open "
"question: should -9p=false force the namespace to be empty; or should a "
"none-empty namespace for -9p to be true? For now, we have chosen the latter "
"approach."
msgstr ""

#: src/utilities/cpu.md:526
msgid ""
"Another possible approach is to log conflicting settings of these two "
"switches and exit:"
msgstr ""

#: src/utilities/cpu.md:531
msgid "\"\""
msgstr ""

#: src/utilities/cpu.md:534
msgid "We welcome comments on this issue."
msgstr ""

#: src/utilities/cpu.md:536
msgid "cpu and Docker"
msgstr ""

#: src/utilities/cpu.md:538
msgid ""
"Maintaining file system images is inconvenient. We can use Docker containers "
"on remote hosts instead. We can take a standard Docker container and, with "
"suitable options, use docker to start the container with `cpu` as the first "
"program it runs."
msgstr ""

#: src/utilities/cpu.md:543
msgid ""
"That means we can use any Docker image, on any architecture, at any time; "
"and we can even run more than one at a time, since the namespaces are "
"private."
msgstr ""

#: src/utilities/cpu.md:546
msgid "In this example, we are starting a standard Ubuntu image:"
msgstr ""

#: src/utilities/cpu.md:550
msgid ""
"'ubuntu@sha256:073e060cec31fed4a86fcd45ad6f80b1f135109ac2c0b57272f01909c9626486'"
msgstr ""

#: src/utilities/cpu.md:555
msgid ""
"'s platform (linux/arm64/v8) does not match the detected host platform "
"(linux/amd64) and no specific platform was requested\n"
"1970/01/01 21:37:32 CPUD:Warning: mounting /tmp/cpu/lib64 on /lib64 failed: "
"no such file or directory\n"
"$ ls\n"
"bbin  buildbin  env  go    init     lib    proc  tcz  ubin  var\n"
"bin   dev       etc  home  key.pub  lib64  sys   tmp  usr\n"
msgstr ""

#: src/utilities/cpu.md:562
msgid ""
"Note that the image was update and then started. The `/lib64` mount fails, "
"because there is no `/lib64` directory in the image, but that is harmless."
msgstr ""

#: src/utilities/cpu.md:565
msgid ""
"On the local host, on which we ran docker, this image will show up in docker "
"`ps`:"
msgstr ""

#: src/utilities/cpu.md:570
msgid "\"/home/rminnich/go/b…\""
msgstr ""

#: src/utilities/cpu.md:573
msgid "Even though the binaries themselves are running on the remote ARM system."
msgstr ""

#: src/utilities/cpu.md:575
msgid "cpu and virtiofs"
msgstr ""

#: src/utilities/cpu.md:577
msgid ""
"While 9p is very general, because it is _transport-independent_, there are "
"cases where we can get much better performance by using a less general file "
"system. One such case is with virtofs."
msgstr ""

#: src/utilities/cpu.md:581
msgid ""
"Because virtiofs is purely from guest kernel vfs to host kernel vfs, via "
"virtio transport, it has been measured to run at up to 100 times faster."
msgstr ""

#: src/utilities/cpu.md:584
msgid ""
"We can use virtiofs by specifying virtiofs mounts. cpud will look for an "
"environemnt variable, `CPU_FSTAB`, which is in `fstab(5)` format. The client "
"can specify an fstab in one of two ways. Either via the `-fstab` switch, in "
"which case the client will populate the `CPU_FSTAB` variable with the "
"contents of the file or by passing the `CPU_FSTAB` environment variable, "
"which happens by default."
msgstr ""

#: src/utilities/cpu.md:591
msgid ""
"On the client side, the file specified via the -fstab takes precedence over "
"any value of the CPU_FSTAB environment variable. On the server side, cpud "
"does not use the -fstab switch, only using the environment variable."
msgstr ""

#: src/utilities/cpu.md:595
msgid "Here is an example of using the CPU_FSTAB variable with one entry:"
msgstr ""

#: src/utilities/cpu.md:601
msgid ""
"In this case, the virtiofs server had the name myfs, and on the remote side, "
"virtiofs was mounted on /mnt."
msgstr ""

#: src/utilities/cpu.md:604
msgid "For the fstab case, the command looks like this:"
msgstr ""

#: src/utilities/cpu.md:610
msgid "The fstab in this case would be"
msgstr ""

#: src/utilities/cpu.md:616
msgid ""
"Note that both the environment variable and the fstab can have more than one "
"entry, but they entries must be separate by newlines. Hence, this will not "
"work:"
msgstr ""

#: src/utilities/cpu.md:624
msgid "as shells insist on converting newlines to spaces."
msgstr ""

#: src/utilities/cpu.md:626
msgid ""
"The fstab can specify any file system. If there is a mount path to, e.g., "
"Google drive, and it can be specified in fstab format, then cpu clients can "
"use Google Drive files. Note, again, that these alternative mounts do not "
"use the 9p server built in to the cpu client; they use the file systems "
"provided on the cpu server machine."
msgstr ""

#: src/utilities/cpu.md:632
msgid "There are thus several choices for setting up the mounts"
msgstr ""

#: src/utilities/cpu.md:634
msgid "9p support by the cpu client"
msgstr ""

#: src/utilities/cpu.md:635
msgid ""
"9p supported by the cpu client, with additional mounts via -fstab or "
"-namespace"
msgstr ""

#: src/utilities/cpu.md:636
msgid ""
"9p _without_ any bind mounts, i.e. -9p=false -namespace \"\", in which case, "
"on the remote machine, files from the client are visible in /tmp/cpu, but no "
"bind mounts are done; with additional mounts provided by fstab mounts are "
"provided"
msgstr ""

#: src/utilities/cpu.md:640
msgid ""
"no 9p mounts at all, when -namespace=\"\" -9p=false; with optional "
"additional mounts via fstab"
msgstr ""

#: src/utilities/cpu.md:642
msgid "if there are no 9p mounts, and no fstab mounts, cpu is equivalent to ssh."
msgstr ""

#: src/utilities/cpu.md:644
msgid "For reference, the command we used: `cpu -dbg9p -d apu2 date`"
msgstr ""

#: src/utilities/dut.md:1
msgid "DUT, a simple Device Under Test utility."
msgstr ""

#: src/utilities/dut.md:3
msgid "Points of contact: [Ron Minnich](https://github.com/rminnich)"
msgstr ""

#: src/utilities/dut.md:5
msgid ""
"DUT is a simple Device Under Test program that gives you control of a node. "
"It is intended to make very fast startup and control easy."
msgstr ""

#: src/utilities/dut.md:8
msgid ""
"DUT is one program implementing three operations. The first, tester, is run "
"on a test control system, such as your desktop; the second, called device, "
"is run on the device; the third, called ssh and also run on the device, "
"starts an ssh server assuming one is present."
msgstr ""

#: src/utilities/dut.md:12
msgid ""
"DUT is intended to be very limited, with more sophisticated operations, "
"should they be needed, being done over SSH."
msgstr ""

#: src/utilities/dut.md:15
msgid "DUT is found at github.com:linuxboot/dut."
msgstr ""

#: src/utilities/dut.md:17
msgid "This chapter describes how we build and use DUT."
msgstr ""

#: src/utilities/dut.md:19 src/coreboot.u-root.systemboot/index.md:31
msgid "Components"
msgstr ""

#: src/utilities/dut.md:21
msgid "DUT is intended to be built into a u-root image. First one must fetch it:"
msgstr ""

#: src/utilities/dut.md:27
msgid ""
"DUT source tree is structured such that a program called uinit is produced. "
"This is convenient for u-root usage."
msgstr ""

#: src/utilities/dut.md:29
msgid "Building it into a u-root image is easy:"
msgstr ""

#: src/utilities/dut.md:34
msgid ""
"I almost always add an sshd to u-root; it's just too handy. U-root sshd does "
"not support passwords, so you have to supply the public key:"
msgstr ""

#: src/utilities/dut.md:40
msgid "DUT on the device"
msgstr ""

#: src/utilities/dut.md:41
msgid ""
"On boot, the standard init program will find dut, and run it. The standard "
"mode on a device is device mode, and dut will bring up the ethernet, "
"currently using 192.168.0.2, and assuming the tester is 192.168.0.1 (this "
"should be fixed ...). It will then attempt to connect to a uinit running in "
"'tester' mode on 192.168.0.1. Once connected, it functions as a server and "
"waits for requests."
msgstr ""

#: src/utilities/dut.md:47
msgid "DUT on the controller"
msgstr ""

#: src/utilities/dut.md:48
msgid "Running on the controller is easy:"
msgstr ""

#: src/utilities/dut.md:53
msgid ""
"On the controller, the program waits for a connection and then starts "
"issuing commands to the device. The controller has the option of calling the "
"following RPC functions:"
msgstr ""

#: src/utilities/dut.md:63
msgid ""
"Each of these RPCs takes arguments and returns a result, with Welcome being "
"the most fun:"
msgstr ""

#: src/utilities/dut.md:75
msgid ""
"The current tester mode performs an RPC sequence I use for DXE cleaning, "
"namely, a Welcome, followed by a Reboot, followed by a Welcome. This "
"sequence verifies that I can get network going from power on, do a reboot, "
"and reconnect after a reboot. It's been good for finding out if a particular "
"DXE can be removed."
msgstr ""

#: src/utilities/dut.md:79
msgid ""
"Once the second Welcome has happened, if an sshd is installed, it will have "
"been started, and you can do additional commands."
msgstr ""

#: src/utilities/dut.md:81
msgid "Future work"
msgstr ""

#: src/utilities/dut.md:83
msgid ""
"Obviously, much more can be done. But this is a useful foundation on which "
"to build DUT environments."
msgstr ""

#: src/implementation.md:3
msgid ""
"The aim of LinuxBoot is to reduce complexity and obscure firmware by moving "
"that functionality into kernel and user-space."
msgstr ""

#: src/implementation.md:6
msgid ""
"This chapter describes the procedures from a [LinuxBoot "
"workshop](https://docs.google.com/presentation/d/1s9ka4v7leKeJa3116AQoNb9cv3OqmnW6pgn0ov9WiHo/edit?ts=5e2b227b#slide=id.g7ceec54197_4_163) "
"where an Atomic Pi board with UEFI firmware was converted to run LinuxBoot. "
"The build materials associated with this are found at "
"[digitalloggers/atomicpi](https://github.com/linuxboot/mainboards/tree/master/digitalloggers/atomicpi)."
msgstr ""

#: src/implementation.md:12
msgid ""
"Read the below and consult the Makefile for the details of how it was "
"implemented."
msgstr ""

#: src/implementation.md:15
msgid "A quick refresher on UEFI"
msgstr ""

#: src/implementation.md:17
msgid "UEFI has three sections:"
msgstr ""

#: src/implementation.md:19
msgid "SEC (\"Boot\")"
msgstr ""

#: src/implementation.md:20
msgid "PEI (\"Very early chip setup and DRAM programming\")"
msgstr ""

#: src/implementation.md:21
msgid "DXE (\"DRAM code\")"
msgstr ""

#: src/implementation.md:23
msgid "DXE process is very complex; some systems have 750 DXEs."
msgstr ""

#: src/implementation.md:25
msgid ""
"LinuxBoot replaces most of the UEFI software with Linux. LinuxBoot has an "
"initramfs provided by [u-root](./u-root.md)."
msgstr ""

#: src/implementation.md:28
msgid ""
"The above are stored inside a flash filesystem (FFS) inside a region of "
"flash on your motherboard (the BIOS region). Another important region of "
"flash is the ME region."
msgstr ""

#: src/implementation.md:32
msgid ""
"The Management Engine (ME) is an x86 CPU embedded in the Intel Platform "
"Controller Hub (PCH). It runs the Minix operating system which boots first "
"and enables hardware such as clocks and GPIOs. ME checks the contents of "
"flash memory and is used to implement \"BootGuard\". If you reflash and the "
"ME is in \"BootGuard\" mode, your machine will be unusable. You need to run "
"a tool called `me_cleaner` on the image to disable BootGuard."
msgstr ""

#: src/implementation.md:39
msgid "How do you get LinuxBoot on your hardware"
msgstr ""

#: src/implementation.md:41
msgid ""
"Start with a board running standard UEFI and proceed from \"zero changes to "
"FLASH\" to \"max changes\" in 4 steps:"
msgstr ""

#: src/implementation.md:44
msgid "Boot from USB stick via UEFI shell command _or_ netboot (zero changes)"
msgstr ""

#: src/implementation.md:45
msgid "Find a way to read flash and write flash"
msgstr ""

#: src/implementation.md:46
msgid "Understand the flash layout"
msgstr ""

#: src/implementation.md:47
msgid "Prepare linux kernel and initrd/initramfs payload."
msgstr ""

#: src/implementation.md:48
msgid ""
"Replace UEFI Shell code section with Linux kernel and associated initrd "
"(change part of one thing)"
msgstr ""

#: src/implementation.md:50
msgid "Remove as many DXEs as possible (change by removal). This change:"
msgstr ""

#: src/implementation.md:51
msgid "Speeds boot"
msgstr ""

#: src/implementation.md:52
msgid "Reduces panic possibilities"
msgstr ""

#: src/implementation.md:53
msgid "Removes exploits"
msgstr ""

#: src/implementation.md:54
msgid "In production, it has solved problems"
msgstr ""

#: src/implementation.md:55
msgid "Clear ME region for initrd storage"
msgstr ""

#: src/implementation.md:56
msgid "Replace some DXEs with open source components (change by replacement)"
msgstr ""

#: src/implementation.md:58
msgid ""
"One of the challenges in the above is in finding (or reclaiming) enough "
"space in flash to shoehorn your kernel and initrd into."
msgstr ""

#: src/implementation.md:61
msgid "Tools of the trade"
msgstr ""

#: src/implementation.md:63
msgid ""
"There are two tools you use when you modify the UEFI flash image: `utk` and "
"`me_cleaner`."
msgstr ""

#: src/implementation.md:66
msgid "The ME Cleaner tool:"
msgstr ""

#: src/implementation.md:68
msgid "`/usr/bin/python2 me_cleaner.py -s` _imagefile.bin_"
msgstr ""

#: src/implementation.md:70
msgid ""
"`me_cleaner` sets the high assurance platform (HAP) bit. HAP provides a way "
"to disable a feature on Intel chips that does not allow us to modify the "
"UEFI image and install LinuxBoot. Setting the bit with `me_cleaner` disables "
"the \"feature\".  Note that this does not always work; check with the "
"LinuxBoot community."
msgstr ""

#: src/implementation.md:76
msgid "When you run `me_cleaner`:"
msgstr ""

#: src/implementation.md:82
msgid "you should see output similar to the following:"
msgstr ""

#: src/implementation.md:86
msgid "`Full image detected`"
msgstr ""

#: src/implementation.md:87
msgid "`Found FPT header at 0x1010`"
msgstr ""

#: src/implementation.md:88
msgid "`Found 20 partition(s)`"
msgstr ""

#: src/implementation.md:89
msgid "`Found FTPR header: FTPR partition spans from 0x6f000 to 0xe700`"
msgstr ""

#: src/implementation.md:90
msgid "`ME/TXE firmware version 2.0.5.3112 (generation 2)`"
msgstr ""

#: src/implementation.md:91
msgid "`Public key match: Intel TXE, firmware versions 2.x.x.x`"
msgstr ""

#: src/implementation.md:92
msgid "`The AltMeDisable bit is SET`"
msgstr ""

#: src/implementation.md:93
msgid "`Setting the AltMeDisable bit in PCHSTRP10 to disable Intel ME…`"
msgstr ""

#: src/implementation.md:94
msgid "`Checking the FTPR RSA signature... VALID`"
msgstr ""

#: src/implementation.md:95
msgid "`Done! Good luck!`"
msgstr ""

#: src/implementation.md:97
msgid ""
"By applying `me_cleaner`, it has been observed that almost 4M of flash ram "
"can be reclaimed for use. That 4M is enough to store a reasonably full "
"featured compressed initrd image."
msgstr ""

#: src/implementation.md:101
msgid "The `utk` tool can:"
msgstr ""

#: src/implementation.md:103
msgid "Remove DXEs"
msgstr ""

#: src/implementation.md:104
msgid "Insert new DXEs"
msgstr ""

#: src/implementation.md:105
msgid "Replace the binary code of a DXE with a kernel"
msgstr ""

#: src/implementation.md:106
msgid "Reallocate space from the ME region to the BIOS region (\"tighten\")"
msgstr ""

#: src/implementation.md:108
msgid "LinuxBoot Implementation steps"
msgstr ""

#: src/implementation.md:110
msgid "Step 1: boot Linux via netboot / UEFI shell"
msgstr ""

#: src/implementation.md:112
msgid "netboot: standard BIOS-based PXE boot"
msgstr ""

#: src/implementation.md:113
msgid "Netboot is probably the most common working boot method on UEFI"
msgstr ""

#: src/implementation.md:114
msgid "We have never seen a system that did not have a net boot"
msgstr ""

#: src/implementation.md:115
msgid "UEFI Shell (mentioned only for completeness)"
msgstr ""

#: src/implementation.md:116
msgid ""
"Install Linux on FAT-32 media with a name of your choice (e.g. \"kernel\")"
msgstr ""

#: src/implementation.md:117
msgid "FAT-32, also known as MS-DOS file system"
msgstr ""

#: src/implementation.md:118
msgid "Boot kernel at UEFI Shell prompt"
msgstr ""

#: src/implementation.md:119
msgid "We've run into a few systems that don't have a UEFI shell"
msgstr ""

#: src/implementation.md:121
msgid "Working with a system that only has a net interface"
msgstr ""

#: src/implementation.md:123
msgid ""
"If the system only has a net interface, you use Dynamic Host Configuration "
"Protocol (DHCP), using broadcast DISCOVER, and Trivial File Transfer "
"Protocol (TFTP) to get the boot information you need."
msgstr ""

#: src/implementation.md:127
msgid ""
"Configuration information is provided by REPLY to a DHCP request. The REPLY "
"returns an IP, server, and a configuration file name that provides:"
msgstr ""

#: src/implementation.md:130
msgid "Identity"
msgstr ""

#: src/implementation.md:131
msgid "What to boot"
msgstr ""

#: src/implementation.md:132
msgid "Where to get it"
msgstr ""

#: src/implementation.md:134
msgid ""
"Data is provided by TFTP. HTTP downloading takes a fraction of a second even "
"for 16M kernels. With TFTP it's very slow and TFTP won't work with initramfs "
"much large than 32MiB. Most LinuxBoot shops use or are transitioning to HTTP."
msgstr ""

#: src/implementation.md:138
msgid ""
"Note: Boot images require a kernel(bzImage) + an initramfs + a command line. "
"They can be loaded as three pieces or compiled and loaded as one piece, as "
"described in this section."
msgstr ""

#: src/implementation.md:142
msgid "Step 2: read & write the flash"
msgstr ""

#: src/implementation.md:144
msgid ""
"There are two main ways to read and write the flash - hardware and software."
msgstr ""

#: src/implementation.md:146
msgid ""
"Hardware: It is worth buying a Pomona 5250 SOIC Clip adapter to read "
"directly by hardware to have something to roll back to if anything goes "
"wrong. Avoid cheap SOIC clip adapters that don't allow you to use standard "
"jumper leads. For a good example of using a Raspberry Pi 3/4 to read/write, "
"see [Sakaki's EFI Install Guide/Disabling the Intel Management "
"Engine](https://wiki.gentoo.org/wiki/Sakaki%27s_EFI_Install_Guide/Disabling_the_Intel_Management_Engine#imt_check)"
msgstr ""

#: src/implementation.md:153
msgid ""
"Software: With a working boot image, use flashrom to read an image of your "
"flash. To write you may need to disable flash protections (look for \"ME "
"Manufacturing mode\" jumpers on your motherboard). Figure on generally using "
"software methods for reading & writing flash, but with hardware to drop back "
"to."
msgstr ""

#: src/implementation.md:159
msgid ""
"Step 3: Familiarise yourself with the flash layout and identify free space"
msgstr ""

#: src/implementation.md:161
msgid ""
"Open your flash image with UEFITool, and locate the filesystem containing "
"the DXE's (it will have the Shell or `Shell_Full` in it ). Check how much "
"volume free space is in that filesystem - this will be an initial limit when "
"you come to place your kernel and initramfs in it in step 5."
msgstr ""

#: src/implementation.md:166
msgid "Step 4: Prepare linux/u-root payload"
msgstr ""

#: src/implementation.md:168
msgid "Start small and work your way up."
msgstr ""

#: src/implementation.md:170
msgid ""
"Use the tiny.config to configure your first kernel, and embed a small "
"initramfs in-kernel (the u-root cpu payload is an excellent starting point)."
msgstr ""

#: src/implementation.md:172
msgid "One can have a full kernel/initramfs in around 2M of flash."
msgstr ""

#: src/implementation.md:173
msgid ""
"A more full featured kernel might consume 2M and a u-root bb distribution "
"4M, which may well exceed the volume free space."
msgstr ""

#: src/implementation.md:175
msgid ""
"When there isn't enough space in this filesystem, one can either start "
"removing unused DXE's (step 6), or use space formerly used by the ME Region "
"(step 7)."
msgstr ""

#: src/implementation.md:179
msgid "Step 5: replace Shell binary section"
msgstr ""

#: src/implementation.md:181
msgid "UEFI Shell is a DXE"
msgstr ""

#: src/implementation.md:182
msgid "DXEs are Portable Executable 32-bit binaries (PE32)"
msgstr ""

#: src/implementation.md:183
msgid "They have multiple sections, one of them being binary code"
msgstr ""

#: src/implementation.md:184
msgid ""
"You need a flash image (in this case called _firmware.bin_). You can get it "
"via vendor website, flashrom, or other mechanism."
msgstr ""

#: src/implementation.md:186
msgid ""
"The following `utk` command replaces the Shell code section with a Linux "
"kernel:"
msgstr ""

#: src/implementation.md:188
msgid "`utk firmware.bin replace_pe32 Shell bzImage save` _new.bin_"
msgstr ""

#: src/implementation.md:189
msgid ""
"Note: It's always a PE32, even for 64-bit kernels. _new.bin_ is a filename "
"of your choosing."
msgstr ""

#: src/implementation.md:191
msgid "After running `utk`, you can reflash"
msgstr ""

#: src/implementation.md:193
msgid "Step 6a: remove as many DXEs as possible"
msgstr ""

#: src/implementation.md:195
msgid "You can do an initial mass removal based on your current knowledge"
msgstr ""

#: src/implementation.md:196
msgid "`utk` automates removing DXEs: this is the DXE cleaner"
msgstr ""

#: src/implementation.md:197
msgid ""
"`utk` removes a DXE, reflashes, checks if it boots, repeat This part should "
"be easy: DXE can have a dependency section. In practice, it's hard: because "
"dependency sections are full of errors and omissions. A lot of UEFI code "
"does not check for failed DXE loads."
msgstr ""

#: src/implementation.md:202
msgid "Step 6b: place your initramfs in me_cleaned region"
msgstr ""

#: src/implementation.md:204
msgid ""
"Run `me_cleaner` and then utk tighten on the source image, then inspect the "
"image using UEFITool. If successful, there will now be padding at the "
"beginning of the BIOS region of a substantial size."
msgstr ""

#: src/implementation.md:207
msgid ""
"This padding space can be used, without the filesystem's knowledge, to stash "
"an initramfs. The kernel is informed of the location this initramfs as an "
"initrd kernel parameter."
msgstr ""

#: src/implementation.md:210
msgid ""
"Use the base address of this padding region to calculate the offset in the "
"flash image where the initrd is stashed using dd."
msgstr ""

#: src/implementation.md:212
msgid ""
"Use the address (not base address) as the initramfs location in memory to "
"pass as a kernel parameter."
msgstr ""

#: src/implementation.md:215
msgid "Step 7: replace closed-source with open source"
msgstr ""

#: src/implementation.md:217
msgid ""
"If you can build a DXE from source, you can use `utk` to remove the "
"proprietary one and replace it with one built from source. You can get DXE "
"source from the tianocore/EDK2 source repo at github.com. The GitHub repo "
"has a **_limited_** number of DXEs in source form; i.e., you can't build a "
"full working image using it."
msgstr ""

#: src/implementation.md:222
msgid ""
"There are scripts that let you compile individual DXEs, including the UEFI "
"Shell and Boot Device Selection (BDS). These two DXEs have been compiled and "
"are used in the Atomic Pi. Source-based BDS was needed to ensure the UEFI "
"Shell was called."
msgstr ""

#: src/implementation.md:226
msgid "You only need the UEFI Shell built long enough to replace it with Linux."
msgstr ""

#: src/implementation.md:228
msgid "Final step: reflash the image"
msgstr ""

#: src/implementation.md:230
msgid ""
"\"Native\" reflash: Boot the system whatever way is easiest: netboot, usb, "
"local disk, and run `flashrom -p internal -w _filename.bin_` where "
"_filename.bin_ is a filename of your choosing."
msgstr ""

#: src/implementation.md:233
msgid ""
"Run `flashrom` with an external device such as an sf100. There may be a "
"header on the board, or you might have to use a clip. `flashrom -p "
"dediprog:voltage=1.8 -w _filename.bin_`"
msgstr ""

#: src/implementation.md:237
msgid "The voltage option is required for the Atomic Pi."
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:3
msgid ""
"Points of contact: [Andrea Barberio](https://github.com/insomniacslk), "
"[David Hendricks](https://github.com/dhendrix)"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:7
msgid ""
"This chapter describes how to build a LinuxBoot firmware based on coreboot, "
"u-root and systemboot.  The examples will focus on `x86_64`, and the "
"coreboot builds will cover virtual and physical OCP hardware."
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:11
msgid "Quick Start with coreboot"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:13
msgid ""
"Run these commands in a directory you create or in `/tmp`; do so because it "
"creates some files and directories:"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:22
msgid ""
"This produces a coreboot image in coreboot-4.9/build/coreboot.rom You can "
"now run this ROM image:"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:29
msgid "And see how it looks when you put this in a coreboot ROM image."
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:33
msgid "The final image is built on top of multiple open-source components:"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:35
msgid ""
"[coreboot](https://coreboot.org), used for the platform initialization. "
"Silicon and DRAM initialization are done here."
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:37
msgid ""
"[Linux](https://kernel.org), used to initialize peripherals and various "
"device drivers like file systems, storage and network devices; network "
"stack; a multiuser and multitasking environment."
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:40
msgid ""
"[u-root](https://github.com/u-root/u-root), an user-space environment that "
"provides basic libraries and utilities to work in a Linux environment."
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:42
msgid ""
"~~[systemboot](https://systemboot.org), an additional set of libraries and "
"tools on top of u-root, that provide a bootloader behaviour for various "
"booting scenarios.~~ systemboot was merged into u-root."
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:46
msgid ""
"These components are built in reverse order. `u-root` and `systemboot` are "
"built together in a single step."
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:49
msgid "Building u-root"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:51
msgid ""
"The first step is building the initramfs. This is done using the `u-root` "
"ramfs builder, with additional tools and libraries from `systemboot`."
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:54
msgid ""
"u-root is written in Go. We recommend using a relatively recent version of "
"the Go toolchain. At the time of writing the latest is 1.11, and we "
"recommend using at least version 1.10. Previous versions may not be fully "
"supported."
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:58
msgid ""
"Adjust your `PATH` to include `${GOPATH}/bin`, in order to find the `u-root` "
"command that we will use in the next steps."
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:61
msgid "Then, fetch `u-root` and its dependencies:"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:67
msgid ""
"Then build the ramfs in busybox mode, and add fbnetboot, localboot, and a "
"custom uinit to wrap everything together:"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:74
msgid ""
"This command will generate a ramfs named "
"`/tmp/initramfs_${os}_${arch}.cpio`, e.g. `/tmp/initramfs.linux_amd64.cpio`. "
"You can specify an alternative output path with `-o`. Run `u-root -h` for "
"additional command line parameters."
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:78
msgid ""
"Note: the above command will include only pure-Go commands from `u-root`. If "
"you need to include other files or non-Go binaries, use the `-file` option "
"in `u-root`.  For example, you may want to include static builds of `kexec` "
"or `flashrom`, that we build on https://github.com/systemboot/binaries ."
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:83
msgid ""
"Then, the initramfs has to be compressed. This step is necessary to embed "
"the initramfs in the kernel as explained below, in order to maintain the "
"image size smaller. Linux has a limited XZ compressor, so the compression "
"requires specific options:"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:92
msgid "which will produce the file `/tmp/initramfs.linux_amd64.cpio.xz`."
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:94
msgid ""
"The kernel compression requirements are documented under "
"[Documentation/xz.txt](https://www.kernel.org/doc/Documentation/xz.txt) "
"(last checked 2018-12-03) in the kernel docs."
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:98
msgid "Building a suitable Linux kernel"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:100
msgid ""
"A sample config to use with QEMU can be downloaded here: "
"[linux-4.19.6-linuxboot.config](linux-4.19.6-linuxboot.config)."
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:103
msgid ""
"You need a relatively recent kernel. Ideally a kernel 4.16, to have support "
"for VPD variables, but a 4.11 can do the job too, if you don't care about "
"boot entries and want \"brute-force\" booting only."
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:107
msgid "We will build a kernel with the following properties:"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:109
msgid ""
"small enough to fit most flash chips, and with some fundamental kernel "
"features"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:110
msgid "that can run Go programs (mainly futex and epoll support)"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:111
msgid "with the relevant storage and network stack and drivers"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:112
msgid "with kexec support, so it can boot a new kernel"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:113
msgid "with kexec signature verification disabled (optional)"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:114
msgid "with devtmpfs enabled, since we don't use udev"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:115
msgid "XZ support to decompress the embedded initramfs"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:116
msgid "VPD (Vital Product Data) (optional)"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:117
msgid "TPM support (optional)"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:118
msgid "embed the u-root initramfs"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:119
msgid "and last but not least, \"linuxboot\" as default host name :)"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:121
msgid "Download kernel sources"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:123
msgid ""
"You can either download a tarball from kernel.org, or get it via git and use "
"a version tag. We recommend at least a kernel 4.16, in order to have VPD "
"variables support."
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:127
msgid ""
"```\n"
"# download the kernel tarball. Replace 4.19.6` with whatever kernel version "
"you want\n"
"wget https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.19.6.tar.xz\n"
"tar xvJf linux-4.19.6.tar.xz\n"
"cd linux-4.19.6\n"
"make tinyconfig\n"
"```"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:135
msgid ""
"You can also check out the `linux-stable` branch, that will point to the "
"latest stable commit. You need to download it via `git` as follows:"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:138
msgid ""
"```\n"
"git clone --depth 1 -b linux-stable\n"
"git://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git\n"
"cd linux-stable\n"
"make tinyconfig\n"
"```"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:145
msgid ""
"Some more information about tiny configs can be found at "
"https://tiny.wiki.kernel.org (last checked 2018-12-01)."
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:148
msgid "A few fundamental features"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:150
msgid "Assuming we are running on `x86_64`, some basic features to enable are:"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:152
msgid "`64-bit kernel`"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:153
msgid ""
"`General setup` → `Configure standard kernel features` → `Enable support for "
"printk`"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:155
msgid ""
"`General setup` → `Configure standard kernel features` → `Multiple users, "
"groups and capabilities support` (this is not strictly required on LinuxBoot)"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:158
msgid ""
"`Processor type and features` → `Built-in kernel command line` (customize "
"your command line here if needed, e.g. `earlyprintk=serial,ttyS0,57600 "
"console=ttyS0,57600`)"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:161
msgid ""
"`Executable file formats / Emulations` → `Kernel support for ELF binaries` "
"(you may want to enable more formats)"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:163
msgid "`Networking support` → `Networking options` → `TCP/IP networking`"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:164
msgid "`Networking support` → `Networking options` → `The IPv6 protocol`"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:165
msgid "`Device Drivers` → `Character devices` → `Enable TTY`"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:166
msgid ""
"`Device Drivers` → `Character devices` → `Serial drivers` → `8250/16550 and "
"compatible serial support`"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:168
msgid ""
"`Device Drivers` → `Character devices` → `Serial drivers` → `Console on "
"8250/16550 and compatible serial port`"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:170
msgid "`File systems` → `Pseudo filesystems` → `/proc file system support`"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:171
msgid "`File systems` → `Pseudo filesystems` → `sysfs file system support`"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:173
msgid "Requirements for Go 1.11"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:175
msgid ""
"`Go` requires a few kernel features to work properly. At the time of "
"writing, you need to enable `CONFIG_FUTEX` in your kernel config. Older "
"versions of Go may require `CONFIG_EPOLL`."
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:179
#: src/coreboot.u-root.systemboot/index.md:199
#: src/coreboot.u-root.systemboot/index.md:232
#: src/coreboot.u-root.systemboot/index.md:249
#: src/coreboot.u-root.systemboot/index.md:259
#: src/coreboot.u-root.systemboot/index.md:274
#: src/coreboot.u-root.systemboot/index.md:289
msgid "In menuconfig:"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:181
msgid ""
"`General setup` → `Configure standard kernel features (expert users)` → "
"`Enable futex support`"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:183
msgid ""
"`General setup` → `Configure standard kernel features (expert users)` → "
"`Enable eventpoll support`"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:186
msgid ""
"Additional information about Go's minimum requirements can be found at "
"https://github.com/golang/go/wiki/MinimumRequirements (last checked "
"2018-12-01)."
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:190
msgid "Enable devtmpfs"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:192
msgid ""
"Our system firmware uses u-root, which does not have (intentionally) an "
"`udev` equivalent. Therefore, to have `/dev/` automatically populated at "
"boot time you should enable devtmps."
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:196
msgid ""
"Simply enable `CONFIG_DEVTMPFS` and `CONFIG_DEVTMPFS_MOUNT` in your kernel "
"config."
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:201
msgid ""
"`Device drivers` → `Generic Driver Options` → `Maintain a devtmpfs "
"filesystem to mount at /dev`"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:203
msgid ""
"`Device drivers` → `Generic Driver Options` → `Automount devtmpfs at /dev, "
"after the kernel mounted the rootfs`"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:206
msgid "Additional drivers"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:208
msgid ""
"This really depends on your hardware. You may want to add all the relevant "
"drivers for the platforms you plan to run LinuxBoot on. For example you may "
"need to include NIC drivers, file system drivers, and any other device that "
"you need at boot time."
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:213
msgid ""
"For example, enable SCSI disk, SATA drivers, EXT4, and e1000 NIC driver. In "
"menuconfig:"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:216
msgid "`Bus options` → `PCI support`"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:217
msgid "`Enable the block layer`"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:218
msgid "`Device drivers` → `Block devices` (required for SCSI and SATA)"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:219
msgid "`Device drivers` → `SCSI device support` → `SCSI disk support`"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:220
msgid "`Device drivers` → `Serial ATA and Parallel ATA drivers`"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:221
msgid "`File systems` → `The Extended 4 (ext4) filesystem`"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:222
msgid "`Networking support` (required for e1000)"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:223
msgid ""
"`Device drivers` → `Network device support` → `Ethernet driver support` → "
"`Intel(R) PRO/1000 Gigabit Ethernet support`"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:226
msgid "Enable XZ kernel and initramfs compression support"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:228
msgid ""
"The `u-root`\\-based RAMFS will be compressed with XZ and embedded in the "
"kernel. Hence you need to enable XZ compression support. Make sure to have "
"at least `CONFIG_HAVE_KERNEL_XZ`, `CONFIG_KERNEL_XZ`, `CONFIG_DECOMPRESS_XZ`."
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:234
msgid "`General setup` → `Kernel compression mode` → `XZ`"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:235
msgid ""
"`General setup` → `Initial RAM filesystem and RAM disk (initramfs/initrd) "
"support` → `Support initial ramdisk/ramfs compressed using XZ`"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:239
msgid "Enable VPD"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:241
msgid ""
"VPD stands for [Vital Product "
"Data](https://chromium.googlesource.com/chromiumos/platform/vpd/+/1c1806d8df4bb5976eed71a2e2bf156c36ccdce2/README.md). "
"We use VPD to store boot configuration for `localboot` and `fbnetboot`, "
"similarly to UEFI's boot variables. Linux supports VPD out of the box, but "
"you need at least a kernel 4.16."
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:247
msgid "Make sure to have `CONFIG_GOOGLE_VPD` enabled in your kernel config."
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:251
msgid ""
"`Firmware drivers` → `Google Firmware Drivers` → `Coreboot Table Access - "
"ACPI` → `Vital Product Data`"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:254
msgid "TPM support"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:256
msgid ""
"This also depends on your needs. If you plan to use TPM, and this is "
"supported by your platform, make sure to enable `CONFIG_TCG_TPM`."
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:261
msgid ""
"`Device drivers` → `Character devices` → `TPM Hardware Support` → (enable "
"the relevant drivers)"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:264
msgid "Include the initramfs"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:266
msgid ""
"As mentioned above, the kernel will embed the compressed initramfs image. "
"Your kernel configuration should point to the appropriate file using the "
"`CONFIG_INITRAMFS_SOURCE` directive. E.g."
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:270
msgid ""
"```\n"
"CONFIG_INITRAMFS_SOURCE=\"/path/to/initramfs_linux.x86_64.cpio.xz\"\n"
"```"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:276
msgid ""
"`General setup` → `Initial RAM filesystem and RAM disk (initramfs/initrd) "
"support` → `Initramfs source file(s)`"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:279
msgid "Default hostname"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:281
msgid ""
"We use \"linuxboot\" as the default hostname. You may want to adjust it to a "
"different value. You need to set `CONFIG_DEFAULT_HOSTNAME` for the purpose. "
"For example:"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:285
msgid ""
"```\n"
"CONFIG_DEFAULT_HOSTNAME=\"linuxboot\"\n"
"```"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:291
msgid "`General setup` → `Default hostname`"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:293
msgid "Build the kernel"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:295
msgid "Once your configuration is ready, build the kernel as usual:"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:301
msgid ""
"The image will be located under `arch/${ARCH}/boot/bzImage` if your "
"architecture supports bzImage (e.g. x86)."
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:304
msgid ""
"For more details on how to build a kernel, see "
"https://kernelnewbies.org/KernelBuild (last checked 2018-12-01)."
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:307
msgid "Building coreboot"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:309
msgid ""
"In this step we will build `coreboot` using the Linux kernel image that we "
"built at the previous step as payload. This build is for a Qemu x86 target, "
"the process may be somehow different for other platforms."
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:313
msgid "Steps overview:"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:315
msgid "download coreboot from the git repo"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:316
msgid "build the compiler toolchain"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:317
msgid "configure coreboot for Qemu, and to use our `bzImage` as payload"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:318
msgid "build `coreboot.rom`"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:320
msgid "Download coreboot"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:322
msgid "Our preferred method is to download coreboot from the git repository:"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:324
msgid ""
"```\n"
"git clone https://review.coreboot.org/coreboot.git\n"
"cd coreboot\n"
"```"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:329
msgid "Build the compiler toolchain"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:331
msgid ""
"This step is required to have, among other things, reproducible builds, and "
"a compiler toolchain that is known to work with coreboot."
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:338
msgid ""
"The step above may ask you to install a few additional libraries or headers, "
"do so as requested, with the exception of gcc-gnat, that we won't need."
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:341
msgid "Configure coreboot for Qemu and our payload"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:343
msgid "Run `make menuconfig` to enter the coreboot configuration menus. Then:"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:345
msgid "Specify the platform we will run on:"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:347
msgid "`Mainboard` → `Mainboard vendor` → `Emulation`"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:348
msgid ""
"`Mainboard` → `Mainboard Model` → `QEMU x86 q35/ich9 (aka qemu -M q35, since "
"v1.4)`"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:351
msgid "Specify a large enough flash chip and CBFS size:"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:353
msgid "`Mainboard` → `ROM chip size` → `16 MB`"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:354
msgid "`Mainboard` → `Size of CBFS filesystem in ROM` → `0x1000000`"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:356
msgid "Specify our payload:"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:358
msgid "`Payload` → `Add a payload` → `A Linux payload`"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:359
msgid "`Payload` → `Linux path and filename` → path to your bzImage"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:361
msgid "Then save your configuration and exit menuconfig."
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:363
msgid "Build coreboot"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:365
msgid "This is done with a simple"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:371
msgid ""
"The coreboot build system will clone the relevant submodules, if it was not "
"done already, and will build a coreboot ROM file that will contain the "
"initialization code, and our bzImage payload. The output file is at "
"`build/coreboot.rom`."
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:375
msgid ""
"If everything works correctly you will get an output similar to the "
"following:"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:402
msgid "Putting everything together"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:406
msgid "Defining boot entries"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:410
msgid "Running on a virtual machine"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:412
msgid ""
"The image built with the above steps can run on a QEMU virtual machine, "
"using the machine type `q35`, as specified in the coreboot mainboard "
"section. Assuming that your coreboot image is located at "
"`build/coreboot.rom`, you can run the following command:"
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:428
msgid ""
"If everything has been done correctly you should see, in order, the output "
"from `coreboot`, `linux`, `u-root`, and `systemboot`. You can press `ctrl-c` "
"when Systemboot instructs you to do so, to enter the `u-root` shell."
msgstr ""

#: src/coreboot.u-root.systemboot/index.md:432
msgid "Running on real OCP hardware"
msgstr ""

#: src/glossary.md:3
msgid ""
"_**BIOS**_: Originally, BIOS was the software built into computers to send "
"simple instructions to the hardware, allowing input and output before the "
"operating system was loaded. It was a binary blob with no standardized "
"structure that was responsible for initializing CPU and memory, and jumping "
"to a hard-coded position on the master block of the first disk drive. BIOS "
"has been largely replaced by UEFI. Many UEFI implementations still offer a "
"\"BIOS compatibility mode\" which makes it behave like an old BIOS, with its "
"features."
msgstr ""

#: src/glossary.md:11
msgid ""
"_**busybox**_: Busybox is a single user-space binary which includes versions "
"of a large number of system commands, including a shell. This package can be "
"very useful for recovering from certain types of system failures, "
"particularly those involving broken shared libraries. There are multiple "
"implementations of busybox, such as git.busybox.net/busybox and "
"github.com/u-root/u-root."
msgstr ""

#: src/glossary.md:17
msgid ""
"[_**coreboot**_](https://doc.coreboot.org/): A project to develop open "
"source boot firmware for various architectures. Its design philosophy is to "
"do the bare minimum necessary to ensure that hardware is usable and then "
"pass control to a different program called the payload. The payload can then "
"provide user interfaces, file system drivers, various policies etc. to load "
"the OS."
msgstr ""

#: src/glossary.md:23
msgid ""
"_**DHCP**_: A networking protocol that runs on a DHCP server and that "
"automatically assigns an IP address from a pre-configured pool to any "
"machine that queries it on boot up."
msgstr ""

#: src/glossary.md:26
msgid ""
"[_**EDK II**_](https://github.com/tianocore/edk2): An open source reference "
"implementation of an UEFI-compliant firmware, originally developed by Intel"
msgstr ""

#: src/glossary.md:28
msgid ""
"_**firmware**_: A specific class of computer software that provides "
"low-level control for a device's specific hardware. It is installed at the "
"time of manufacturing and is the first program that runs when a computer is "
"turned on. It checks to see what hardware components the computing device "
"has, wakes the components up, and hands them over to the operating system "
"that is to be installed on the machine. The current x86 firmware is based on "
"Intel’s Universal Extensible Firmware Interface (UEFI)."
msgstr ""

#: src/glossary.md:35
msgid ""
"_**flashkernel**_: A small Linux kernel that is stored in flash and used as "
"a boot stage (e.g. the kernel used in LinuxBoot). Debian and Ubuntu maintain "
"a `flash-kernel` script to install the kernel and initramfs in a special "
"location for embedded devices that can not boot the kernel and initramfs "
"using the normal `/boot` mechanism"
msgstr ""

#: src/glossary.md:40
msgid ""
"[_**Heads**_](https://github.com/linuxboot/heads): An open source firmware "
"for laptops and servers, aimed at strong platform security. Developed by "
"Trammell Hudson, based on stripped UEFI plus Linux, and BusyBox instead of "
"u-root."
msgstr ""

#: src/glossary.md:44
msgid ""
"_**iSCSI**_: A protocol that provides a way to make network-attached storage "
"appear to be a local device to the hosts using it, allowing it to be (among "
"other things) mounted as a regular local file system."
msgstr ""

#: src/glossary.md:47
msgid ""
"_**kexec**_: A system call that enables you to load and boot into another "
"kernel from the currently running kernel. kexec performs the function of the "
"boot loader from within the kernel."
msgstr ""

#: src/glossary.md:50
msgid ""
"_**LinuxBIOS**_: A project originated in 1999 from Ron Minnich, Stefan "
"Reinauer and others. It was an experiment in the idea of running Linux as "
"firmware. At that time Linux was not mature enough for a hardware "
"initialization project, and while LinuxBIOS was successful in several "
"performance-and-reliability critical environments, it didn't see mass "
"adoption. It later became coreboot."
msgstr ""

#: src/glossary.md:56
msgid ""
"_**LinuxBoot**_: LinuxBoot is not a product, but rather a concept. It's the "
"idea of booting Linux (OS) with Linux (system firmware). In a way, the same "
"concept pioneered by LinuxBIOS. It is like a Linux distribution, but for "
"firmware. It is a collection of various open source components, combined to "
"work as a consistent firmware OS."
msgstr ""

#: src/glossary.md:61
msgid ""
"_**NERF**_: The original name for the LinuxBoot project composed of stripped "
"UEFI plus Linux plus u-root. The name stands for Non-Extensible Reduced "
"Firmware, as opposed to UEFI's Unified Extensible Firmware Interface. NERF "
"is an UEFI replacement that is more compact and less extensible. While "
"extensibility is nice and often desirable, too much extensibility can make a "
"complex project very hard to maintain and keep secure."
msgstr ""

#: src/glossary.md:67
msgid ""
"_**Open Source Firmware**_: OSF can be used to refer to Open Source Firmware "
"or Open System Firmware depending on the context."
msgstr ""

#: src/glossary.md:69
msgid ""
"_**Open System Firmware (OSF)**_: An official subproject of the Open Compute "
"Project (OCP). OSF has been developed in the open, by various members of OCP "
"that were interested in having open source system firmware. OSF defines a "
"set of guidelines with contributions from Microsoft, Google, Facebook, "
"Intel, 9elements, TwoSigma, and several other companies."
msgstr ""

#: src/glossary.md:74
msgid ""
"_**OVMF**_: Open Virtual Machine Firmware. Open Virtual Machine Firmware is "
"a build of EDK II for virtual machines. It includes full support for UEFI, "
"including Secure Boot, allowing use of UEFI in place of a traditional BIOS "
"in your EFI Initialization (PEI)|UEFI stage which runs before RAM is "
"initialized, from cache and ROM. PEI is mostly C-code running in 32-bit "
"protected flat mode.  The main goal of the PEI stage is to detect RAM. As "
"soon as RAM is detected and configured, PEI stage give control to the DXE "
"through DXE Initial Program Load (IPL) driver"
msgstr ""

#: src/glossary.md:82
msgid ""
"_**production kernel**_: LinuxBoot is not intended to be a runtime "
"production kernel; rather, it is meant to replace specific UEFI "
"functionality using Linux kernel capabilities and then boot the actual "
"production kernel (prodkernel) on the machine. Kernel configuration files "
"specific to LinuxBoot provide the needed Linux kernel capabilities without "
"bloating the size of the BIOS with unnecessary drivers."
msgstr ""

#: src/glossary.md:88
msgid ""
"_**PureBoot**_: A combination of disabling IME, coreboot, a TPM, Heads and "
"the Librem Key (see [Trusted Boot (Anti-Evil-Maid, Heads, and "
"PureBoot)](https://tech.michaelaltfield.net/2023/02/16/evil-maid-heads-pureboot/#pureboot))"
msgstr ""

#: src/glossary.md:91
msgid ""
"_**QEMU**_: An emulator that performs hardware virtualization. QEMU is a "
"hosted virtual machine monitor."
msgstr ""

#: src/glossary.md:93
msgid ""
"_**Secure Boot Preverifier (SEC)**_: In UEFI, the SEC stage initializes the "
"CPU cache-as-RAM (CAR) and gives control to the PEI dispatcher. It is 99.9% "
"assembly code (32-bit protected mode)."
msgstr ""

#: src/glossary.md:96
msgid ""
"_**u-boot**_: A very popular open source firmware and bootloader. Not to be "
"confused with u-root."
msgstr ""

#: src/glossary.md:98
msgid ""
"_**u-root**_: A modern, embedded user-space environment for Linux, with "
"bootloader tools. See the section on u-root."
msgstr ""

#: src/glossary.md:100
msgid ""
"_**UEFI**_: Unified Extensible Firmware Interface. It is Intel’s "
"specification of a standard for system firmware. UEFI defines everything "
"from the layout on the flash chip, to how to interface to peripherals, "
"enables boot from disk or from a network, defines how UEFI applications "
"work, etc). It is not an implementation, it's a standard. EDK II and OpenEDK "
"II are UEFI implementations. UEFI is not closed source per-se, but in "
"practice most implementations are."
msgstr ""

#: src/history.md:5
msgid ""
"[BIOS](https://en.wikipedia.org/wiki/BIOS) is the good old, inscrutable way "
"of initializing a hardware platform in the pre-UEFI days. It's a binary blob "
"with no standardized structure, that is responsible for initializing CPU and "
"memory, and jumping to a hard-coded position on the MBR of the first disk "
"drive."
msgstr ""

#: src/history.md:10
msgid ""
"Starting around 2000, BIOS has been largely replaced by the standardized "
"[UEFI](https://en.wikipedia.org/wiki/UEFI). Many UEFI implementations still "
"offer a BIOS compatibility mode called CSM (Compatibility Support Module), "
"which makes it behave like an old BIOS."
msgstr ""

#: src/history.md:15
msgid ""
"Note that the term \"BIOS\" is sometimes misused to refer to the general "
"concept of _system firmware_, such as UEFI or even LinuxBoot. However, as "
"\"BIOS\" refers to firmware with specific functionality, UEFI is definitely "
"_not_ a BIOS, nor is LinuxBoot a BIOS in the original sense."
msgstr ""

#: src/history.md:20
msgid "LinuxBIOS"
msgstr ""

#: src/history.md:22
msgid ""
"The "
"[LinuxBIOS](https://web.archive.org/web/20070430170020/http://www.linuxbios.org/Welcome_to_LinuxBIOS) "
"project was created in 1999 by Ron Minnich, Stefan Reinauer and others. It "
"is not much younger than UEFI, but they were already experimenting the idea "
"of running Linux as firmware. Like many great ideas, it was way ahead of its "
"time. At that time Linux was not mature enough to be used in a hardware "
"initialization project, and while LinuxBIOS was successful in several "
"performance-and-reliability critical environments, it didn't see mass "
"adoption."
msgstr ""

#: src/history.md:31
msgid "In 2008 LinuxBIOS became [coreboot](https://www.coreboot.org/)."
msgstr ""

#: src/history.md:33
msgid "LinuxBoot"
msgstr ""

#: src/history.md:35
msgid "NERF"
msgstr ""

#: src/history.md:37
msgid ""
"This is the original name for the stripped UEFI, plus Linux, plus u-root. "
"The name stands for Non-Extensible Reduced Firmware, as opposed to UEFI's "
"Unified Extensible Firmware Interface. Basically, saying that NERF is an "
"UEFI replacement that prefers to be more compact, less extensible, and a bit "
"more opinionated. While extensibility is nice and often desirable, too much "
"extensibility and too many \"yes\" can make a complex project very hard to "
"maintain and keep secure."
msgstr ""

#: src/history.md:45
msgid ""
"NERF was created by Ron Minnich while at Google in 2017. The project grew "
"and was maintained by Google's \"NERF team\"."
msgstr ""

#: src/history.md:48
msgid ""
"NERF eventually became the "
"[linuxboot](https://github.com/linuxboot/linuxboot/) build system."
msgstr ""

#: src/history.md:53
msgid ""
"[Heads](https://github.com/linuxboot/heads) is an open source firmware for "
"laptops and servers created by  Trammell Hudson (a.k.a. osreasrch), aimed at "
"strong platform security. It is currently maintained by Thierry Laurion."
msgstr ""

#: src/history.md:59
msgid "[osresearch.net](https://osresearch.net/)"
msgstr ""

#: src/history.md:60
msgid "[trmm.net/NERF](https://trmm.net/NERF/)"
msgstr ""

#: src/history.md:61
msgid ""
"[NERF-Projekt statt "
"UEFI](https://www.golem.de/news/freie-linux-firmware-google-will-server-ohne-intel-me-und-uefi-1710-130840-2.html)"
msgstr ""

#: src/history.md:62
msgid ""
"[Bringing Linux back to the Server BIOS with "
"LinuxBoot](https://www.twosigma.com/articles/bringing-linux-back-to-the-server-bios-with-linuxboot/)"
msgstr ""

#: src/history.md:63
msgid ""
"[LinuxBoot: A Fast, Reliable Open Source Firmware for Linux "
"Servers](https://www.twosigma.com/articles/linuxboot-a-fast-reliable-open-source-firmware-for-linux-servers/)"
msgstr ""

#: src/history.md:64
msgid ""
"[safeboot: Improving the Safety of Booting Linux on Normal "
"Laptops](https://www.twosigma.com/articles/safeboot-improving-the-safety-of-booting-linux-on-normal-laptops/)"
msgstr ""

#: src/history.md:66
msgid "Open Platform Firmware"
msgstr ""

#: src/history.md:68
msgid ""
"[Open Platform "
"Firmware](https://www.opencompute.org/projects/open-system-firmware) (OPF), "
"formerly Open System Firmware (OSF), is an official subproject of the [Open "
"Compute Project](https://www.opencompute.org) (OCP). OPF has been developed "
"in the open, by various members of OCP that were interested in having open "
"source system firmware. OPF defines a set of guidelines with contributions "
"from Microsoft, Google, Facebook, Intel, 9elements, Two Sigma, and several "
"other companies."
msgstr ""

#: src/history.md:77
msgid ""
"The important thing to keep in mind is that **Open Platform Firmware is a "
"project name**, not an implementation, nor an idea. An implementation (like "
"LinuxBoot or OpenEDK2) can be OPF-compliant if it follows the aforementioned "
"guidelines."
msgstr ""

#: src/history.md:81
msgid "Currently, Open Platform Firmware has two work streams:"
msgstr ""

#: src/history.md:83
msgid ""
"LinuxBoot, led by Google, Facebook, 9elements, ITRenew, TwoSigma, and others"
msgstr ""

#: src/history.md:84
msgid "OpenEDK II, led by Microsoft and Intel"
msgstr ""

#: src/case_studies/index.md:3
msgid "This chapter contains case studies for various solutions."
msgstr ""

#: src/case_studies/index.md:5
msgid "Table of Contents"
msgstr ""

#: src/case_studies/index.md:7
msgid "[Ampere study](Ampere_study.md)"
msgstr ""

#: src/case_studies/index.md:8
msgid "[Google study](Google_study.md)"
msgstr ""

#: src/case_studies/index.md:9
msgid "[OCP TiogaPass](TiogaPass.md)"
msgstr ""

#: src/case_studies/Ampere_study.md:1
msgid "LinuxBoot on Ampere Mt. Jade Platform"
msgstr ""

#: src/case_studies/Ampere_study.md:3
msgid ""
"The Ampere Altra Family processor based Mt. Jade platform is a "
"high-performance ARM server platform, offering up to 256 processor cores in "
"a dual socket configuration. The Tianocore EDK2 firmware for the Mt. Jade "
"platform has been fully upstreamed to the tianocore/edk2-platforms "
"repository, enabling the community to build and experiment with the "
"platform's firmware using entirely open-source code. It also supports "
"LinuxBoot, an open-source firmware framework that reduces boot time, "
"enhances security, and increases flexibility compared to standard UEFI "
"firmware."
msgstr ""

#: src/case_studies/Ampere_study.md:12
msgid ""
"Mt. Jade has also achieved a significant milestone by becoming [the first "
"server certified under the Arm SystemReady LS certification "
"program](https://community.arm.com/arm-community-blogs/b/architectures-and-processors-blog/posts/arm-systemready-ls). "
"SystemReady LS ensures compliance with standardized boot and runtime "
"environments for Linux-based systems, enabling seamless deployment across "
"diverse hardware.  This certification further emphasizes Mt. Jade's "
"readiness for enterprise and cloud-scale adoption by providing assurance of "
"compatibility, performance, and reliability."
msgstr ""

#: src/case_studies/Ampere_study.md:21
msgid ""
"This case study explores the LinuxBoot implementation on the Ampere Mt. Jade "
"platform, inspired by the approach used in [Google's LinuxBoot "
"deployment](Google_study.md)."
msgstr ""

#: src/case_studies/Ampere_study.md:25
msgid "Ampere EDK2-LinuxBoot Components"
msgstr ""

#: src/case_studies/Ampere_study.md:27
msgid ""
"The Mt. Jade platform embraces a hybrid firmware architecture, combining "
"UEFI/EDK2 for hardware initialization and LinuxBoot for advanced boot "
"functionalities. The platform aligns closely with step 6 in the LinuxBoot "
"adoption model."
msgstr ""

#: src/case_studies/Ampere_study.md:34
msgid ""
"The entire boot firmware stack for the Mt. Jade is open source and available "
"in the Github."
msgstr ""

#: src/case_studies/Ampere_study.md:37
msgid ""
"**EDK2**: The PEI and minimal (stripped-down) DXE drivers, including both "
"common and platform code, are fully open source and resides in Tianocore "
"edk2-platforms and edk2 repositories."
msgstr ""

#: src/case_studies/Ampere_study.md:40
msgid ""
"**LinuxBoot**: The LinuxBoot binary ([flashkernel](../glossary.md)) for Mt. "
"Jade is supported in the "
"[linuxboot/linuxboot](https://github.com/linuxboot/linuxboot/tree/main/mainboards/ampere/jade) "
"repository."
msgstr ""

#: src/case_studies/Ampere_study.md:45
msgid "Ampere Solution for LinuxBoot as a Boot Device Selection"
msgstr ""

#: src/case_studies/Ampere_study.md:47
msgid ""
"Ampere has implemented and successfully upstreamed a solution for "
"integrating LinuxBoot as a Boot Device Selection (BDS) option into the "
"TianoCore EDK2 framework, as seen in commit [ArmPkg: Implement "
"PlatformBootManagerLib for "
"LinuxBoot](https://github.com/tianocore/edk2/commit/62540372230ecb5318a9c8a40580a14beeb9ded0). "
"This innovation simplifies the boot process for the Mt. Jade platform and "
"aligns with LinuxBoot's goals of efficiency and flexibility."
msgstr ""

#: src/case_studies/Ampere_study.md:55
msgid ""
"Unlike the earlier practice that replaced the UEFI Shell with a LinuxBoot "
"flashkernel, Ampere's solution introduces a custom BDS implementation that "
"directly boots into the LinuxBoot environment as the active boot option. "
"This approach bypasses the need to load the UEFI Shell or UiApp (UEFI Setup "
"Menu), which depend on numerous unnecessary DXE drivers."
msgstr ""

#: src/case_studies/Ampere_study.md:61
msgid ""
"To further enhance flexibility, Ampere introduced a new GUID specifically "
"for the LinuxBoot binary, ensuring clear separation from the UEFI Shell "
"GUID. This distinction allows precise identification of LinuxBoot components "
"in the firmware."
msgstr ""

#: src/case_studies/Ampere_study.md:66
msgid "Build Process"
msgstr ""

#: src/case_studies/Ampere_study.md:68
msgid ""
"Building a flashable EDK2 firmware image with an integrated LinuxBoot "
"flashkernel for the Ampere Mt. Jade platform involves two main steps: "
"building the LinuxBoot flashkernel and integrating it into the EDK2 firmware "
"build."
msgstr ""

#: src/case_studies/Ampere_study.md:72
msgid "Step 1: Build the LinuxBoot Flashkernel"
msgstr ""

#: src/case_studies/Ampere_study.md:74
msgid "The LinuxBoot flash kernel is built as follows:"
msgstr ""

#: src/case_studies/Ampere_study.md:81
msgid ""
"After the build process completes, the flash kernel will be located at: "
"linuxboot/mainboards/ampere/jade/flashkernel"
msgstr ""

#: src/case_studies/Ampere_study.md:84
msgid "Step 2: Build the EDK2 Firmware Image with the Flash Kernel"
msgstr ""

#: src/case_studies/Ampere_study.md:86
msgid ""
"The EDK2 firmware image is built with the LinuxBoot flashkernel integrated "
"into the flash image using the following steps:"
msgstr ""

#: src/case_studies/Ampere_study.md:96
msgid ""
"The `buildfw.sh` script automatically integrates the LinuxBoot flash kernel "
"(provided via the -l option) as part of the final EDK2 firmware image."
msgstr ""

#: src/case_studies/Ampere_study.md:99
msgid ""
"This process generates a flashable EDK2 firmware image with embedded "
"LinuxBoot, ready for deployment on the Ampere Mt. Jade platform."
msgstr ""

#: src/case_studies/Ampere_study.md:102
msgid "Booting with LinuxBoot"
msgstr ""

#: src/case_studies/Ampere_study.md:104
msgid ""
"When powered on, the system will boot into the u-root and automatically "
"kexec to the target OS."
msgstr ""

#: src/case_studies/Ampere_study.md:107
msgid ""
"```text\n"
"Run /init as init process\n"
"1970/01/01 00:00:10 Welcome to u-root!\n"
"                              _\n"
"   _   _      _ __ ___   ___ | |_\n"
"  | | | |____| '__/ _ \\ / _ \\| __|\n"
"  | |_| |____| | | (_) | (_) | |_\n"
"   \\__,_|    |_|  \\___/ \\___/ \\__|\n"
"\n"
"cgroup: Unknown subsys name 'perf_event'\n"
"init: 1970/01/01 00:00:10 Deprecation warning: use UROOT_NOHWRNG=1 on kernel "
"cmdline instead of uroot.nohwrng\n"
"1970/01/01 00:00:10 Booting from the following block devices: "
"[BlockDevice(name=nvme0n1, fs_uuid=) BlockDevice(name=nvme0n1p1, "
"fs_uuid=d6c6-6306) BlockDevice(name=nvme0n1p2, "
"fs_uuid=63402158-6266-48fb-b602-5f83f26bd0b9) BlockDevice(name=nvme0n1p3, "
"fs_uuid=) BlockDevice(name=nvme1n1, fs_uuid=) BlockDevice(name=nvme1n1p1, "
"fs_uuid=525c-92fb)]\n"
"1970/01/01 00:00:10 [grub] Got config file "
"file:///tmp/u-root-mounts3457412855/nvme0n1p1/EFI/ubuntu/grub.cfg:\n"
"search.fs_uuid 63402158-6266-48fb-b602-5f83f26bd0b9 root\n"
"set prefix=($root)'/grub'\n"
"configfile $prefix/grub.cfg\n"
"\n"
"1970/01/01 00:00:10 Warning: Grub parser could not parse [\"search\" "
"\"--fs-uuid\" \"63402158-6266-48fb-b602-5f83f26bd0b9\" \"root\"]\n"
"1970/01/01 00:00:10 [grub] Got config file "
"file:///tmp/u-root-mounts3457412855/nvme0n1p2/grub/grub.cfg\n"
"1970/01/01 00:00:10 Error: Expected 1 device with UUID "
"\"1334d6c5-c16f-46ba-9120-5127ae43bf63\", found 0\n"
"1970/01/01 00:00:10 Error: Expected 1 device with UUID "
"\"1334d6c5-c16f-46ba-9120-5127ae43bf63\", found 0\n"
"\n"
"\n"
"Welcome to LinuxBoot's Menu\n"
"\n"
"Enter a number to boot a kernel:\n"
"\n"
"1.  Ubuntu\n"
"\n"
"2.  Ubuntu, with Linux 6.8.0-49-generic\n"
"\n"
"3.  Ubuntu, with Linux 6.8.0-49-generic (recovery mode)\n"
"\n"
"4.  Ubuntu, with Linux 6.8.0-48-generic\n"
"\n"
"5.  Ubuntu, with Linux 6.8.0-48-generic (recovery mode)\n"
"\n"
"6.  Reboot\n"
"\n"
"7.  Enter a LinuxBoot shell\n"
"\n"
"\n"
"Enter an option ('01' is the default, 'e' to edit kernel cmdline):\n"
" > 07\n"
"\n"
"> dmidecode -t 4\n"
"# dmidecode-go\n"
"Reading SMBIOS/DMI data from sysfs.\n"
"SMBIOS 3.3.0 present.\n"
"\n"
"Handle 0x0003, DMI type 4, 51 bytes\n"
"Processor Information\n"
"        Socket Designation: CPU01\n"
"        Type: Central Processor\n"
"        Family: ARMv8\n"
"        Manufacturer: Ampere(R)\n"
"        ID: 01 00 16 0A A1 00 00 00\n"
"        Signature: Implementor 0x0a, Variant 0x1, Architecture 6, Part "
"0x000, Revision 1\n"
"        Version: Ampere(R) Altra(R) Processor\n"
"        Voltage: 1.0 V\n"
"        External Clock: 25 MHz\n"
"        Max Speed: 3000 MHz\n"
"        Current Speed: 3000 MHz\n"
"        Status: Populated, Enabled\n"
"        Upgrade: Unknown\n"
"        L1 Cache Handle: 0x0001\n"
"        L2 Cache Handle: 0x0002\n"
"        L3 Cache Handle: Not Provided\n"
"        Serial Number: 000000000000000002550904033865B4\n"
"        Asset Tag: Not Set\n"
"        Part Number: Q80-30\n"
"        Core Count: 80\n"
"        Core Enabled: 80\n"
"        Thread Count: 80\n"
"        Characteristics:\n"
"                64-bit capable\n"
"                Multi-Core\n"
"                Execute Protection\n"
"                Enhanced Virtualization\n"
"                Power/Performance Control\n"
"\n"
"Handle 0x0007, DMI type 4, 51 bytes\n"
"Processor Information\n"
"        Socket Designation: CPU02\n"
"        Type: Central Processor\n"
"        Family: ARMv8\n"
"        Manufacturer: Ampere(R)\n"
"        ID: 01 00 16 0A A1 00 00 00\n"
"        Signature: Implementor 0x0a, Variant 0x1, Architecture 6, Part "
"0x000, Revision 1\n"
"        Version: Ampere(R) Altra(R) Processor\n"
"        Voltage: 1.0 V\n"
"        External Clock: 25 MHz\n"
"        Max Speed: 3000 MHz\n"
"        Current Speed: 3000 MHz\n"
"        Status: Populated, Enabled\n"
"        Upgrade: Unknown\n"
"        L1 Cache Handle: 0x0005\n"
"        L2 Cache Handle: 0x0006\n"
"        L3 Cache Handle: Not Provided\n"
"        Serial Number: 000000000000000002560909033865B4\n"
"        Asset Tag: Not Set\n"
"        Part Number: Q80-30\n"
"        Core Count: 80\n"
"        Core Enabled: 80\n"
"        Thread Count: 80\n"
"        Characteristics:\n"
"                64-bit capable\n"
"                Multi-Core\n"
"                Execute Protection\n"
"                Enhanced Virtualization\n"
"                Power/Performance Control\n"
"\n"
">\n"
"M-? toggle key help • C-d erase/stop • C-c clear/cancel • C-r search hist …\n"
"```"
msgstr ""

#: src/case_studies/Ampere_study.md:223
msgid "Future Work"
msgstr ""

#: src/case_studies/Ampere_study.md:225
msgid ""
"While the LinuxBoot implementation on the Ampere Mt. Jade platform "
"represents a significant milestone, several advanced features and "
"improvements remain to be explored. These enhancements would extend the "
"platform's capabilities, improve its usability, and reinforce its position "
"as a leading open source firmware solution. Key areas for future development "
"include:"
msgstr ""

#: src/case_studies/Ampere_study.md:231
msgid "Secure Boot with LinuxBoot"
msgstr ""

#: src/case_studies/Ampere_study.md:233
msgid ""
"One of the critical areas for future development is enabling secure boot "
"verification for the target operating system. In the LinuxBoot environment, "
"the target OS is typically booted using kexec. However, it is unclear how "
"Secure Boot operates in this context, as kexec bypasses traditional "
"firmware-controlled secure boot mechanisms. Future work should investigate "
"how to extend Secure Boot principles to kexec, ensuring that the OS kernel "
"and its components are verified and authenticated before execution. This may "
"involve implementing signature checks and utilizing trusted certificate "
"chains directly within the LinuxBoot environment to mimic the functionality "
"of UEFI Secure Boot during the kexec process."
msgstr ""

#: src/case_studies/Ampere_study.md:244
msgid "TPM Support"
msgstr ""

#: src/case_studies/Ampere_study.md:246
msgid ""
"The platform supports TPM, but its integration with LinuxBoot is yet to be "
"defined. Future work could explore utilizing the TPM for secure boot "
"measurements, and system integrity attestation."
msgstr ""

#: src/case_studies/Ampere_study.md:250
msgid "Expanding Support for Additional Ampere Platforms"
msgstr ""

#: src/case_studies/Ampere_study.md:252
msgid ""
"Building on the success of LinuxBoot on Mt. Jade, future efforts should "
"expand support to other Ampere platforms.  This would ensure broader "
"adoption and usability across different hardware configurations."
msgstr ""

#: src/case_studies/Ampere_study.md:256
msgid "Optimizing the Transition Between UEFI and LinuxBoot"
msgstr ""

#: src/case_studies/Ampere_study.md:258
msgid ""
"Improving the efficiency of the handoff between UEFI and LinuxBoot could "
"further reduce boot times.  This optimization would involve refining the "
"initialization process and minimizing redundant operations during the "
"handoff."
msgstr ""

#: src/case_studies/Ampere_study.md:262
msgid "Advanced Diagnostics and Monitoring Tools"
msgstr ""

#: src/case_studies/Ampere_study.md:264
msgid ""
"Adding more diagnostic and monitoring tools to the LinuxBoot u-root "
"environment would enhance debugging and system management.  These tools "
"could provide deeper insights into system performance and potential issues, "
"improving reliability and maintainability."
msgstr ""

#: src/case_studies/Ampere_study.md:269
msgid "See Also"
msgstr ""

#: src/case_studies/Ampere_study.md:271
msgid ""
"[LinuxBoot on Ampere Platforms: A new (old) approach to "
"firmware](https://amperecomputing.com/blogs/linuxboot-on-ampere-platforms--a-new-old-approach-to-firmware)"
msgstr ""

#: src/case_studies/Google_study.md:1
msgid "The LinuxBoot project at Google"
msgstr ""

#: src/case_studies/Google_study.md:3
msgid ""
"Google runs workloads across a number of clusters each with up to tens of "
"thousands of machines. Firmware runs on these machines when they first start "
"up. Google is pushing the state-of-the-art in many places including "
"firmware. The discussion here about Google's implementation of LinuxBoot is "
"limited to replacing specific UEFI [firmware](../glossary.md) functionality "
"with a Linux kernel and runtime. Over the years this project has grown to "
"include various initiatives with the overarching goal of moving from "
"obscure, complex firmware to simpler, open source firmware."
msgstr ""

#: src/case_studies/Google_study.md:12
msgid "Team"
msgstr ""

#: src/case_studies/Google_study.md:14
msgid ""
"There have been a number of contributors to the Google LinuxBoot project "
"including:"
msgstr ""

#: src/case_studies/Google_study.md:17
msgid "Ron Minnich (technical lead)"
msgstr ""

#: src/case_studies/Google_study.md:18
msgid "Gan-shun Lim"
msgstr ""

#: src/case_studies/Google_study.md:19
msgid "Ryan O'Leary"
msgstr ""

#: src/case_studies/Google_study.md:20
msgid "Prachi Laud"
msgstr ""

#: src/case_studies/Google_study.md:21
msgid "Chris Koch"
msgstr ""

#: src/case_studies/Google_study.md:22
msgid "Xuan Chen"
msgstr ""

#: src/case_studies/Google_study.md:23
msgid "Andrew Sun"
msgstr ""

#: src/case_studies/Google_study.md:25
msgid ""
"Ryan O'Leary is one of the Open Compute Platform Foundation [Open System "
"Firmware project](https://www.opencompute.org/projects/open-system-firmware) "
"volunteer leads and Ron Minnich is the Open Compute Platform Foundation "
"Incubation Committee Representative."
msgstr ""

#: src/case_studies/Google_study.md:30
msgid "Goal"
msgstr ""

#: src/case_studies/Google_study.md:32
msgid ""
"The primary goal of Google's LinuxBoot is to modernize the firmware by "
"simplifying it to technologies engineers understand and trust. In UEFI "
"systems, LinuxBoot consists of a \"full stack\" solution of stripped-down "
"UEFI firmware, a Linux kernel, and an initramfs with tools written in Go. "
"Although these components all make up one bundle stored in ROM, there are "
"three parts: the closed-source EFI firmware, a Linux kernel, and "
"[u-root](../u-root.md). The Linux kernel is an unmodified kernel.  The "
"user-space initramfs image with Go tools for system booting is available as "
"u-root. Due to this modularity, LinuxBoot can be used with a variety of "
"systems. In many cases, for example, the same kernel and initramfs have been "
"used, without recompilation, on both AMD and Intel x86 boards. The UEFI on "
"these boards is always specific to the board, however."
msgstr ""

#: src/case_studies/Google_study.md:46
msgid "Converting a UEFI firmware image to use LinuxBoot"
msgstr ""

#: src/case_studies/Google_study.md:48
msgid ""
"The conversion to LinuxBoot starts with generic UEFI. A UEFI computer boots "
"in four main phases. The security phase (SEC) and the Pre-EFI Initialization "
"Stage (PEI) are responsible for low-level operations to prepare the hardware "
"and are usually specific to the hardware they are implemented for. After "
"these two stages, the Driver Execution Environment (DXE) loads various "
"drivers, and then the Boot Device Select (BDS) phase begins."
msgstr ""

#: src/case_studies/Google_study.md:56
msgid ""
"It is not possible to modify the SEC and PEI stages, as their components are "
"tightly coupled to the chips on the board; even small changes to the chips "
"require new SEC and PEI stages. LinuxBoot starts during the DXE stage, "
"resulting in most of the drivers (and their associated attack surface) not "
"being loaded. Instead, a Linux kernel is loaded as if it were a driver. By "
"loading during the DXE, LinuxBoot runs after the first two stages of the "
"UEFI, but takes over after that point, replacing the UEFI drivers. It "
"therefore completely replaces a large portion of the boot process."
msgstr ""

#: src/case_studies/Google_study.md:67
msgid "Phases of the project"
msgstr ""

#: src/case_studies/Google_study.md:69
msgid ""
"Google's LinuxBoot project is focused on moving UEFI boot functionality into "
"the kernel and user-space. That is, converting UEFI firmware to run "
"LinuxBoot. The project has taken the standard UEFI boot process and "
"converted it to LinuxBoot for production environments. The steps to reach "
"this goal are described below."
msgstr ""

#: src/case_studies/Google_study.md:75
msgid "Step 1. Reduce or replace UEFI components"
msgstr ""

#: src/case_studies/Google_study.md:77
msgid ""
"UEFI contains proprietary, closed-source, vendor-supplied firmware drivers "
"and firmware. LinuxBoot replaces many Driver Execution Environment (DXE) "
"modules used by UEFI and other firmware, particularly the network stack and "
"file system modules, with Linux applications."
msgstr ""

#: src/case_studies/Google_study.md:83
msgid ""
"The following diagram shows the phases of the UEFI boot process. The items "
"in <span style=\"color:red\">red</span> are components that are either "
"reduced or eliminated with LinuxBoot. The <span style=\"color:blue\">dark "
"blue</span> items on the left cannot be changed."
msgstr ""

#: src/case_studies/Google_study.md:91
msgid ""
"In the real FLASH part, the SEC and PEI are actually only 10% of total, so "
"we reduce the size of those boxes in this and following diagrams."
msgstr ""

#: src/case_studies/Google_study.md:96
msgid ""
"Another part of the conversion process was to modify the UEFI boot process "
"to boot a LinuxBoot image as shown below."
msgstr ""

#: src/case_studies/Google_study.md:101
msgid ""
"Step 2. Delete or replace as many proprietary DXEs as required to make step "
"3 work. In most cases, none need to be removed."
msgstr ""

#: src/case_studies/Google_study.md:106
msgid "Step 3. Replace the UEFI shell with a Linux kernel + u-root"
msgstr ""

#: src/case_studies/Google_study.md:110
msgid ""
"When Linux boots it needs a root file system with utilities. LinuxBoot "
"provides a file system based on u-root standard utilities written in Go."
msgstr ""

#: src/case_studies/Google_study.md:114
msgid ""
"Step 4. Through trial and error, continue to remove DXEs until you can't "
"remove anymore."
msgstr ""

#: src/case_studies/Google_study.md:117
msgid ""
"The DXEs are delivered as binary blobs. There are three ways to handle them:"
msgstr ""

#: src/case_studies/Google_study.md:120
msgid ""
"The most desirable is to remove them and let Linux drivers take over what "
"they did. This works well for USB, network, disk, and other drivers, as well "
"as network protocols and file systems. In fact we have resolved many system "
"reliability and performance issues just by removing DXEs!"
msgstr ""

#: src/case_studies/Google_study.md:125
msgid ""
"The second way is to replace the DXE with an open source driver. This is "
"less desirable, as the DXE environment is not as hardened as the Linux "
"kernel environment."
msgstr ""

#: src/case_studies/Google_study.md:128
msgid ""
"The final, least desired option, is to continue to use the DXE. This is "
"required if the DXE contains proprietary code that \"tweaks\" chipset "
"settings, for example, memory timing or other controls, and there is no "
"chance of ever bringing them to open source."
msgstr ""

#: src/case_studies/Google_study.md:136
msgid "Step 5. Replace closed source DXEs with open source"
msgstr ""

#: src/case_studies/Google_study.md:138
msgid "If we can build a DXE from source, we can use `utk` to:"
msgstr ""

#: src/case_studies/Google_study.md:140
msgid "Remove the proprietary one"
msgstr ""

#: src/case_studies/Google_study.md:141
msgid "Replace it with one built from source"
msgstr ""

#: src/case_studies/Google_study.md:145
msgid "Step 6. Next steps: complete LinuxBoot"
msgstr ""

#: src/case_studies/Google_study.md:147
msgid ""
"LinuxBoot is currently in production, but the LinuxBoot project development "
"continues to provide an open-source solution that does the following:"
msgstr ""

#: src/case_studies/Google_study.md:151
msgid ""
"Brings up the Linux kernel as a DXE in flash ROM instead of the UEFI shell."
msgstr ""

#: src/case_studies/Google_study.md:152
msgid ""
"Provides a Go based user-space that can then bring up the kernel that you "
"want to run on the machine."
msgstr ""

#: src/case_studies/Google_study.md:154
msgid ""
"Enables writing traditional firmware applications such as bootloader, "
"debugging, diagnosis, and error detection applications as cross-architecture "
"and cross-platform portable Linux applications."
msgstr ""

#: src/case_studies/Google_study.md:158
msgid "The complete LinuxBoot solution is shown in the following diagram."
msgstr ""

#: src/case_studies/TiogaPass.md:1
msgid "OCP TiogaPass Case Study"
msgstr ""

#: src/case_studies/TiogaPass.md:3
msgid ""
"Points of contact: [Jonathan Zhang](https://github.com/jonzhang-fb), [Andrea "
"Barberio](https://github.com/insomniacslk), [David "
"Hendricks](https://github.com/dhendrix), "
"[Adi](https://github.com/agangidi53), [Morgan "
"Jang](https://github.com/morganjangwiwynn), [Johnny "
"Lin](https://github.com/johnnylinwiwynn)"
msgstr ""

#: src/case_studies/TiogaPass.md:11
msgid ""
"This case study describes information for firmware development community to "
"use [OCP](https://www.opencompute.org/) platform TiogaPass, made by [Wiwynn "
"Corporation](http://www.wiwynn.com/english)."
msgstr ""

#: src/case_studies/TiogaPass.md:15
msgid "It contains following sections:"
msgstr ""

#: src/case_studies/TiogaPass.md:17
msgid "[Quick Start](#Quick-Start)"
msgstr ""

#: src/case_studies/TiogaPass.md:18
msgid "[Details](#Details)"
msgstr ""

#: src/case_studies/TiogaPass.md:19
msgid "[How to build](#How-to-build)"
msgstr ""

#: src/case_studies/TiogaPass.md:20
msgid "[How to operate](#How-to-operate)"
msgstr ""

#: src/case_studies/TiogaPass.md:21
msgid "[Platform info](#Platform-info)"
msgstr ""

#: src/case_studies/TiogaPass.md:22
msgid "[Support](#Support)"
msgstr ""

#: src/case_studies/TiogaPass.md:23
msgid "[Hardware support](#Hardware-support)"
msgstr ""

#: src/case_studies/TiogaPass.md:24
msgid "[Community support](#Community-support)"
msgstr ""

#: src/case_studies/TiogaPass.md:25
msgid "[Professional support](#Professional-support)"
msgstr ""

#: src/case_studies/TiogaPass.md:27
msgid "Quick Start"
msgstr ""

#: src/case_studies/TiogaPass.md:29
msgid ""
"[Order the hardware](http://www.wiwynn.com/english) if you have not done so."
msgstr ""

#: src/case_studies/TiogaPass.md:30
msgid ""
"Download or build the firmware binary. The current solution is to boot "
"embedded Linux kernel and initramfs as UEFI payload. Please contact Wiwynn "
"to get a UEFI binary after ordering."
msgstr ""

#: src/case_studies/TiogaPass.md:33
msgid "Flash the firmware."
msgstr ""

#: src/case_studies/TiogaPass.md:34
msgid "Copy the downloaded firmware to OpenBMC."
msgstr ""

#: src/case_studies/TiogaPass.md:35 src/case_studies/TiogaPass.md:40
msgid "From OpenBMC"
msgstr ""

#: src/case_studies/TiogaPass.md:39
msgid "Boot and enjoy."
msgstr ""

#: src/case_studies/TiogaPass.md:46
msgid "Details"
msgstr ""

#: src/case_studies/TiogaPass.md:48
msgid "How to build"
msgstr ""

#: src/case_studies/TiogaPass.md:50
msgid ""
"Follow [Build Details](#Build-Details) for details on how to get the source "
"code, and how to build."
msgstr ""

#: src/case_studies/TiogaPass.md:53
msgid ""
"Boot flow of the current firmware solution is: Power on → minimized UEFI → "
"LinuxBoot → target OS."
msgstr ""

#: src/case_studies/TiogaPass.md:56
msgid ""
"In near feature, the boot flow will be: power on → Coreboot → LinuxBoot → "
"target OS."
msgstr ""

#: src/case_studies/TiogaPass.md:59
msgid "Build Details"
msgstr ""

#: src/case_studies/TiogaPass.md:61
msgid ""
"Download the code from [linuxboot "
"github](https://github.com/linuxboot/linuxboot)"
msgstr ""

#: src/case_studies/TiogaPass.md:62
msgid ""
"```\n"
"  git clone https://github.com/linuxboot/linuxboot.git\n"
"```"
msgstr ""

#: src/case_studies/TiogaPass.md:65
msgid "You need to apply Wiwiynn's linuxboot patch for now"
msgstr ""

#: src/case_studies/TiogaPass.md:66
msgid ""
"```\n"
"cd linuxboot\n"
"wget -O TiogaPass.patch "
"https://github.com/johnnylinwiwynn/linuxboot/commit/28ae8450b3b05c6e6b8c74e29d0974ccf711d5e6.patch\n"
"git am TiogaPass.patch\n"
"```"
msgstr ""

#: src/case_studies/TiogaPass.md:71
msgid ""
"Build the kernel bzImage (has embedded initramfs) for linuxboot, please "
"reference [Building "
"u-root](https://github.com/linuxboot/book/tree/master/coreboot.u-root.systemboot#building-u-root) "
"and [Building a suitable Linux "
"kernel](https://github.com/linuxboot/book/tree/master/coreboot.u-root.systemboot#building-a-suitable-linux-kernel) "
"for how to build the bzImage. You can always customize your Linux kernel "
"configuration to suit your needs, please reference Wiwynn's kernel "
"configuration file as a sample [linux_config](linux_config)."
msgstr ""

#: src/case_studies/TiogaPass.md:77
msgid ""
"Place the tioga.rom into linuxboot/boards/tioga which is provided from "
"Wiwynn after ordering, and also put your bzImage to the root folder of "
"linuxboot, and then make"
msgstr ""

#: src/case_studies/TiogaPass.md:86
msgid "You should see the built image at build/tioga/linuxboot.rom."
msgstr ""

#: src/case_studies/TiogaPass.md:88
msgid "How to operate"
msgstr ""

#: src/case_studies/TiogaPass.md:90
msgid "Follow **TBD section** for details on:"
msgstr ""

#: src/case_studies/TiogaPass.md:92
msgid ""
"How to flash. The image can be flashed either out-of-band, or from LinuxBoot "
"u-root shell, or from targetOS shell."
msgstr ""

#: src/case_studies/TiogaPass.md:94
msgid "How to run LinuxBoot u-root shell commands."
msgstr ""

#: src/case_studies/TiogaPass.md:96
msgid "Platform info"
msgstr ""

#: src/case_studies/TiogaPass.md:98
msgid ""
"The SKU contains TiogaPass board, a debug card, a VGA card, a power adapter. "
"The details can be obtained from the [Wiwynn "
"Corporation](http://www.wiwynn.com/english)."
msgstr ""

#: src/case_studies/TiogaPass.md:101
msgid ""
"Platform design details (including the design spec and schematics) can be "
"found on the [Open Compute Project UfiSpace product "
"page](https://www.opencompute.org/products/108/wiwynn-tioga-pass-standard-sv7220g3-s-2u-ocp-server-up-to-768gb-8gb16gb32gb-ddr4-up-to-2666mts-12-dimm-slots)."
msgstr ""

#: src/case_studies/TiogaPass.md:105
msgid "Support"
msgstr ""

#: src/case_studies/TiogaPass.md:107
msgid "Hardware support"
msgstr ""

#: src/case_studies/TiogaPass.md:109
msgid ""
"Hardware support can be obtained from [Wiwynn "
"Corporation](http://www.wiwynn.com/english)."
msgstr ""

#: src/case_studies/TiogaPass.md:111
msgid "Community support"
msgstr ""

#: src/case_studies/TiogaPass.md:113
msgid ""
"[OCP Open System "
"Firmware](https://www.opencompute.org/projects/open-system-firmware) is "
"where industry collaborates on how to move forward with OSF. The OCP OSF "
"project has regular recorded meetings and a mailing list."
msgstr ""

#: src/case_studies/TiogaPass.md:117
msgid ""
"[LinuxBoot open source community](https://www.linuxboot.org/) is the "
"community you can ask any technical questions. LinuxBoot community has a "
"slack channel, a IRC channel, a mailing list and regular meetings."
msgstr ""

#: src/case_studies/TiogaPass.md:121
msgid "Professional support"
msgstr ""

#: src/case_studies/TiogaPass.md:123
msgid "Following companies provides professional support services:"
msgstr ""

#: src/case_studies/TiogaPass.md:125
msgid "\\** TBD **"
msgstr ""

#: src/faq.md:1
msgid "Frequently asked questions"
msgstr ""

#: src/faq.md:3
msgid "Troubleshooting"
msgstr ""

#: src/faq.md:5
msgid "**Why does the u-root DHCP client take ages?**"
msgstr ""

#: src/faq.md:7
msgid ""
"The problem is a lack of early entropy. If your platform has a hardware "
"random number generator then enable it with `CONFIG_ARCH_RANDOM` and trust "
"it with `CONFIG_RANDOM_TRUST_CPU`. Otherwise, add `uroot.nohwrng` to your "
"kernel command line so u-root use a non-blocking random number generator "
"implementation."
msgstr ""

